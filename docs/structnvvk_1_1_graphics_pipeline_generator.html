<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: nvvk::GraphicsPipelineGenerator Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structnvvk_1_1_graphics_pipeline_generator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structnvvk_1_1_graphics_pipeline_generator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvvk::GraphicsPipelineGenerator Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;pipeline_vk.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30730477e4b464a423b969685b342d60"><td class="memItemLeft" align="right" valign="top"><a id="a30730477e4b464a423b969685b342d60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GraphicsPipelineGenerator</b> (GraphicsPipelineState &amp;pipelineState_)</td></tr>
<tr class="separator:a30730477e4b464a423b969685b342d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462e0b9e6b8bec233a90a87b3359771"><td class="memItemLeft" align="right" valign="top"><a id="af462e0b9e6b8bec233a90a87b3359771"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GraphicsPipelineGenerator</b> (const <a class="el" href="structnvvk_1_1_graphics_pipeline_generator.html">GraphicsPipelineGenerator</a> &amp;src)</td></tr>
<tr class="separator:af462e0b9e6b8bec233a90a87b3359771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2974bf97708ea07235d5a67de07469"><td class="memItemLeft" align="right" valign="top"><a id="a2c2974bf97708ea07235d5a67de07469"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GraphicsPipelineGenerator</b> (VkDevice device_, const VkPipelineLayout &amp;layout, const VkRenderPass &amp;renderPass, GraphicsPipelineState &amp;pipelineState_)</td></tr>
<tr class="separator:a2c2974bf97708ea07235d5a67de07469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aeb9f86eeed1ebe7c8d4aeec66afdbf"><td class="memItemLeft" align="right" valign="top"><a id="a5aeb9f86eeed1ebe7c8d4aeec66afdbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GraphicsPipelineGenerator</b> (VkDevice device_, const VkPipelineLayout &amp;layout, const VkPipelineRenderingCreateInfo &amp;pipelineRenderingCreateInfo, GraphicsPipelineState &amp;pipelineState_)</td></tr>
<tr class="separator:a5aeb9f86eeed1ebe7c8d4aeec66afdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b9e4f480a9d9e14d91affd808d4a77"><td class="memItemLeft" align="right" valign="top"><a id="aa2b9e4f480a9d9e14d91affd808d4a77"></a>
const <a class="el" href="structnvvk_1_1_graphics_pipeline_generator.html">GraphicsPipelineGenerator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structnvvk_1_1_graphics_pipeline_generator.html">GraphicsPipelineGenerator</a> &amp;src)</td></tr>
<tr class="separator:aa2b9e4f480a9d9e14d91affd808d4a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4479f66d466689cfa164b6691e6d4904"><td class="memItemLeft" align="right" valign="top"><a id="a4479f66d466689cfa164b6691e6d4904"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDevice</b> (VkDevice device_)</td></tr>
<tr class="separator:a4479f66d466689cfa164b6691e6d4904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3794ed0619a0c1ceff86dc158d1e81"><td class="memItemLeft" align="right" valign="top"><a id="adc3794ed0619a0c1ceff86dc158d1e81"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setRenderPass</b> (VkRenderPass renderPass)</td></tr>
<tr class="separator:adc3794ed0619a0c1ceff86dc158d1e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f67b944e910f38c5914bfa914e8bb5"><td class="memItemLeft" align="right" valign="top"><a id="ac4f67b944e910f38c5914bfa914e8bb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setPipelineRenderingCreateInfo</b> (const VkPipelineRenderingCreateInfo &amp;pipelineRenderingCreateInfo)</td></tr>
<tr class="separator:ac4f67b944e910f38c5914bfa914e8bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3597121615042e3a047e9c1855a6729"><td class="memItemLeft" align="right" valign="top"><a id="ac3597121615042e3a047e9c1855a6729"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setLayout</b> (VkPipelineLayout layout)</td></tr>
<tr class="separator:ac3597121615042e3a047e9c1855a6729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3b756c796c220dbbb4d717abb3a794"><td class="memItemLeft" align="right" valign="top"><a id="a9c3b756c796c220dbbb4d717abb3a794"></a>
VkPipelineShaderStageCreateInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addShader</b> (const std::string &amp;code, VkShaderStageFlagBits stage, const char *entryPoint=&quot;main&quot;)</td></tr>
<tr class="separator:a9c3b756c796c220dbbb4d717abb3a794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87739daddba8beec3af1453a2aa9ad8"><td class="memTemplParams" colspan="2"><a id="ab87739daddba8beec3af1453a2aa9ad8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab87739daddba8beec3af1453a2aa9ad8"><td class="memTemplItemLeft" align="right" valign="top">VkPipelineShaderStageCreateInfo &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addShader</b> (const std::vector&lt; T &gt; &amp;code, VkShaderStageFlagBits stage, const char *entryPoint=&quot;main&quot;)</td></tr>
<tr class="separator:ab87739daddba8beec3af1453a2aa9ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee57a4601b65db3323a0b40142d4529c"><td class="memItemLeft" align="right" valign="top"><a id="aee57a4601b65db3323a0b40142d4529c"></a>
VkPipelineShaderStageCreateInfo &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addShader</b> (VkShaderModule shaderModule, VkShaderStageFlagBits stage, const char *entryPoint=&quot;main&quot;)</td></tr>
<tr class="separator:aee57a4601b65db3323a0b40142d4529c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d52a4b111b45e7ef28db9d95bc6831"><td class="memItemLeft" align="right" valign="top"><a id="a74d52a4b111b45e7ef28db9d95bc6831"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearShaders</b> ()</td></tr>
<tr class="separator:a74d52a4b111b45e7ef28db9d95bc6831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab7853c3625e951ab8e966939da62c8"><td class="memItemLeft" align="right" valign="top"><a id="a6ab7853c3625e951ab8e966939da62c8"></a>
VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><b>getShaderModule</b> (size_t index) const</td></tr>
<tr class="separator:a6ab7853c3625e951ab8e966939da62c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a6f2820d0cde0f7b1553ee0dbf69d3"><td class="memItemLeft" align="right" valign="top"><a id="a91a6f2820d0cde0f7b1553ee0dbf69d3"></a>
VkPipeline&#160;</td><td class="memItemRight" valign="bottom"><b>createPipeline</b> (const VkPipelineCache &amp;cache)</td></tr>
<tr class="separator:a91a6f2820d0cde0f7b1553ee0dbf69d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3c4b76d51a4e492a366b8bf018db23"><td class="memItemLeft" align="right" valign="top"><a id="abc3c4b76d51a4e492a366b8bf018db23"></a>
VkPipeline&#160;</td><td class="memItemRight" valign="bottom"><b>createPipeline</b> ()</td></tr>
<tr class="separator:abc3c4b76d51a4e492a366b8bf018db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea134691bba5bbdb752eac1f2786b91"><td class="memItemLeft" align="right" valign="top"><a id="aeea134691bba5bbdb752eac1f2786b91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroyShaderModules</b> ()</td></tr>
<tr class="separator:aeea134691bba5bbdb752eac1f2786b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c40ded70b309e561b09732c3ccbf44"><td class="memItemLeft" align="right" valign="top"><a id="a50c40ded70b309e561b09732c3ccbf44"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update</b> ()</td></tr>
<tr class="separator:a50c40ded70b309e561b09732c3ccbf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa2dcb7fa1fd115595dcff0acfa3e7e25"><td class="memItemLeft" align="right" valign="top"><a id="aa2dcb7fa1fd115595dcff0acfa3e7e25"></a>
VkGraphicsPipelineCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>createInfo</b> {VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO}</td></tr>
<tr class="separator:aa2dcb7fa1fd115595dcff0acfa3e7e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md198"></a>
struct nvvk::GraphicsPipelineState</h1>
<p>Most graphic pipelines have similar states, therefore the helper <code>GraphicsPipelineStage</code> holds all the elements and initialize the structures with the proper default values, such as the primitive type, <code>PipelineColorBlendAttachmentState</code> with their mask, <code>DynamicState</code> for viewport and scissor, adjust depth test if enabled, line width to 1 pixel, for example.</p>
<p>Example of usage : </p><div class="fragment"><div class="line">nvvk::GraphicsPipelineState pipelineState();</div>
<div class="line">pipelineState.depthStencilState.setDepthTestEnable(<span class="keyword">true</span>);</div>
<div class="line">pipelineState.rasterizationState.setCullMode(vk::CullModeFlagBits::eNone);</div>
<div class="line">pipelineState.addBindingDescription({0, <span class="keyword">sizeof</span>(Vertex)});</div>
<div class="line">pipelineState.addAttributeDescriptions ({</div>
<div class="line">    {0, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, pos))},</div>
<div class="line">    {1, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, nrm))},</div>
<div class="line">    {2, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, col))}});</div>
</div><!-- fragment --><p> @DOC_END */</p>
<p>struct GraphicsPipelineState { // Initialize the state to common values: triangle list topology, depth test enabled, // dynamic viewport and scissor, one render target, blending disabled GraphicsPipelineState() { sampleMask = ~0;</p>
<p>rasterizationState.flags = {}; rasterizationState.depthClampEnable = {}; rasterizationState.rasterizerDiscardEnable = {}; setValue(rasterizationState.polygonMode, VK_POLYGON_MODE_FILL); setValue(rasterizationState.cullMode, VK_CULL_MODE_BACK_BIT); setValue(rasterizationState.frontFace, VK_FRONT_FACE_COUNTER_CLOCKWISE);</p>
<p>rasterizationState.depthBiasEnable = {}; rasterizationState.depthBiasConstantFactor = {}; rasterizationState.depthBiasClamp = {}; rasterizationState.depthBiasSlopeFactor = {}; rasterizationState.lineWidth = 1.f;</p>
<p>inputAssemblyState.flags = {}; setValue(inputAssemblyState.topology, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST); inputAssemblyState.primitiveRestartEnable = {};</p>
<pre class="fragment">colorBlendState.flags         = {};
colorBlendState.logicOpEnable = {};
setValue(colorBlendState.logicOp, VK_LOGIC_OP_CLEAR);
colorBlendState.attachmentCount = {};
colorBlendState.pAttachments    = {};
for(int i = 0; i &lt; 4; i++)
{
  colorBlendState.blendConstants[i] = 0.f;
}


dynamicState.flags             = {};
dynamicState.dynamicStateCount = {};
dynamicState.pDynamicStates    = {};


vertexInputState.flags                           = {};
vertexInputState.vertexBindingDescriptionCount   = {};
vertexInputState.pVertexBindingDescriptions      = {};
vertexInputState.vertexAttributeDescriptionCount = {};
vertexInputState.pVertexAttributeDescriptions    = {};


viewportState.flags         = {};
viewportState.viewportCount = {};
viewportState.pViewports    = {};
viewportState.scissorCount  = {};
viewportState.pScissors     = {};


depthStencilState.flags            = {};
depthStencilState.depthTestEnable  = VK_TRUE;
depthStencilState.depthWriteEnable = VK_TRUE;
setValue(depthStencilState.depthCompareOp, VK_COMPARE_OP_LESS_OR_EQUAL);
depthStencilState.depthBoundsTestEnable = {};
depthStencilState.stencilTestEnable     = {};
setValue(depthStencilState.front, VkStencilOpState());
setValue(depthStencilState.back, VkStencilOpState());
depthStencilState.minDepthBounds = {};
depthStencilState.maxDepthBounds = {};

setValue(multisampleState.rasterizationSamples, VK_SAMPLE_COUNT_1_BIT);
</pre><p> }</p>
<p>GraphicsPipelineState(const GraphicsPipelineState&amp; src) = default;</p>
<p>// Attach the pointer values of the structures to the internal arrays void update() { multisampleState.pSampleMask = </p>
<p>colorBlendState.attachmentCount = (uint32_t)blendAttachmentStates.size(); colorBlendState.pAttachments = blendAttachmentStates.data();</p>
<p>dynamicState.dynamicStateCount = (uint32_t)dynamicStateEnables.size(); dynamicState.pDynamicStates = dynamicStateEnables.data();</p>
<p>vertexInputState.vertexAttributeDescriptionCount = static_cast&lt;uint32_t&gt;(attributeDescriptions.size()); vertexInputState.vertexBindingDescriptionCount = static_cast&lt;uint32_t&gt;(bindingDescriptions.size()); vertexInputState.pVertexBindingDescriptions = bindingDescriptions.data(); vertexInputState.pVertexAttributeDescriptions = attributeDescriptions.data();</p>
<p>if(viewports.empty()) { viewportState.viewportCount = 1; viewportState.pViewports = nullptr; } else { viewportState.viewportCount = (uint32_t)viewports.size(); viewportState.pViewports = viewports.data(); }</p>
<p>if(scissors.empty()) { viewportState.scissorCount = 1; viewportState.pScissors = nullptr; } else { viewportState.scissorCount = (uint32_t)scissors.size(); viewportState.pScissors = scissors.data(); } }</p>
<p>static inline VkPipelineColorBlendAttachmentState makePipelineColorBlendAttachmentState( VkColorComponentFlags colorWriteMask_ = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT, VkBool32 blendEnable_ = 0, VkBlendFactor srcColorBlendFactor_ = VK_BLEND_FACTOR_ZERO, VkBlendFactor dstColorBlendFactor_ = VK_BLEND_FACTOR_ZERO, VkBlendOp colorBlendOp_ = VK_BLEND_OP_ADD, VkBlendFactor srcAlphaBlendFactor_ = VK_BLEND_FACTOR_ZERO, VkBlendFactor dstAlphaBlendFactor_ = VK_BLEND_FACTOR_ZERO, VkBlendOp alphaBlendOp_ = VK_BLEND_OP_ADD) { VkPipelineColorBlendAttachmentState res;</p>
<p>res.blendEnable = blendEnable_; res.srcColorBlendFactor = srcColorBlendFactor_; res.dstColorBlendFactor = dstColorBlendFactor_; res.colorBlendOp = colorBlendOp_; res.srcAlphaBlendFactor = srcAlphaBlendFactor_; res.dstAlphaBlendFactor = dstAlphaBlendFactor_; res.alphaBlendOp = alphaBlendOp_; res.colorWriteMask = colorWriteMask_; return res; }</p>
<p>static inline VkVertexInputBindingDescription makeVertexInputBinding(uint32_t binding, uint32_t stride, VkVertexInputRate rate = VK_VERTEX_INPUT_RATE_VERTEX) { VkVertexInputBindingDescription vertexBinding; vertexBinding.binding = binding; vertexBinding.inputRate = rate; vertexBinding.stride = stride; return vertexBinding; }</p>
<p>static inline VkVertexInputAttributeDescription makeVertexInputAttribute(uint32_t location, uint32_t binding, VkFormat format, uint32_t offset) { VkVertexInputAttributeDescription attrib; attrib.binding = binding; attrib.location = location; attrib.format = format; attrib.offset = offset; return attrib; }</p>
<p>void clearBlendAttachmentStates() { blendAttachmentStates.clear(); } void setBlendAttachmentCount(uint32_t attachmentCount) { blendAttachmentStates.resize(attachmentCount); }</p>
<p>void setBlendAttachmentState(uint32_t attachment, const VkPipelineColorBlendAttachmentState&amp; blendState) { assert(attachment &lt; blendAttachmentStates.size()); if(attachment &lt;= blendAttachmentStates.size()) { blendAttachmentStates[attachment] = blendState; } }</p>
<p>void setBlendAttachmentColorMask(uint32_t attachment, VkColorComponentFlags mask) { assert(attachment &lt; blendAttachmentStates.size()); if(attachment &lt;= blendAttachmentStates.size()) { blendAttachmentStates[attachment].colorWriteMask = mask; } }</p>
<p>uint32_t addBlendAttachmentState(const VkPipelineColorBlendAttachmentState&amp; blendState) { blendAttachmentStates.push_back(blendState); return (uint32_t)(blendAttachmentStates.size() - 1); }</p>
<p>void clearDynamicStateEnables() { dynamicStateEnables.clear(); } void setDynamicStateEnablesCount(uint32_t dynamicStateCount) { dynamicStateEnables.resize(dynamicStateCount); }</p>
<p>void setDynamicStateEnable(uint32_t state, VkDynamicState dynamicState) { assert(state &lt; dynamicStateEnables.size()); if(state &lt;= dynamicStateEnables.size()) { dynamicStateEnables[state] = dynamicState; } }</p>
<p>uint32_t addDynamicStateEnable(VkDynamicState dynamicState) { dynamicStateEnables.push_back(dynamicState); return (uint32_t)(dynamicStateEnables.size() - 1); }</p>
<p>void clearBindingDescriptions() { bindingDescriptions.clear(); } void setBindingDescriptionsCount(uint32_t bindingDescriptionCount) { bindingDescriptions.resize(bindingDescriptionCount); } void setBindingDescription(uint32_t binding, VkVertexInputBindingDescription bindingDescription) { assert(binding &lt; bindingDescriptions.size()); if(binding &lt;= bindingDescriptions.size()) { bindingDescriptions[binding] = bindingDescription; } }</p>
<p>uint32_t addBindingDescription(const VkVertexInputBindingDescription&amp; bindingDescription) { bindingDescriptions.push_back(bindingDescription); return (uint32_t)(bindingDescriptions.size() - 1); }</p>
<p>void addBindingDescriptions(const std::vector&lt;VkVertexInputBindingDescription&gt;&amp; bindingDescriptions_) { bindingDescriptions.insert(bindingDescriptions.end(), bindingDescriptions_.begin(), bindingDescriptions_.end()); }</p>
<p>void clearAttributeDescriptions() { attributeDescriptions.clear(); } void setAttributeDescriptionsCount(uint32_t attributeDescriptionCount) { attributeDescriptions.resize(attributeDescriptionCount); }</p>
<p>void setAttributeDescription(uint32_t attribute, const VkVertexInputAttributeDescription&amp; attributeDescription) { assert(attribute &lt; attributeDescriptions.size()); if(attribute &lt;= attributeDescriptions.size()) { attributeDescriptions[attribute] = attributeDescription; } }</p>
<p>uint32_t addAttributeDescription(const VkVertexInputAttributeDescription&amp; attributeDescription) { attributeDescriptions.push_back(attributeDescription); return (uint32_t)(attributeDescriptions.size() - 1); }</p>
<p>void addAttributeDescriptions(const std::vector&lt;VkVertexInputAttributeDescription&gt;&amp; attributeDescriptions_) { attributeDescriptions.insert(attributeDescriptions.end(), attributeDescriptions_.begin(), attributeDescriptions_.end()); }</p>
<p>void clearViewports() { viewports.clear(); } void setViewportsCount(uint32_t viewportCount) { viewports.resize(viewportCount); } void setViewport(uint32_t attribute, VkViewport viewport) { assert(attribute &lt; viewports.size()); if(attribute &lt;= viewports.size()) { viewports[attribute] = viewport; } } uint32_t addViewport(VkViewport viewport) { viewports.push_back(viewport); return (uint32_t)(viewports.size() - 1); }</p>
<p>void clearScissors() { scissors.clear(); } void setScissorsCount(uint32_t scissorCount) { scissors.resize(scissorCount); } void setScissor(uint32_t attribute, VkRect2D scissor) { assert(attribute &lt; scissors.size()); if(attribute &lt;= scissors.size()) { scissors[attribute] = scissor; } } uint32_t addScissor(VkRect2D scissor) { scissors.push_back(scissor); return (uint32_t)(scissors.size() - 1); }</p>
<p>VkSampleMask sampleMask{~0U}; VkPipelineInputAssemblyStateCreateInfo inputAssemblyState{VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO}; VkPipelineRasterizationStateCreateInfo rasterizationState{VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO}; VkPipelineMultisampleStateCreateInfo multisampleState{VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO}; VkPipelineDepthStencilStateCreateInfo depthStencilState{VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO}; VkPipelineViewportStateCreateInfo viewportState{VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO}; VkPipelineDynamicStateCreateInfo dynamicState{VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO}; VkPipelineColorBlendStateCreateInfo colorBlendState{VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO}; VkPipelineVertexInputStateCreateInfo vertexInputState{VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO};</p>
<p>protected: std::vector&lt;VkPipelineColorBlendAttachmentState&gt; blendAttachmentStates{makePipelineColorBlendAttachmentState()}; std::vector&lt;VkDynamicState&gt; dynamicStateEnables = {VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_SCISSOR};</p>
<p>std::vector&lt;VkVertexInputBindingDescription&gt; bindingDescriptions; std::vector&lt;VkVertexInputAttributeDescription&gt; attributeDescriptions;</p>
<p>std::vector&lt;VkViewport&gt; viewports; std::vector&lt;VkRect2D&gt; scissors;</p>
<p>// Helper to set objects for either C and C++ template &lt;class T, class U&gt; void setValue(T&amp; target, const U&amp; val) { target = (T)(val); } };</p>
<p>//-----------------------------------------------------------------------------------------------&mdash; /** @DOC_START </p>
<h1><a class="anchor" id="autotoc_md199"></a>
struct nvvk::GraphicsPipelineGenerator</h1>
<p>The graphics pipeline generator takes a GraphicsPipelineState object and pipeline-specific information such as the render pass and pipeline layout to generate the final pipeline.</p>
<p>Note: <code>nvvk::GraphicsPipelineState::createInfo.pNext</code> is modified by the setter functions. Therefore custom changes must be done last.</p>
<p>Example of usage : </p><div class="fragment"><div class="line">nvvk::GraphicsPipelineState pipelineState();</div>
<div class="line">...</div>
<div class="line">nvvk::GraphicsPipelineGenerator pipelineGenerator(m_device, m_pipelineLayout, m_renderPass, pipelineState);</div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/vert_shader.vert.spv&quot;</span>), VkShaderStageFlagBits::eVertex);</div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/frag_shader.frag.spv&quot;</span>), VkShaderStageFlagBits::eFragment);</div>
<div class="line"> </div>
<div class="line">m_pipeline = pipelineGenerator.createPipeline();</div>
</div><!-- fragment --><p> @DOC_END </p>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>pipeline_vk.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvvk.html">nvvk</a></li><li class="navelem"><a class="el" href="structnvvk_1_1_graphics_pipeline_generator.html">GraphicsPipelineGenerator</a></li>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:49 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
