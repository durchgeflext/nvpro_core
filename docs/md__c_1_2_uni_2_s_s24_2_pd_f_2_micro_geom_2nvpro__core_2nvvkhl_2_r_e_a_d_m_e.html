<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nvpro_core<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_uni_2_s_s24_2_pd_f_2_micro_geom_2nvpro__core_2nvvkhl_2_r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Table of Contents</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md369"></a></p><ul>
<li>alloc_vma.hpp</li>
<li>appbase_vk.hpp</li>
<li>appbase_vkpp.hpp</li>
<li>application.hpp</li>
<li>element_benchmark_parameters.hpp</li>
<li>element_camera.hpp</li>
<li>element_dbgprintf.hpp</li>
<li>element_gui.hpp</li>
<li>element_inspector.hpp</li>
<li>element_logger.hpp</li>
<li>element_nvml.hpp</li>
<li>element_profiler.hpp</li>
<li>element_testing.hpp</li>
<li>gbuffer.hpp</li>
<li>glsl_compiler.hpp</li>
<li>gltf_scene_rtx.hpp</li>
<li>gltf_scene_vk.hpp</li>
<li>hdr_env.hpp</li>
<li>hdr_env_dome.hpp</li>
<li>pipeline_container.hpp</li>
<li>scene_camera.hpp</li>
<li>sky.hpp</li>
<li>tonemap_postprocess.hpp</li>
</ul>
<h1><a class="anchor" id="autotoc_md370"></a>
alloc_vma.hpp</h1>
<h2><a class="anchor" id="autotoc_md371"></a>
class nvvkhl::AllocVma</h2>
<blockquote class="doxtable">
<p>&zwj; This class is an element of the application that is responsible for the resource allocation. It is using the <code>VMA</code> library to allocate buffers, images and acceleration structures. </p>
</blockquote>
<p>This allocator uses VMA (Vulkan Memory Allocator) to allocate buffers, images and acceleration structures. It is using the <code><a class="el" href="classnvvk_1_1_resource_allocator.html">nvvk::ResourceAllocator</a></code> to manage the allocation and deallocation of the resources.</p>
<h1><a class="anchor" id="autotoc_md372"></a>
appbase_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md373"></a>
class nvvkhl::AppBaseVk</h2>
<p><a class="el" href="classnvvkhl_1_1_app_base_vk.html">nvvkhl::AppBaseVk</a> is used in a few samples, can serve as base class for various needs. They might differ a bit in setup and functionality, but in principle aid the setup of context and window, as well as some common event processing.</p>
<p>The <a class="el" href="classnvvkhl_1_1_app_base_vk.html">nvvkhl::AppBaseVk</a> serves as the base class for many ray tracing examples and makes use of the Vulkan C API. It does the basics for Vulkan, by holding a reference to the instance and device, but also comes with optional default setups for the render passes and the swapchain.</p>
<h3><a class="anchor" id="autotoc_md374"></a>
Usage</h3>
<p>An example will derive from this class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>VkSample : <span class="keyword">public</span> AppBaseVk</div>
<div class="line">{</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md375"></a>
Setup</h3>
<p>In the <code>main()</code> of an application, call <code>setup()</code> which is taking a Vulkan instance, device, physical device, and a queue family index. Setup copies the given Vulkan handles into AppBase, and query the 0th VkQueue of the specified family, which must support graphics operations and drawing to the surface passed to createSurface. Furthermore, it is creating a VkCommandPool.</p>
<p>Prior to calling setup, if you are using the <code><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a></code> class to create and initialize Vulkan instances, you may want to create a VkSurfaceKHR from the window (glfw for example) and call <code>setGCTQueueWithPresent()</code>. This will make sure the m_queueGCT queue of <a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a> can draw to the surface, and m_queueGCT.familyIndex will meet the requirements of setup().</p>
<p>Creating the swapchain for displaying. Arguments are width and height, color and depth format, and vsync on/off. Defaults will create the best format for the surface.</p>
<p>Creating framebuffers has a dependency on the renderPass and depth buffer. All those are virtual and can be overridden in a sample, but default implementation exist.</p>
<ul>
<li>createDepthBuffer: creates a 2D depth/stencil image</li>
<li>createRenderPass : creates a color/depth pass and clear both buffers.</li>
</ul>
<p>Here is the dependency order:</p>
<div class="fragment"><div class="line">vkSample.createDepthBuffer();</div>
<div class="line">vkSample.createRenderPass();</div>
<div class="line">vkSample.createFrameBuffers();</div>
</div><!-- fragment --><p> cpp</p>
<p>The nvvk::Swapchain will create n images, typically 3. With this information, AppBase is also creating 3 VkFence, 3 VkCommandBuffer and 3 VkFrameBuffer.</p>
<h4><a class="anchor" id="autotoc_md376"></a>
Frame Buffers</h4>
<p>The created frame buffers are <em>display</em> frame buffers, made to be presented on screen. The frame buffers will be created using one of the images from swapchain, and a depth buffer. There is only one depth buffer because that resource is not used simultaneously. For example, when we clear the depth buffer, it is not done immediately, but done through a command buffer, which will be executed later.</p>
<p><b>Note</b>: the imageView(s) are part of the swapchain.</p>
<h4><a class="anchor" id="autotoc_md377"></a>
Command Buffers</h4>
<p>AppBase works with 3 <em>frame command buffers</em>. Each frame is filling a command buffer and gets submitted, one after the other. This is a design choice that can be debated, but makes it simple. I think it is still possible to submit other command buffers in a frame, but those command buffers will have to be submitted before the <em>frame</em> one. The <em>frame</em> command buffer when submitted with submitFrame, will use the current fence.</p>
<h4><a class="anchor" id="autotoc_md378"></a>
Fences</h4>
<p>There are as many fences as there are images in the swapchain. At the beginning of a frame, we call prepareFrame(). This is calling the acquire() from <a class="el" href="classnvvk_1_1_swap_chain.html">nvvk::SwapChain</a> and wait until the image is available. The very first time, the fence will not stop, but later it will wait until the submit is completed on the GPU.</p>
<h3><a class="anchor" id="autotoc_md379"></a>
ImGui</h3>
<p>If the application is using Dear <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a>, there are convenient functions for initializing it and setting the callbacks (glfw). The first one to call is <code>initGUI(0)</code>, where the argument is the subpass it will be using. Default is 0, but if the application creates a renderpass with multi-sampling and resolves in the second subpass, this makes it possible.</p>
<h3><a class="anchor" id="autotoc_md380"></a>
Glfw Callbacks</h3>
<p>Call <code>setupGlfwCallbacks(window)</code> to have all the window callback: key, mouse, window resizing. By default AppBase will handle resizing of the window and will recreate the images and framebuffers. If a sample needs to be aware of the resize, it can implement <code>onResize(width, height)</code>.</p>
<p>To handle the callbacks in Imgui, call <code>ImGui_ImplGlfw_InitForVulkan(window, true)</code>, where true will handle the default <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> callback .</p>
<p><b>Note</b>: All the methods are virtual and can be overloaded if they are not doing the typical setup.</p>
<div class="fragment"><div class="line"><span class="comment">// Create example</span></div>
<div class="line">VulkanSample vkSample;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Window need to be opened to get the surface on which to draw</span></div>
<div class="line"><span class="keyword">const</span> VkSurfaceKHR surface = vkSample.getVkSurface(vkctx.m_instance, window);</div>
<div class="line">vkctx.setGCTQueueWithPresent(surface);</div>
<div class="line"> </div>
<div class="line">vkSample.setup(vkctx.m_instance, vkctx.m_device, vkctx.m_physicalDevice, vkctx.m_queueGCT.familyIndex);</div>
<div class="line">vkSample.createSwapchain(surface, SAMPLE_WIDTH, SAMPLE_HEIGHT);</div>
<div class="line">vkSample.createDepthBuffer();</div>
<div class="line">vkSample.createRenderPass();</div>
<div class="line">vkSample.createFrameBuffers();</div>
<div class="line">vkSample.initGUI(0);</div>
<div class="line">vkSample.setupGlfwCallbacks(window);</div>
<div class="line"> </div>
<div class="line">ImGui_ImplGlfw_InitForVulkan(window, <span class="keyword">true</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md381"></a>
Drawing loop</h3>
<p>The drawing loop in the main() is the typicall loop you will find in glfw examples. Note that AppBase has a convenient function to tell if the window is minimize, therefore not doing any work and contain a sleep(), so the CPU is not going crazy.</p>
<div class="fragment"><div class="line"><span class="comment">// Window system loop</span></div>
<div class="line"><span class="keywordflow">while</span>(!glfwWindowShouldClose(window))</div>
<div class="line">{</div>
<div class="line">  glfwPollEvents();</div>
<div class="line">  <span class="keywordflow">if</span>(vkSample.isMinimized())</div>
<div class="line">    <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">  vkSample.display();  <span class="comment">// infinitely drawing</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md382"></a>
Display</h3>
<p>A typical display() function will need the following:</p>
<ul>
<li>Acquiring the next image: <code>prepareFrame()</code></li>
<li>Get the command buffer for the frame. There are n command buffers equal to the number of in-flight frames.</li>
<li>Clearing values</li>
<li>Start rendering pass</li>
<li>Drawing</li>
<li>End rendering</li>
<li>Submitting frame to display</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> VkSample::display()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Acquire</span></div>
<div class="line">  prepareFrame();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Command buffer for current frame</span></div>
<div class="line">  <span class="keyword">auto</span>                   curFrame = getCurFrame();</div>
<div class="line">  <span class="keyword">const</span> VkCommandBuffer&amp; cmdBuf   = getCommandBuffers()[curFrame];</div>
<div class="line"> </div>
<div class="line">  VkCommandBufferBeginInfo beginInfo{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};</div>
<div class="line">  beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</div>
<div class="line">  vkBeginCommandBuffer(cmdBuf, &amp;beginInfo);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Clearing values</span></div>
<div class="line">  std::array&lt;VkClearValue, 2&gt; clearValues{};</div>
<div class="line">  clearValues[0].color        = {{1.f, 1.f, 1.f, 1.f}};</div>
<div class="line">  clearValues[1].depthStencil = {1.0f, 0};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Begin rendering</span></div>
<div class="line">  VkRenderPassBeginInfo renderPassBeginInfo{VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO};</div>
<div class="line">  renderPassBeginInfo.clearValueCount = 2;</div>
<div class="line">  renderPassBeginInfo.pClearValues    = clearValues.data();</div>
<div class="line">  renderPassBeginInfo.renderPass      = m_renderPass;</div>
<div class="line">  renderPassBeginInfo.framebuffer     = m_framebuffers[curFram];</div>
<div class="line">  renderPassBeginInfo.renderArea      = {{0, 0}, m_size};</div>
<div class="line">  vkCmdBeginRenderPass(cmdBuf, &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// .. draw scene ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Draw UI</span></div>
<div class="line">  ImGui_ImplVulkan_RenderDrawData( ImGui::GetDrawData(),cmdBuff)</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// End rendering</span></div>
<div class="line">  vkCmdEndRenderPass(cmdBuf);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// End of the frame and present the one which is ready</span></div>
<div class="line">  vkEndCommandBuffer(cmdBuf);</div>
<div class="line">  submitFrame();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md383"></a>
Closing</h3>
<p>Finally, all resources can be destroyed by calling <code>destroy()</code> at the end of main().</p>
<div class="fragment"><div class="line">vkSample.destroy();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md384"></a>
appbase_vkpp.hpp</h1>
<h2><a class="anchor" id="autotoc_md385"></a>
class nvvkhl::AppBase</h2>
<p><a class="el" href="classnvvkhl_1_1_app_base_vk.html">nvvkhl::AppBaseVk</a> is the same as <a class="el" href="classnvvkhl_1_1_app_base_vk.html">nvvkhl::AppBaseVk</a> but makes use of the Vulkan C++ API (<code>vulkan.hpp</code>).</p>
<h1><a class="anchor" id="autotoc_md386"></a>
application.hpp</h1>
<h2><a class="anchor" id="autotoc_md387"></a>
class nvvkhl::Application</h2>
<p>The Application is basically a small modification of the <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> example for Vulkan. Because we support multiple viewports, duplicating the code would be not necessary and the code is very well explained.</p>
<p>To use the application,</p><ul>
<li>Fill the ApplicationCreateInfo with all the information, including the Vulkan creation information (<a class="el" href="structnvvk_1_1_context_create_info.html">nvvk::ContextCreateInfo</a>).</li>
<li>Attach elements to the application, such as rendering, camera, etc.</li>
<li>Call run() to start the application.</li>
<li></li>
<li>The application will create the window, the Vulkan context, and the <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> context.</li>
</ul>
<p>Worth notice</p><ul>
<li>::init() : will create the GLFW window, call nvvk::context for the creation of the Vulkan context, initialize <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> , create the surface and window (::setupVulkanWindow)</li>
<li>::shutdown() : the oposite of init</li>
<li>::run() : while running, render the frame and present the frame. Check for resize, minimize window and other changes. In the loop, it will call some functions for each 'element' that is connected. onUIRender, onUIMenu, onRender. See IApplication for details.</li>
<li>The Application is a singleton, and the main loop is inside the run() function.</li>
<li>The Application is the owner of the elements, and it will call the onRender, onUIRender, onUIMenu for each element that is connected to it.</li>
<li>The Application is the owner of the Vulkan context, and it will create the surface and window.</li>
<li>The Application is the owner of the <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> context, and it will create the dockspace and the main menu.</li>
<li>The Application is the owner of the GLFW window, and it will create the window and handle the events.</li>
</ul>
<p>The application itself does not render per se. It contains control buffers for the images in flight, it calls <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> rendering for Vulkan, but that's it. Note that none of the samples render directly into the swapchain. Instead, they render into an image, and the image is displayed in the <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> window window called "Viewport".</p>
<p>Application elements must be created to render scenes or add "elements" to the application. Several elements can be added to an application, and each of them will be called during the frame. This allows the application to be divided into smaller parts, or to reuse elements in various samples. For example, there is an element that adds a default menu (File/Tools), another that changes the window title with FPS, the resolution, and there is also an element for our automatic tests.</p>
<p>Each added element will be called in a frame, see the IAppElement interface for information on virtual functions. Basically there is a call to create and destroy, a call to render the user interface and a call to render the frame with the command buffer.</p>
<p>Note: order of Elements can be important if one depends on the other. For example, the ElementCamera should be added before the rendering sample, such that its matrices are updated before pulled by the renderer.</p>
<h1><a class="anchor" id="autotoc_md388"></a>
element_benchmark_parameters.hpp</h1>
<h2><a class="anchor" id="autotoc_md389"></a>
class nvvkhl::ElementBenchmarkParameters</h2>
<p>This element allows you to control an application with command line parameters. There are default parameters, but others can be added using the parameterLists().add(..) function.</p>
<p>It can also use a file containing several sets of parameters, separated by "benchmark" and which can be used to benchmark an application.</p>
<p>If a profiler is set, the measured performance at the end of each benchmark group is logged.</p>
<p>There are default parameters that can be used: -logfile Set a logfile.txt. If string contains $DEVICE$ it will be replaced by the GPU device name -winsize Set window size (width and height) -winpos Set window position (x and y) -vsync Enable or disable vsync -screenshot Save a screenshot into this file -benchmarkframes Set number of benchmarkframes -benchmark Set benchmark filename -test Enabling Testing -test-frames If test is on, number of frames to run -test-time If test is on, time that test will run</p>
<p>Example of Setup:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;nvvkhl::ElementBenchmarkParameters&gt; g_benchmark;</div>
<div class="line">std::shared_ptr&lt;nvvkhl::ElementProfiler&gt;  g_profiler;</div>
<div class="line"> </div>
<div class="line">main() {</div>
<div class="line">  ...</div>
<div class="line">  g_benchmark   = std::make_shared&lt;nvvkhl::ElementBenchmarkParameters&gt;(argc, argv);</div>
<div class="line">  g_profiler = std::make_shared&lt;nvvkhl::ElementProfiler&gt;(<span class="keyword">false</span>);</div>
<div class="line">  g_benchmark-&gt;setProfiler(g_profiler);</div>
<div class="line">  app-&gt;addElement(g_profiler);</div>
<div class="line">  app-&gt;addElement(g_benchmark);</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Applications can also get their parameters modified:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySample::MySample() {</div>
<div class="line">    g_benchmark-&gt;parameterLists().add(<span class="stringliteral">&quot;speed|The speed&quot;</span>, &amp;m_speed);</div>
<div class="line">    g_benchmark-&gt;parameterLists().add(<span class="stringliteral">&quot;color&quot;</span>, &amp;m_color, <span class="keyword">nullptr</span>, 3);</div>
<div class="line">    g_benchmark-&gt;parameterLists().add(<span class="stringliteral">&quot;complex&quot;</span>, &amp;m_complex, [&amp;](<span class="keywordtype">int</span> p){ doSomething(); });</div>
</div><!-- fragment --><p> cpp</p>
<p>Example of a benchmark.txt could look like</p>
<div class="fragment"><div class="line">#how many frames to average</div>
<div class="line">-benchmarkframes 12</div>
<div class="line">-winpos 10 10</div>
<div class="line">-winsize 500 500</div>
<div class="line"> </div>
<div class="line">benchmark &quot;No vsync&quot;</div>
<div class="line">-vsync 0</div>
<div class="line">-benchmarkframes 100</div>
<div class="line">-winpos 500 500</div>
<div class="line">-winsize 100 100</div>
<div class="line"> </div>
<div class="line">benchmark &quot;Image only&quot;</div>
<div class="line">-screenshot &quot;temporal_mdi.jpg&quot;</div>
<div class="line">```</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## element_camera.hpp</div>
<div class="line">### class nvvkhl::ElementCamera</div>
<div class="line"> </div>
<div class="line">This class is an element of the application that is responsible for the camera manipulation. It is using the &lt;tt&gt;nvh::CameraManipulator&lt;/tt&gt; to handle the camera movement and interaction.</div>
<div class="line"> </div>
<div class="line">To use this class, you need to add it to the &lt;tt&gt;nvvkhl::Application&lt;/tt&gt; using the &lt;tt&gt;addElement&lt;/tt&gt; method.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## element_dbgprintf.hpp</div>
<div class="line">### class nvvkhl::ElementDbgPrintf</div>
<div class="line"> </div>
<div class="line">&gt;  This class is an element of the application that is responsible for the debug printf in the shader. It is using the &lt;tt&gt;VK_EXT_debug_printf&lt;/tt&gt; extension to print information from the shader.</div>
<div class="line"> </div>
<div class="line">To use this class, you need to add it to the &lt;tt&gt;nvvkhl::Application&lt;/tt&gt; using the &lt;tt&gt;addElement&lt;/tt&gt; method.</div>
<div class="line"> </div>
<div class="line">  Create the element such that it will be available to the target application</div>
<div class="line">  - Example:</div>
<div class="line">    &lt;tt&gt;cpp</div>
<div class="line">    std::shared_ptr&lt;nvvkhl::ElementDbgPrintf&gt; g_dbgPrintf = std::make_shared&lt;nvvkhl::ElementDbgPrintf&gt;();</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line">  Add to main</div>
<div class="line">  - Before creating the nvvkhl::Application, set:</div>
<div class="line">    &lt;tt&gt;spec.vkSetup.instanceCreateInfoExt = g_dbgPrintf-&gt;getFeatures();&lt;/tt&gt;</div>
<div class="line">  - Add the Element to the Application</div>
<div class="line">    &lt;tt&gt;app-&gt;addElement(g_dbgPrintf);&lt;/tt&gt;</div>
<div class="line">  - In the target application, push the mouse coordinated</div>
<div class="line">    &lt;tt&gt;m_pushConst.mouseCoord = g_dbgPrintf-&gt;getMouseCoord();&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line">  In the Shader, do:</div>
<div class="line">  - Add the extension</div>
<div class="line">    &lt;tt&gt;\#extension GL_EXT_debug_printf : enable&lt;/tt&gt;</div>
<div class="line">  - Where to get the information</div>
<div class="line">    &lt;tt&gt;cpp</div>
<div class="line">    ivec2 fragCoord = ivec2(floor(gl_FragCoord.xy));</div>
<div class="line">    if(fragCoord == ivec2(pushC.mouseCoord))</div>
<div class="line">      debugPrintfEXT(&quot;Value: %f\n&quot;, myVal);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line">## element_gui.hpp</div>
<div class="line">### class nvvkhl::ElementDefaultMenu</div>
<div class="line"> </div>
<div class="line">&gt;  This class is an element of the application that is responsible for the default menu of the application. It is using the &lt;tt&gt;ImGui&lt;/tt&gt; library to create a menu with File/Exit and View/V-Sync.</div>
<div class="line"> </div>
<div class="line">To use this class, you need to add it to the &lt;tt&gt;nvvkhl::Application&lt;/tt&gt; using the &lt;tt&gt;addElement&lt;/tt&gt; method.</div>
<div class="line"> </div>
<div class="line">### class nvvkhl::ElementDefaultWindowTitle</div>
<div class="line"> </div>
<div class="line">&gt;  This class is an element of the application that is responsible for the default window title of the application. It is using the &lt;tt&gt;GLFW&lt;/tt&gt; library to set the window title with the application name, the size of the window and the frame rate.</div>
<div class="line"> </div>
<div class="line">To use this class, you need to add it to the &lt;tt&gt;nvvkhl::Application&lt;/tt&gt; using the &lt;tt&gt;addElement&lt;/tt&gt; method.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## element_inspector.hpp</div>
<div class="line"> </div>
<div class="line">### class nvvkhl::ElementInspector</div>
<div class="line"> </div>
<div class="line">-----------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> This element is used to facilitate GPU debugging by inspection of:</div>
<div class="line">  - Image contents</div>
<div class="line">  - Buffer contents</div>
<div class="line">  - Variables in compute shaders</div>
<div class="line">  - Variables in fragment shaders</div>
<div class="line"> </div>
<div class="line">  IMPORTANT NOTE: if used in a multi threaded environment synchronization needs to be performed</div>
<div class="line">  externally by the application.</div>
<div class="line"> </div>
<div class="line"> Basic usage:</div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> #####                 INITIALIZATION</div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> </div>
<div class="line"> Create the element as a global variable, and add it to the applications</div>
<div class="line"> ```cpp</div>
<div class="line"> std::shared_ptr&lt;ElementInspector&gt; g_inspectorElement = std::make_shared&lt;ElementInspector&gt;();</div>
<div class="line"> </div>
<div class="line"> void main(...)</div>
<div class="line"> {</div>
<div class="line">   ...</div>
<div class="line">   app-&gt;addElement(g_inspectorElement);</div>
<div class="line">   ...</div>
<div class="line">  }</div>
<div class="line"> &lt;tt&gt;</div>
<div class="line"> Upon attachment of the main app element, initialize the Inspector and specify the number of</div>
<div class="line"> buffers, images, compute shader variables and fragment shader variables that it will need to</div>
<div class="line"> inspect</div>
<div class="line">&lt;/tt&gt;cpp</div>
<div class="line"> void onAttach(nvvkhl::Application* app) override</div>
<div class="line"> {</div>
<div class="line">   ...</div>
<div class="line">    ElementInspector::InitInfo initInfo{};</div>
<div class="line">    initInfo.allocator     = m_alloc.get();</div>
<div class="line">    initInfo.imageCount    = imageInspectionCount;</div>
<div class="line">    initInfo.bufferCount   = bufferInspectionCount;</div>
<div class="line">    initInfo.computeCount  = computeInspectionCount;</div>
<div class="line">    initInfo.fragmentCount = fragmentInspectionCount;</div>
<div class="line">    initInfo.customCount   = customInspectionCount;</div>
<div class="line">    initInfo.device = m_app-&gt;getDevice();</div>
<div class="line">    initInfo.graphicsQueueFamilyIndex = m_app-&gt;getQueueGCT().familyIndex;</div>
<div class="line"> </div>
<div class="line">    g_inspectorElement-&gt;init(initInfo);</div>
<div class="line">   ...</div>
<div class="line">  }</div>
<div class="line">  ```</div>
<div class="line"> </div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> #####                 BUFFER INSPECTION</div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> </div>
<div class="line"> Each inspection needs to be initialized before use:</div>
<div class="line"> Inspect a buffer of size bufferSize, where each entry contains 5 values. The buffer format specifies the data</div>
<div class="line"> structure of the entries. The following format is the equivalent of</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line">  // struct</div>
<div class="line">  // {</div>
<div class="line">  //   uint32_t counterU32;</div>
<div class="line">  //   float    counterF32;</div>
<div class="line">  //   int16_t  anI16Value;</div>
<div class="line">  //   uint16_t myU16;</div>
<div class="line">  //   int32_t  anI32;</div>
<div class="line">  // };</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> bufferFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(5);</div>
<div class="line"> bufferFormat[0] = {ElementInspector::eUint32, &quot;counterU32&quot;};</div>
<div class="line"> bufferFormat[1] = {ElementInspector::eFloat32, &quot;counterF32&quot;};</div>
<div class="line"> bufferFormat[2] = {ElementInspector::eInt16, &quot;anI16Value&quot;};</div>
<div class="line"> bufferFormat[3] = {ElementInspector::eUint16, &quot;myU16&quot;};</div>
<div class="line"> bufferFormat[4] = {ElementInspector::eInt32, &quot;anI32&quot;};</div>
<div class="line"> ElementInspector::BufferInspectionInfo info{};</div>
<div class="line"> info.entryCount   = bufferSize;</div>
<div class="line"> info.format       = bufferFormat;</div>
<div class="line"> info.name         = &quot;myBuffer&quot;;</div>
<div class="line"> info.sourceBuffer = m_buffer.buffer;</div>
<div class="line"> g_inspectorElement-&gt;initBufferInspection(0, info);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> When the inspection is desired, simply add it to the current command buffer. Required barriers are added internally.</div>
<div class="line"> IMPORTANT: the buffer MUST have been created with the VK_BUFFER_USAGE_TRANSFER_SRC_BIT flag</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> g_inspectorElement-&gt;inspectBuffer(cmd, 0);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> #####                 IMAGE INSPECTION</div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> </div>
<div class="line"> Inspection of the image stored in m_texture, with format RGBA32F. Other formats can be specified using the syntax</div>
<div class="line"> above</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> ElementInspector::ImageInspectionInfo info{};</div>
<div class="line"> info.createInfo  = create_info;</div>
<div class="line"> info.format      = g_inspectorElement-&gt;formatRGBA32();</div>
<div class="line"> info.name        = &quot;MyImageInspection&quot;;</div>
<div class="line"> info.sourceImage = m_texture.image;</div>
<div class="line"> g_inspectorElement-&gt;initImageInspection(0, info);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> When the inspection is desired, simply add it to the current command buffer. Required barriers are added internally.</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> g_inspectorElement-&gt;inspectImage(cmd, 0, imageCurrentLayout);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> #####                 COMPUTE SHADER VARIABLE INSPECTION</div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> </div>
<div class="line"> Inspect a compute shader variable for a given 3D grid and block size (use 1 for unused dimensions). This mode applies</div>
<div class="line"> to shaders where invocation IDs (e.g. gl_LocalInvocationID) are defined, such as compute, mesh and task shaders.</div>
<div class="line"> Since grids may contain many threads capturing a variable for all threads</div>
<div class="line"> may incur large memory consumption and performance loss. The blocks to inspect, and the warps within those blocks can</div>
<div class="line"> be specified using inspectedMin/MaxBlocks and inspectedMin/MaxWarp.</div>
<div class="line"> ```cpp</div>
<div class="line"> computeInspectionFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(...);</div>
<div class="line"> ElementInspector::ComputeInspectionInfo info{}; info.blockSize = blockSize;</div>
<div class="line"> </div>
<div class="line"> // Create a 4-component vector format where each component is a uint32_t. The components will be labeled myVec4u.x,</div>
<div class="line"> // myVec4u.y, myVec4u.z, myVec4u.w in the UI</div>
<div class="line"> info.format           = ElementInspector::formatVector4(eUint32, &quot;myVec4u&quot;);</div>
<div class="line"> info.gridSizeInBlocks = gridSize;</div>
<div class="line"> info.minBlock         = inspectedMinBlock;</div>
<div class="line"> info.maxBlock         = inspectedMaxBlock;</div>
<div class="line"> info.minWarp          = inspectedMinWarp;</div>
<div class="line"> info.maxWarp          = inspectedMaxWarp;</div>
<div class="line"> info.name             = &quot;My Compute Inspection&quot;;</div>
<div class="line"> g_inspectorElement-&gt;initComputeInspection(0, info);</div>
<div class="line"> ```</div>
<div class="line"> </div>
<div class="line"> To allow variable inspection two buffers need to be made available to the target shader:</div>
<div class="line"> m_computeShader.updateBufferBinding(eThreadInspection, g_inspectorElement-&gt;getComputeInspectionBuffer(0));</div>
<div class="line"> m_computeShader.updateBufferBinding(eThreadMetadata, g_inspectorElement-&gt;getComputeMetadataBuffer(0));</div>
<div class="line"> </div>
<div class="line"> The shader code needs to indicate include the Inspector header along with preprocessor variables to set the</div>
<div class="line"> inspection mode to Compute, and indicate the binding points for the buffers:</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> \#define INSPECTOR_MODE_COMPUTE</div>
<div class="line"> \#define INSPECTOR_DESCRIPTOR_SET 0</div>
<div class="line"> \#define INSPECTOR_INSPECTION_DATA_BINDING 1</div>
<div class="line"> \#define INSPECTOR_METADATA_BINDING 2</div>
<div class="line"> \#include &quot;dh_inspector.h&quot;</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit</div>
<div class="line"> granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be</div>
<div class="line"> unpacked within the Inspector for display according to the specified format.</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> uint32_t myVariable = myFunction(...);</div>
<div class="line"> inspect32BitValue(0, myVariable);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> The inspection is triggered on the host side right after the compute shader invocation:</div>
<div class="line"> ```cpp</div>
<div class="line"> m_computeShader.dispatchBlocks(cmd, computGridSize, &amp;constants);</div>
<div class="line"> </div>
<div class="line"> g_inspectorElement-&gt;inspectComputeVariables(cmd, 0);</div>
<div class="line"> ```</div>
<div class="line"> </div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> #####                 FRAGMENT SHADER VARIABLE INSPECTION</div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> </div>
<div class="line"> Inspect a fragment shader variable for a given output image resolution. Since the image may have high resolution</div>
<div class="line"> capturing a variable for all threads may incur large memory consumption and performance loss. The bounding box of the</div>
<div class="line"> fragments to inspect can be specified using inspectedMin/MaxCoord.</div>
<div class="line"> IMPORTANT: Overlapping geometry may trigger</div>
<div class="line"> several fragment shader invocations for a given pixel. The inspection will only store the value of the foremost</div>
<div class="line"> fragment (with the lowest gl_FragCoord.z).</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> fragmentInspectionFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(...);</div>
<div class="line"> FragmentInspectionInfo info{};</div>
<div class="line"> info.name        = &quot;My Fragment Inspection&quot;;</div>
<div class="line"> info.format      = fragmentInspectionFormat;</div>
<div class="line"> info.renderSize  = imageSize;</div>
<div class="line"> info.minFragment = inspectedMinCoord;</div>
<div class="line"> info.maxFragment = inspectedMaxCoord;</div>
<div class="line"> g_inspectorElement-&gt;initFragmentInspection(0, info);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> To allow variable inspection two storage buffers need to be declared in the pipeline layout and made available</div>
<div class="line"> as follows:</div>
<div class="line"> ```cpp</div>
<div class="line"> std::vector&lt;VkWriteDescriptorSet&gt; writes;</div>
<div class="line"> </div>
<div class="line"> const VkDescriptorBufferInfo inspectorInspection{</div>
<div class="line">    g_inspectorElement-&gt;getFragmentInspectionBuffer(0),</div>
<div class="line">    0,</div>
<div class="line">    VK_WHOLE_SIZE};</div>
<div class="line"> writes.emplace_back(m_dset-&gt;makeWrite(0, 1, &amp;inspectorInspection));</div>
<div class="line"> const VkDescriptorBufferInfo inspectorMetadata{</div>
<div class="line">    g_inspectorElement-&gt;getFragmentMetadataBuffer(0),</div>
<div class="line">    0,</div>
<div class="line">    VK_WHOLE_SIZE};</div>
<div class="line"> writes.emplace_back(m_dset-&gt;makeWrite(0, 2, &amp;inspectorMetadata));</div>
<div class="line"> </div>
<div class="line"> vkUpdateDescriptorSets(m_device, static_cast&lt;uint32_t&gt;(writes.size()), writes.data(), 0, nullptr);</div>
<div class="line"> ```</div>
<div class="line"> </div>
<div class="line"> The shader code needs to indicate include the Inspector header along with preprocessor variables to set the</div>
<div class="line"> inspection mode to Fragment, and indicate the binding points for the buffers:</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> \#define INSPECTOR_MODE_FRAGMENT</div>
<div class="line"> \#define INSPECTOR_DESCRIPTOR_SET 0</div>
<div class="line"> \#define INSPECTOR_INSPECTION_DATA_BINDING 1</div>
<div class="line"> \#define INSPECTOR_METADATA_BINDING 2</div>
<div class="line"> \#include &quot;dh_inspector.h&quot;</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit</div>
<div class="line"> granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be</div>
<div class="line"> unpacked within the Inspector for display according to the specified format.</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> uint32_t myVariable = myFunction(...);</div>
<div class="line"> inspect32BitValue(0, myVariable);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> The inspection data for a pixel will only be written if a fragment actually covers that pixel. To avoid ghosting</div>
<div class="line"> where no fragments are rendered it is useful to clear the inspection data before rendering:</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> g_inspectorElement-&gt;clearFragmentVariables(cmd, 0);</div>
<div class="line"> vkCmdBeginRendering(...);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> The inspection is triggered on the host side right after rendering:</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> vkCmdEndRendering(cmd);</div>
<div class="line"> g_inspectorElement-&gt;inspectFragmentVariables(cmd, 0);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> #####                 CUSTOM SHADER VARIABLE INSPECTION</div>
<div class="line"> ---------------------------------------------------------------------------------------------&amp;mdash;</div>
<div class="line"> </div>
<div class="line"> In case some in-shader data has to be inspected in other shader types, or not on a once-per-thread basis, the custom</div>
<div class="line"> inspection mode can be used. This mode allows the user to specify the overall size of the generated data as well as</div>
<div class="line"> an effective inspection window. This mode may be used in conjunction with the COMPUTE and FRAGMENT modes.</div>
<div class="line"> std::vector&lt;ElementInspector::ValueFormat&gt; customCaptureFormat;</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> ...</div>
<div class="line"> ElementInspector::CustomInspectionInfo info{};</div>
<div class="line"> info.extent   = totalInspectionSize;</div>
<div class="line"> info.format   = customCaptureFormat;</div>
<div class="line"> info.minCoord = inspectionWindowMin;</div>
<div class="line"> info.maxCoord = inspectionWindowMax;</div>
<div class="line"> info.name     = &quot;My Custom Capture&quot;;</div>
<div class="line"> g_inspectorElement-&gt;initCustomInspection(0, info);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> To allow variable inspection two buffers need to be made available to the target pipeline:</div>
<div class="line"> ```cpp</div>
<div class="line"> std::vector&lt;VkWriteDescriptorSet&gt; writes;</div>
<div class="line"> const VkDescriptorBufferInfo      inspectorInspection{</div>
<div class="line">    g_inspectorElement-&gt;getCustomInspectionBuffer(0),</div>
<div class="line">    0,</div>
<div class="line">    VK_WHOLE_SIZE};</div>
<div class="line"> writes.emplace_back(m_dset-&gt;makeWrite(0, 1, &amp;inspectorInspection));</div>
<div class="line"> const VkDescriptorBufferInfo inspectorMetadata{</div>
<div class="line">    g_inspectorElement-&gt;getCustomMetadataBuffer(0),</div>
<div class="line">    0,</div>
<div class="line">    VK_WHOLE_SIZE};</div>
<div class="line"> writes.emplace_back(m_dset-&gt;makeWrite(0, 2, &amp;inspectorMetadata));</div>
<div class="line"> </div>
<div class="line"> vkUpdateDescriptorSets(m_device, static_cast&lt;uint32_t&gt;(writes.size()), writes.data(), 0, nullptr);</div>
<div class="line"> ```</div>
<div class="line"> </div>
<div class="line"> The shader code needs to indicate include the Inspector header along with preprocessor variables to set the</div>
<div class="line"> inspection mode to Fragment, and indicate the binding points for the buffers:</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> \#define INSPECTOR_MODE_CUSTOM</div>
<div class="line"> \#define INSPECTOR_DESCRIPTOR_SET 0</div>
<div class="line"> \#define INSPECTOR_CUSTOM_INSPECTION_DATA_BINDING 1</div>
<div class="line"> \#define INSPECTOR_CUSTOM_METADATA_BINDING 2</div>
<div class="line"> \#include &quot;dh_inspector.h&quot;</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit</div>
<div class="line"> granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be</div>
<div class="line"> unpacked within the Inspector for display according to the specified format.</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> uint32_t myVariable = myFunction(...);</div>
<div class="line"> inspectCustom32BitValue(0, myCoordinates, myVariable);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line"> The inspection is triggered on the host side right after running the pipeline:</div>
<div class="line"> &lt;tt&gt;cpp</div>
<div class="line"> g_inspectorElement-&gt;inspectCustomVariables(cmd, 0);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line">## element_logger.hpp</div>
<div class="line">### class nvvkhl::ElementLogger</div>
<div class="line"> </div>
<div class="line">&gt;  This class is an element of the application that can redirect all logs to a ImGui window in the application</div>
<div class="line"> </div>
<div class="line">To use this class, you need to add it to the &lt;tt&gt;nvvkhl::Application&lt;/tt&gt; using the &lt;tt&gt;addElement&lt;/tt&gt; method.</div>
<div class="line"> </div>
<div class="line">Create the element such that it will be available to the target application</div>
<div class="line"> </div>
<div class="line">Example:</div>
<div class="line">  ```cpp</div>
<div class="line">  static nvvkhl::SampleAppLog g_logger;</div>
<div class="line">  nvprintSetCallback([](int level, const char* fmt)</div>
<div class="line">  {</div>
<div class="line">    g_logger.addLog(&quot;%s&quot;, fmt);</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  app-&gt;addElement(std::make_unique&lt;nvvkhl::ElementLogger&gt;(&amp;g_logger, true));  // Add logger window</div>
<div class="line">  ```</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## element_nvml.hpp</div>
<div class="line">### class nvvkhl::ElementNvml</div>
<div class="line"> </div>
<div class="line">&gt;  This class is an element of the application that is responsible for the NVML monitoring. It is using the &lt;tt&gt;NVML&lt;/tt&gt; library to get information about the GPU and display it in the application.</div>
<div class="line"> </div>
<div class="line">To use this class, you need to add it to the &lt;tt&gt;nvvkhl::Application&lt;/tt&gt; using the &lt;tt&gt;addElement&lt;/tt&gt; method.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## element_profiler.hpp</div>
<div class="line">### class nvvkhl::ElementProfiler</div>
<div class="line">&gt;  This class is an element of the application that is responsible for the profiling of the application. It is using the &lt;tt&gt;nvvk::ProfilerVK&lt;/tt&gt; to profile the time parts of the computation done on the GPU.</div>
<div class="line"> </div>
<div class="line">To use this class, you need to add it to the &lt;tt&gt;nvvkhl::Application&lt;/tt&gt; using the &lt;tt&gt;addElement&lt;/tt&gt; method.</div>
<div class="line"> </div>
<div class="line">The profiler element, is there to help profiling the time parts of the</div>
<div class="line">computation is done on the GPU. To use it, follow those simple steps</div>
<div class="line"> </div>
<div class="line">In the main() program, create an instance of the profiler and add it to the</div>
<div class="line">nvvkhl::Application</div>
<div class="line"> </div>
<div class="line">&lt;tt&gt;cpp</div>
<div class="line">  std::shared_ptr&lt;nvvkhl::ElementProfiler&gt; profiler = std::make_shared&lt;nvvkhl::ElementProfiler&gt;();</div>
<div class="line">  app-&gt;addElement(profiler);</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line">In the application where profiling needs to be done, add profiling sections</div>
<div class="line"> </div>
<div class="line">&lt;tt&gt;cpp</div>
<div class="line">void mySample::onRender(VkCommandBuffer cmd)</div>
<div class="line">{</div>
<div class="line">  auto sec = m_profiler-&gt;timeRecurring(__FUNCTION__, cmd);</div>
<div class="line">  ...</div>
<div class="line">  // Subsection</div>
<div class="line">  {</div>
<div class="line">    auto sec = m_profiler-&gt;timeRecurring(&quot;Dispatch&quot;, cmd);</div>
<div class="line">    vkCmdDispatch(cmd, (size.width + (GROUP_SIZE - 1)) / GROUP_SIZE, (size.height + (GROUP_SIZE - 1)) / GROUP_SIZE, 1);</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line">This is it and the execution time on the GPU for each part will be showing in the Profiler window.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## element_testing.hpp</div>
<div class="line"> </div>
<div class="line">&gt; Todo: Add documentation</div>
<div class="line"> </div>
<div class="line">## gbuffer.hpp</div>
<div class="line">### class nvvkhl::GBuffer</div>
<div class="line">&gt;  This class is an help for creating GBuffers.</div>
<div class="line"> </div>
<div class="line">This can be use to create a GBuffer with multiple color images and a depth image. The GBuffer can be used to render the scene in multiple passes, such as deferred rendering.</div>
<div class="line"> </div>
<div class="line">To use this class, you need to create it and call the &lt;tt&gt;create&lt;/tt&gt; method to create the GBuffer. The &lt;tt&gt;create&lt;/tt&gt; method will create the images and the descriptor set for the GBuffer. The &lt;tt&gt;destroy&lt;/tt&gt; method will destroy the images and the descriptor set.</div>
<div class="line"> </div>
<div class="line">Note: the &lt;tt&gt;getDescriptorSet&lt;/tt&gt; method can be use to display the image in ImGui. Ex: &lt;tt&gt;ImGui::Image((ImTextureID)gbuffer.getDescriptorSet(), ImVec2(128, 128));&lt;/tt&gt;</div>
<div class="line"> </div>
<div class="line">## glsl_compiler.hpp</div>
<div class="line">### class nvvkhl::GlslCompiler</div>
<div class="line"> </div>
<div class="line">&gt;  This class is a wrapper around the shaderc compiler to help compiling GLSL to Spir-V using shaderC</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## gltf_scene_rtx.hpp</div>
<div class="line">### class nvvkhl::SceneRtx</div>
<div class="line"> </div>
<div class="line">&gt;  This class is responsible for the ray tracing acceleration structure.</div>
<div class="line"> </div>
<div class="line">It is using the &lt;tt&gt;nvh::gltf::Scene&lt;/tt&gt; and &lt;tt&gt;nvvkhl::SceneVk&lt;/tt&gt; information to create the acceleration structure.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## gltf_scene_vk.hpp</div>
<div class="line">### class nvvkhl::SceneVk</div>
<div class="line"> </div>
<div class="line">&gt;  This class is responsible for the Vulkan version of the scene.</div>
<div class="line"> </div>
<div class="line">It is using &lt;tt&gt;nvvkhl::Scene&lt;/tt&gt; to create the Vulkan buffers and images.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## hdr_env.hpp</div>
<div class="line">### class nvvkhl::HdrEnv</div>
<div class="line"> </div>
<div class="line">&gt;  Load an environment image (HDR) and create an acceleration structure for important light sampling.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## hdr_env_dome.hpp</div>
<div class="line">### class nvvkhl::HdrEnvDome</div>
<div class="line"> </div>
<div class="line">&gt;  Use an environment image (HDR) and create the cubic textures for glossy reflection and diffuse illumination. It also has the ability to render the HDR environment, in the background of an image.</div>
<div class="line"> </div>
<div class="line"> Using 4 compute shaders</div>
<div class="line"> - hdr_dome: to make the HDR as background</div>
<div class="line"> - hdr_integrate_brdf     : generate the BRDF lookup table</div>
<div class="line"> - hdr_prefilter_diffuse  : integrate the diffuse contribution in a cubemap</div>
<div class="line"> - hdr_prefilter_glossy   : integrate the glossy reflection in a cubemap</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## pipeline_container.hpp</div>
<div class="line">### struct nvvkhl::PipelineContainer</div>
<div class="line"> </div>
<div class="line">&gt;  Small multi-pipeline container</div>
<div class="line"> </div>
<div class="line">## scene_camera.hpp</div>
<div class="line">### Function nvvkhl::setCameraFromScene</div>
<div class="line">&gt;  Set the camera from the scene, if no camera is found, it will fit the camera to the scene.</div>
<div class="line"> </div>
<div class="line">## sky.hpp</div>
<div class="line">### class nvvkhl::SimpleSkyDome</div>
<div class="line"> </div>
<div class="line">&gt;  This class is responsible for a basic sky dome.</div>
<div class="line"> </div>
<div class="line">This class can render a basic sky dome with a sun, for both the rasterizer and the ray tracer.</div>
<div class="line"> </div>
<div class="line">The &lt;tt&gt;draw&lt;/tt&gt; method is responsible for rendering the sky dome for the rasterizer. For ray tracing, there is no need to call this method, as the sky dome is part of the ray tracing shaders (see shaders/dh_sky.h).</div>
<div class="line"> </div>
<div class="line">### class nvvkhl::PhysicalSkyDome</div>
<div class="line"> </div>
<div class="line">&gt;  This class is responsible for rendering a physical sky</div>
<div class="line"> </div>
<div class="line">This class can render a physical sky dome with a sun, for both the rasterizer and the ray tracer.</div>
<div class="line"> </div>
<div class="line">The &lt;tt&gt;draw&lt;/tt&gt; method is responsible for rendering the sky dome for the rasterizer. For ray tracing, there is no need to call this method, as the sky dome is part of the ray tracing shaders (see shaders/dh_sky.h).</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## tonemap_postprocess.hpp</div>
<div class="line"> </div>
<div class="line">### class nvvkhl::TonemapperPostProcess</div>
<div class="line"> </div>
<div class="line">&gt; Takes an image in linear RGB, tonemaps it, converts it to sRGB, and applies color correction.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">There are two ways to use it, one which is graphic, the other is compute.</div>
<div class="line"> </div>
<div class="line">- The graphic will render a full screen quad with the input image. It is to the</div>
<div class="line">  application to set the rendering target ( -&gt; G-Buffer0 )</div>
<div class="line"> </div>
<div class="line">- The compute takes an image as input and write to an another one using a compute shader</div>
<div class="line"> </div>
<div class="line">- It is either one or the other, both rendering aren&#39;t needed to post-process. If both are provided</div>
<div class="line">  it is for convenience.</div>
<div class="line"> </div>
<div class="line">Note: It is important in any cases to place a barrier if there is a transition from</div>
<div class="line">      fragment to compute and compute to fragment to avoid missing results.</div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 3 2025 15:08:46 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
