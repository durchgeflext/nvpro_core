<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__mnt_c__uni__s_s24__pd_f__micro_geom_nvpro_core_nvvkhl__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Table of Contents </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#alloc_vmahpp">alloc_vma.hpp</a></li>
<li><a href="#appbase_vkhpp">appbase_vk.hpp</a></li>
<li><a href="#appbase_vkpphpp">appbase_vkpp.hpp</a></li>
<li><a href="#applicationhpp">application.hpp</a></li>
<li><a href="#app_swapchain_vkhpp">app_swapchain_vk.hpp</a></li>
<li><a href="#app_utilshpp">app_utils.hpp</a></li>
<li><a href="#element_benchmark_parametershpp">element_benchmark_parameters.hpp</a></li>
<li><a href="#element_camerahpp">element_camera.hpp</a></li>
<li><a href="#element_dbgprintfhpp">element_dbgprintf.hpp</a></li>
<li><a href="#element_guihpp">element_gui.hpp</a></li>
<li><a href="#element_inspectorhpp">element_inspector.hpp</a></li>
<li><a href="#element_loggerhpp">element_logger.hpp</a></li>
<li><a href="#element_nvmlhpp">element_nvml.hpp</a></li>
<li><a href="#element_profilerhpp">element_profiler.hpp</a></li>
<li><a href="#element_testinghpp">element_testing.hpp</a></li>
<li><a href="#gbufferhpp">gbuffer.hpp</a></li>
<li><a href="#glsl_compilerhpp">glsl_compiler.hpp</a></li>
<li><a href="#gltf_scene_rtxhpp">gltf_scene_rtx.hpp</a></li>
<li><a href="#gltf_scene_vkhpp">gltf_scene_vk.hpp</a></li>
<li><a href="#hdr_envhpp">hdr_env.hpp</a></li>
<li><a href="#hdr_env_domehpp">hdr_env_dome.hpp</a></li>
<li><a href="#pipeline_containerhpp">pipeline_container.hpp</a></li>
<li><a href="#scene_camerahpp">scene_camera.hpp</a></li>
<li><a href="#skyhpp">sky.hpp</a></li>
<li><a href="#tonemap_postprocesshpp">tonemap_postprocess.hpp</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md353"></a>
alloc_vma.hpp</h1>
<h2><a class="anchor" id="autotoc_md354"></a>
class nvvkhl::AllocVma</h2>
<blockquote class="doxtable">
<p>This class is an element of the application that is responsible for the resource allocation. It is using the <code>VMA</code> library to allocate buffers, images and acceleration structures. </p>
</blockquote>
<p>This allocator uses VMA (Vulkan Memory Allocator) to allocate buffers, images and acceleration structures. It is using the <code>nvvk::ResourceAllocator</code> to manage the allocation and deallocation of the resources.</p>
<h1><a class="anchor" id="autotoc_md355"></a>
appbase_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md356"></a>
class nvvkhl::AppBaseVk</h2>
<p>nvvkhl::AppBaseVk is used in a few samples, can serve as base class for various needs. They might differ a bit in setup and functionality, but in principle aid the setup of context and window, as well as some common event processing.</p>
<p>The nvvkhl::AppBaseVk serves as the base class for many ray tracing examples and makes use of the Vulkan C API. It does the basics for Vulkan, by holding a reference to the instance and device, but also comes with optional default setups for the render passes and the swapchain.</p>
<h3><a class="anchor" id="autotoc_md357"></a>
Usage</h3>
<p>An example will derive from this class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>VkSample : <span class="keyword">public</span> AppBaseVk</div>
<div class="line">{</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md358"></a>
Setup</h3>
<p>In the <code>main()</code> of an application, call <code>setup()</code> which is taking a Vulkan instance, device, physical device, and a queue family index. Setup copies the given Vulkan handles into AppBase, and query the 0th VkQueue of the specified family, which must support graphics operations and drawing to the surface passed to createSurface. Furthermore, it is creating a VkCommandPool.</p>
<p>Prior to calling setup, if you are using the <code><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a></code> class to create and initialize Vulkan instances, you may want to create a VkSurfaceKHR from the window (glfw for example) and call <code>setGCTQueueWithPresent()</code>. This will make sure the m_queueGCT queue of <a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a> can draw to the surface, and m_queueGCT.familyIndex will meet the requirements of setup().</p>
<p>Creating the swapchain for displaying. Arguments are width and height, color and depth format, and vsync on/off. Defaults will create the best format for the surface.</p>
<p>Creating framebuffers has a dependency on the renderPass and depth buffer. All those are virtual and can be overridden in a sample, but default implementation exist.</p>
<ul>
<li>createDepthBuffer: creates a 2D depth/stencil image</li>
<li>createRenderPass : creates a color/depth pass and clear both buffers.</li>
</ul>
<p>Here is the dependency order:</p>
<div class="fragment"><div class="line">  vkSample.createDepthBuffer();</div>
<div class="line">  vkSample.createRenderPass();</div>
<div class="line">  vkSample.createFrameBuffers();</div>
<div class="line">```cpp</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">The nvvk::Swapchain will create n images, typically 3. With <span class="keyword">this</span> information, AppBase is also creating 3 VkFence,</div>
<div class="line">3 VkCommandBuffer and 3 VkFrameBuffer.</div>
<div class="line"> </div>
<div class="line">##### Frame Buffers</div>
<div class="line"> </div>
<div class="line">The created frame buffers are *display* frame buffers,  made to be presented on screen. The frame buffers will be created</div>
<div class="line"><span class="keyword">using</span> one of the images from swapchain, and a depth buffer. There is only one depth buffer because that resource is not</div>
<div class="line">used simultaneously. For example, when we clear the depth buffer, it is not done immediately, but done through a command</div>
<div class="line">buffer, which will be executed later.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">**Note**: the imageView(s) are part of the swapchain.</div>
<div class="line"> </div>
<div class="line">##### Command Buffers</div>
<div class="line"> </div>
<div class="line">AppBase works with 3 *frame command buffers*. Each frame is filling a command buffer and gets submitted, one after the</div>
<div class="line">other. This is a design choice that can be debated, but makes it simple. I think it is still possible to submit other</div>
<div class="line">command buffers in a frame, but those command buffers will have to be submitted before the *frame* one. The *frame*</div>
<div class="line">command buffer when submitted with submitFrame, will use the current fence.</div>
<div class="line"> </div>
<div class="line">##### Fences</div>
<div class="line"> </div>
<div class="line">There are as many fences as there are images in the swapchain. At the beginning of a frame, we call prepareFrame().</div>
<div class="line">This is calling the acquire() from <a class="code" href="namespacenvvk.html">nvvk</a>::SwapChain and wait until the image is available. The very first time, the</div>
<div class="line">fence will not stop, but later it will wait until the submit is completed on the GPU.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#### ImGui</span></div>
<div class="line"> </div>
<div class="line">If the application is <span class="keyword">using</span> Dear <a class="code" href="namespace_im_gui.html">ImGui</a>, there are convenient functions <span class="keywordflow">for</span> initializing it and</div>
<div class="line">setting the callbacks (glfw). The first one to call is `initGUI(0)`, where the argument is the subpass</div>
<div class="line">it will be <span class="keyword">using</span>. Default is 0, but <span class="keywordflow">if</span> the application creates a renderpass with multi-sampling and</div>
<div class="line">resolves in the second subpass, <span class="keyword">this</span> makes it possible.</div>
<div class="line"> </div>
<div class="line">#### Glfw Callbacks</div>
<div class="line"> </div>
<div class="line">Call `setupGlfwCallbacks(window)` to have all the window callback: key, mouse, window resizing.</div>
<div class="line">By <span class="keywordflow">default</span> AppBase will handle resizing of the window and will recreate the images and framebuffers.</div>
<div class="line">If a sample needs to be aware of the resize, it can implement `onResize(width, height)`.</div>
<div class="line"> </div>
<div class="line">To handle the callbacks in Imgui, call `ImGui_ImplGlfw_InitForVulkan(window, <span class="keyword">true</span>)`, where <span class="keyword">true</span></div>
<div class="line">will handle the <span class="keywordflow">default</span> <a class="code" href="namespace_im_gui.html">ImGui</a> callback .</div>
<div class="line"> </div>
<div class="line">**Note**: All the methods are <span class="keyword">virtual</span> and can be overloaded <span class="keywordflow">if</span> they are not doing the typical setup.</div>
<div class="line"> </div>
<div class="line">```cpp</div>
<div class="line">  <span class="comment">// Create example</span></div>
<div class="line">  VulkanSample vkSample;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Window need to be opened to get the surface on which to draw</span></div>
<div class="line">  <span class="keyword">const</span> VkSurfaceKHR surface = vkSample.getVkSurface(vkctx.m_instance, window);</div>
<div class="line">  vkctx.setGCTQueueWithPresent(surface);</div>
<div class="line"> </div>
<div class="line">  vkSample.setup(vkctx.m_instance, vkctx.m_device, vkctx.m_physicalDevice, vkctx.m_queueGCT.familyIndex);</div>
<div class="line">  vkSample.createSwapchain(surface, SAMPLE_WIDTH, SAMPLE_HEIGHT);</div>
<div class="line">  vkSample.createDepthBuffer();</div>
<div class="line">  vkSample.createRenderPass();</div>
<div class="line">  vkSample.createFrameBuffers();</div>
<div class="line">  vkSample.initGUI(0);</div>
<div class="line">  vkSample.setupGlfwCallbacks(window);</div>
<div class="line"> </div>
<div class="line">  ImGui_ImplGlfw_InitForVulkan(window, <span class="keyword">true</span>);</div>
<div class="ttc" id="anamespace_im_gui_html"><div class="ttname"><a href="namespace_im_gui.html">ImGui</a></div><div class="ttdoc">@DOC_SKIP (keyword to exclude this file from automatic README.md generation)</div><div class="ttdef"><b>Definition:</b> imgui_impl_gl.h:10</div></div>
<div class="ttc" id="anamespacenvvk_html"><div class="ttname"><a href="namespacenvvk.html">nvvk</a></div><div class="ttdef"><b>Definition:</b> acceleration_structures.hpp:26</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md359"></a>
Drawing loop</h3>
<p>The drawing loop in the main() is the typicall loop you will find in glfw examples. Note that AppBase has a convenient function to tell if the window is minimize, therefore not doing any work and contain a sleep(), so the CPU is not going crazy.</p>
<div class="fragment"><div class="line"><span class="comment">// Window system loop</span></div>
<div class="line"><span class="keywordflow">while</span>(!glfwWindowShouldClose(window))</div>
<div class="line">{</div>
<div class="line">  glfwPollEvents();</div>
<div class="line">  <span class="keywordflow">if</span>(vkSample.isMinimized())</div>
<div class="line">    <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">  vkSample.display();  <span class="comment">// infinitely drawing</span></div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md360"></a>
Display</h3>
<p>A typical display() function will need the following:</p>
<ul>
<li>Acquiring the next image: <code>prepareFrame()</code></li>
<li>Get the command buffer for the frame. There are n command buffers equal to the number of in-flight frames.</li>
<li>Clearing values</li>
<li>Start rendering pass</li>
<li>Drawing</li>
<li>End rendering</li>
<li>Submitting frame to display</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> VkSample::display()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Acquire</span></div>
<div class="line">  prepareFrame();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Command buffer for current frame</span></div>
<div class="line">  <span class="keyword">auto</span>                   curFrame = getCurFrame();</div>
<div class="line">  <span class="keyword">const</span> VkCommandBuffer&amp; cmdBuf   = getCommandBuffers()[curFrame];</div>
<div class="line"> </div>
<div class="line">  VkCommandBufferBeginInfo beginInfo{VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};</div>
<div class="line">  beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</div>
<div class="line">  vkBeginCommandBuffer(cmdBuf, &amp;beginInfo);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Clearing values</span></div>
<div class="line">  std::array&lt;VkClearValue, 2&gt; clearValues{};</div>
<div class="line">  clearValues[0].color        = {{1.f, 1.f, 1.f, 1.f}};</div>
<div class="line">  clearValues[1].depthStencil = {1.0f, 0};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Begin rendering</span></div>
<div class="line">  VkRenderPassBeginInfo renderPassBeginInfo{VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO};</div>
<div class="line">  renderPassBeginInfo.clearValueCount = 2;</div>
<div class="line">  renderPassBeginInfo.pClearValues    = clearValues.data();</div>
<div class="line">  renderPassBeginInfo.renderPass      = m_renderPass;</div>
<div class="line">  renderPassBeginInfo.framebuffer     = m_framebuffers[curFram];</div>
<div class="line">  renderPassBeginInfo.renderArea      = {{0, 0}, m_size};</div>
<div class="line">  vkCmdBeginRenderPass(cmdBuf, &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// .. draw scene ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Draw UI</span></div>
<div class="line">  ImGui_ImplVulkan_RenderDrawData( ImGui::GetDrawData(),cmdBuff)</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// End rendering</span></div>
<div class="line">  vkCmdEndRenderPass(cmdBuf);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// End of the frame and present the one which is ready</span></div>
<div class="line">  vkEndCommandBuffer(cmdBuf);</div>
<div class="line">  submitFrame();</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md361"></a>
Closing</h3>
<p>Finally, all resources can be destroyed by calling <code>destroy()</code> at the end of main().</p>
<div class="fragment"><div class="line">vkSample.destroy();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md362"></a>
appbase_vkpp.hpp</h1>
<h2><a class="anchor" id="autotoc_md363"></a>
class nvvkhl::AppBase</h2>
<p>nvvkhl::AppBaseVk is the same as nvvkhl::AppBaseVk but makes use of the Vulkan C++ API (<code>vulkan.hpp</code>).</p>
<h1><a class="anchor" id="autotoc_md364"></a>
application.hpp</h1>
<h2><a class="anchor" id="autotoc_md365"></a>
class nvapp::Application</h2>
<p>To use the application,</p><ul>
<li>Fill the ApplicationCreateInfo with all the information,</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line">    nvapp::ApplicationCreateInfo appInfo;</div>
<div class="line">    appInfo.name           = <span class="stringliteral">&quot;Minimal Test&quot;</span>;</div>
<div class="line">    appInfo.width          = 800;</div>
<div class="line">    appInfo.height         = 600;</div>
<div class="line">    appInfo.vSync          = <span class="keyword">false</span>;</div>
<div class="line">    appInfo.instance       = vkContext.getInstance();</div>
<div class="line">    appInfo.physicalDevice = vkContext.getPhysicalDevice();</div>
<div class="line">    appInfo.device         = vkContext.getDevice();</div>
<div class="line">    appInfo.queues         = vkContext.getQueueInfos();</div>
<div class="line"> ```</div>
<div class="line"> </div>
<div class="line">* Attach elements to the application, the main rendering, and others like, camera, etc.</div>
<div class="line">* Call run() to start the application.</div>
<div class="line">*</div>
<div class="line">* The application will create the window and the <a class="code" href="namespace_im_gui.html">ImGui</a> context.</div>
<div class="line"> </div>
<div class="line">Worth notice</div>
<div class="line">* ::init() : will create the GLFW window, call <a class="code" href="namespacenvvk.html">nvvk</a>::context for the creation of the</div>
<div class="line">              Vulkan context, initialize <a class="code" href="namespace_im_gui.html">ImGui</a> , create the surface and window (::setupVulkanWindow)</div>
<div class="line">* ::shutdown() : the opposite of init</div>
<div class="line">* ::run() : while running, render the frame and present the frame. Check for resize, minimize window</div>
<div class="line">              and other changes. In the loop, it will call some functions for each &#39;element&#39; that is connected.</div>
<div class="line">              onUIRender, onUIMenu, onRender. See IApplication for details.</div>
<div class="line">* The Application is a singleton, and the main loop is inside the run() function.</div>
<div class="line">* The Application is the owner of the elements, and it will call the onRender, onUIRender, onUIMenu</div>
<div class="line">    for each element that is connected to it.</div>
<div class="line">* The Application is the owner of the Vulkan context, and it will create the surface and window.</div>
<div class="line">* The Application is the owner of the <a class="code" href="namespace_im_gui.html">ImGui</a> context, and it will create the dockspace and the main menu.</div>
<div class="line">* The Application is the owner of the GLFW window, and it will create the window and handle the events.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">The application itself does not render per se. It contains control buffers for the images in flight,</div>
<div class="line">it calls <a class="code" href="namespace_im_gui.html">ImGui</a> rendering for Vulkan, but that&#39;s it. Note that none of the samples render</div>
<div class="line">directly into the swapchain. Instead, they render into an image, and the image is displayed in the <a class="code" href="namespace_im_gui.html">ImGui</a> window</div>
<div class="line">window called &quot;Viewport&quot;.</div>
<div class="line"> </div>
<div class="line">Application elements must be created to render scenes or add &quot;elements&quot; to the application.  Several elements</div>
<div class="line">can be added to an application, and each of them will be called during the frame. This allows the application</div>
<div class="line">to be divided into smaller parts, or to reuse elements in various samples. For example, there is an element</div>
<div class="line">that adds a default menu (File/Tools), another that changes the window title with FPS, the resolution, and there</div>
<div class="line">is also an element for our automatic tests.</div>
<div class="line"> </div>
<div class="line">Each added element will be called in a frame, see the IAppElement interface for information on virtual functions.</div>
<div class="line">Basically there is a call to create and destroy, a call to render the user interface and a call to render the</div>
<div class="line">frame with the command buffer.</div>
<div class="line"> </div>
<div class="line">Note: order of Elements can be important if one depends on the other. For example, the ElementCamera should</div>
<div class="line">      be added before the rendering sample, such that its matrices are updated before pulled by the renderer.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#### Docking</span></div>
<div class="line"> </div>
<div class="line">The layout can be customized by providing a <span class="keyword">function</span> to the ApplicationCreateInfo.</div>
<div class="line"> </div>
<div class="line">Example:</div>
</div><!-- fragment --><p> // Setting up the layout of the application appInfo.dockSetup = [](ImGuiID viewportID) { ImGuiID settingID = ImGui::DockBuilderSplitNode(viewportID, ImGuiDir_Right, 0.2F, nullptr, &amp;viewportID); ImGui::DockBuilderDockWindow("Settings", settingID); }; ````</p>
<h1><a class="anchor" id="autotoc_md366"></a>
app_swapchain_vk.hpp</h1>
<blockquote class="doxtable">
<p>Todo: Add documentation </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md367"></a>
app_utils.hpp</h1>
<blockquote class="doxtable">
<p>Todo: Add documentation </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md368"></a>
element_benchmark_parameters.hpp</h1>
<h2><a class="anchor" id="autotoc_md369"></a>
class nvvkhl::ElementBenchmarkParameters</h2>
<p>This element allows you to control an application with command line parameters. There are default parameters, but others can be added using the parameterLists().add(..) function.</p>
<p>It can also use a file containing several sets of parameters, separated by "benchmark" and which can be used to benchmark an application.</p>
<p>If a profiler is set, the measured performance at the end of each benchmark group is logged.</p>
<p>There are default parameters that can be used: -logfile Set a logfile.txt. If string contains $DEVICE$ it will be replaced by the GPU device name -winsize Set window size (width and height) -winpos Set window position (x and y) -vsync Enable or disable vsync -screenshot Save a screenshot into this file -benchmarkframes Set number of benchmarkframes -benchmark Set benchmark filename -test Enabling Testing -test-frames If test is on, number of frames to run -test-time If test is on, time that test will run</p>
<p>Example of Setup:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;nvvkhl::ElementBenchmarkParameters&gt; g_benchmark;</div>
<div class="line">std::shared_ptr&lt;nvvkhl::ElementProfiler&gt;  g_profiler;</div>
<div class="line"> </div>
<div class="line">main() {</div>
<div class="line">  ...</div>
<div class="line">  g_benchmark   = std::make_shared&lt;nvvkhl::ElementBenchmarkParameters&gt;(argc, argv);</div>
<div class="line">  g_profiler = std::make_shared&lt;nvvkhl::ElementProfiler&gt;(<span class="keyword">false</span>);</div>
<div class="line">  g_benchmark-&gt;setProfiler(g_profiler);</div>
<div class="line">  app-&gt;addElement(g_profiler);</div>
<div class="line">  app-&gt;addElement(g_benchmark);</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Applications can also get their parameters modified:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MySample::MySample() {</div>
<div class="line">    g_benchmark-&gt;parameterLists().add(<span class="stringliteral">&quot;speed|The speed&quot;</span>, &amp;m_speed);</div>
<div class="line">    g_benchmark-&gt;parameterLists().add(<span class="stringliteral">&quot;color&quot;</span>, &amp;m_color, <span class="keyword">nullptr</span>, 3);</div>
<div class="line">    g_benchmark-&gt;parameterLists().add(<span class="stringliteral">&quot;complex&quot;</span>, &amp;m_complex, [&amp;](<span class="keywordtype">int</span> p){ doSomething(); });</div>
<div class="line">```cpp</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Example of a benchmark.txt could look like</div>
<div class="line"> </div>
<div class="line">\code{.bat}</div>
<div class="line"><span class="preprocessor">#how many frames to average</span></div>
<div class="line">-benchmarkframes 12</div>
<div class="line">-winpos 10 10</div>
<div class="line">-winsize 500 500</div>
<div class="line"> </div>
<div class="line">benchmark <span class="stringliteral">&quot;No vsync&quot;</span></div>
<div class="line">-vsync 0</div>
<div class="line">-benchmarkframes 100</div>
<div class="line">-winpos 500 500</div>
<div class="line">-winsize 100 100</div>
<div class="line"> </div>
<div class="line">benchmark <span class="stringliteral">&quot;Image only&quot;</span></div>
<div class="line">-screenshot <span class="stringliteral">&quot;temporal_mdi.jpg&quot;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md370"></a>
element_camera.hpp</h1>
<h2><a class="anchor" id="autotoc_md371"></a>
class nvvkhl::ElementCamera</h2>
<p>This class is an element of the application that is responsible for the camera manipulation. It is using the <code>nvh::CameraManipulator</code> to handle the camera movement and interaction.</p>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<h1><a class="anchor" id="autotoc_md372"></a>
element_dbgprintf.hpp</h1>
<h2><a class="anchor" id="autotoc_md373"></a>
class nvvkhl::ElementDbgPrintf</h2>
<blockquote class="doxtable">
<p>This class is an element of the application that is responsible for the debug printf in the shader. It is using the <code>VK_EXT_debug_printf</code> extension to print information from the shader. </p>
</blockquote>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<p>Create the element such that it will be available to the target application</p><ul>
<li>Example: ```cpp std::shared_ptr&lt;nvvkhl::ElementDbgPrintf&gt; g_dbgPrintf = std::make_shared&lt;nvvkhl::ElementDbgPrintf&gt;(); ```</li>
</ul>
<p>Add to main</p><ul>
<li>Before creating the <a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a>, set: <code>spec.vkSetup.instanceCreateInfoExt = g_dbgPrintf-&gt;getFeatures();</code></li>
<li>Add the Element to the Application <code>app-&gt;addElement(g_dbgPrintf);</code></li>
<li>In the target application, push the mouse coordinated <code>m_pushConst.mouseCoord = g_dbgPrintf-&gt;getMouseCoord();</code></li>
</ul>
<p>In the Shader, do:</p><ul>
<li>Add the extension <code>#extension GL_EXT_debug_printf : enable</code></li>
<li>Where to get the information ```cpp ivec2 fragCoord = ivec2(floor(gl_FragCoord.xy)); if(fragCoord == ivec2(pushC.mouseCoord)) debugPrintfEXT("Value: %f\n", myVal); ```</li>
</ul>
<h1><a class="anchor" id="autotoc_md374"></a>
element_gui.hpp</h1>
<h2><a class="anchor" id="autotoc_md375"></a>
class nvvkhl::ElementDefaultMenu</h2>
<blockquote class="doxtable">
<p>This class is an element of the application that is responsible for the default menu of the application. It is using the <code><a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a></code> library to create a menu with File/Exit and View/V-Sync. </p>
</blockquote>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<h2><a class="anchor" id="autotoc_md376"></a>
class nvvkhl::ElementDefaultWindowTitle</h2>
<blockquote class="doxtable">
<p>This class is an element of the application that is responsible for the default window title of the application. It is using the <code>GLFW</code> library to set the window title with the application name, the size of the window and the frame rate. </p>
</blockquote>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<h1><a class="anchor" id="autotoc_md377"></a>
element_inspector.hpp</h1>
<h2><a class="anchor" id="autotoc_md378"></a>
class nvvkhl::ElementInspector</h2>
<hr  />
<p> This element is used to facilitate GPU debugging by inspection of:</p><ul>
<li>Image contents</li>
<li>Buffer contents</li>
<li>Variables in compute shaders</li>
<li>Variables in fragment shaders</li>
</ul>
<p>IMPORTANT NOTE: if used in a multi threaded environment synchronization needs to be performed externally by the application.</p>
<h1><a class="anchor" id="autotoc_md380"></a>
Basic usage:</h1>
<h1><a class="anchor" id="autotoc_md381"></a>
#####                 INITIALIZATION</h1>
<p>Create the element as a global variable, and add it to the applications </p><div class="fragment"><div class="line">std::shared_ptr&lt;ElementInspector&gt; g_inspectorElement = std::make_shared&lt;ElementInspector&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main(...)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  app-&gt;addElement(g_inspectorElement);</div>
<div class="line">  ...</div>
<div class="line"> }</div>
</div><!-- fragment --><p> Upon attachment of the main app element, initialize the Inspector and specify the number of buffers, images, compute shader variables and fragment shader variables that it will need to inspect </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> onAttach(<a class="code" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a>* app)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  ...</div>
<div class="line">   ElementInspector::InitInfo initInfo{};</div>
<div class="line">   initInfo.allocator     = m_alloc.get();</div>
<div class="line">   initInfo.imageCount    = imageInspectionCount;</div>
<div class="line">   initInfo.bufferCount   = bufferInspectionCount;</div>
<div class="line">   initInfo.computeCount  = computeInspectionCount;</div>
<div class="line">   initInfo.fragmentCount = fragmentInspectionCount;</div>
<div class="line">   initInfo.customCount   = customInspectionCount;</div>
<div class="line">   initInfo.device = m_app-&gt;getDevice();</div>
<div class="line">   initInfo.graphicsQueueFamilyIndex = m_app-&gt;getQueueGCT().familyIndex;</div>
<div class="line"> </div>
<div class="line">   g_inspectorElement-&gt;init(initInfo);</div>
<div class="line">  ...</div>
<div class="line"> }</div>
<div class="ttc" id="aclassnvvkhl_1_1_application_html"><div class="ttname"><a href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></div><div class="ttdef"><b>Definition:</b> application.hpp:163</div></div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md383"></a>
#####                 BUFFER INSPECTION</h1>
<p>Each inspection needs to be initialized before use: Inspect a buffer of size bufferSize, where each entry contains 5 values. The buffer format specifies the data structure of the entries. The following format is the equivalent of </p><div class="fragment"><div class="line"><span class="comment">// struct</span></div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//   uint32_t counterU32;</span></div>
<div class="line"><span class="comment">//   float    counterF32;</span></div>
<div class="line"><span class="comment">//   int16_t  anI16Value;</span></div>
<div class="line"><span class="comment">//   uint16_t myU16;</span></div>
<div class="line"><span class="comment">//   int32_t  anI32;</span></div>
<div class="line"><span class="comment">// };</span></div>
</div><!-- fragment --><div class="fragment"><div class="line">bufferFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(5);</div>
<div class="line">bufferFormat[0] = {ElementInspector::eUint32, <span class="stringliteral">&quot;counterU32&quot;</span>};</div>
<div class="line">bufferFormat[1] = {ElementInspector::eFloat32, <span class="stringliteral">&quot;counterF32&quot;</span>};</div>
<div class="line">bufferFormat[2] = {ElementInspector::eInt16, <span class="stringliteral">&quot;anI16Value&quot;</span>};</div>
<div class="line">bufferFormat[3] = {ElementInspector::eUint16, <span class="stringliteral">&quot;myU16&quot;</span>};</div>
<div class="line">bufferFormat[4] = {ElementInspector::eInt32, <span class="stringliteral">&quot;anI32&quot;</span>};</div>
<div class="line">ElementInspector::BufferInspectionInfo info{};</div>
<div class="line">info.entryCount   = bufferSize;</div>
<div class="line">info.format       = bufferFormat;</div>
<div class="line">info.name         = <span class="stringliteral">&quot;myBuffer&quot;</span>;</div>
<div class="line">info.sourceBuffer = m_buffer.buffer;</div>
<div class="line">g_inspectorElement-&gt;initBufferInspection(0, info);</div>
</div><!-- fragment --><p>When the inspection is desired, simply add it to the current command buffer. Required barriers are added internally. IMPORTANT: the buffer MUST have been created with the VK_BUFFER_USAGE_TRANSFER_SRC_BIT flag </p><div class="fragment"><div class="line">g_inspectorElement-&gt;inspectBuffer(cmd, 0);</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md385"></a>
#####                 IMAGE INSPECTION</h1>
<p>Inspection of the image stored in m_texture, with format RGBA32F. Other formats can be specified using the syntax above </p><div class="fragment"><div class="line">ElementInspector::ImageInspectionInfo info{};</div>
<div class="line">info.createInfo  = create_info;</div>
<div class="line">info.format      = g_inspectorElement-&gt;formatRGBA32();</div>
<div class="line">info.name        = <span class="stringliteral">&quot;MyImageInspection&quot;</span>;</div>
<div class="line">info.sourceImage = m_texture.image;</div>
<div class="line">g_inspectorElement-&gt;initImageInspection(0, info);</div>
</div><!-- fragment --><p>When the inspection is desired, simply add it to the current command buffer. Required barriers are added internally. </p><div class="fragment"><div class="line">g_inspectorElement-&gt;inspectImage(cmd, 0, imageCurrentLayout);</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md387"></a>
#####                 COMPUTE SHADER VARIABLE INSPECTION</h1>
<p>Inspect a compute shader variable for a given 3D grid and block size (use 1 for unused dimensions). This mode applies to shaders where invocation IDs (e.g. gl_LocalInvocationID) are defined, such as compute, mesh and task shaders. Since grids may contain many threads capturing a variable for all threads may incur large memory consumption and performance loss. The blocks to inspect, and the warps within those blocks can be specified using inspectedMin/MaxBlocks and inspectedMin/MaxWarp. </p><div class="fragment"><div class="line">computeInspectionFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(...);</div>
<div class="line">ElementInspector::ComputeInspectionInfo info{}; info.blockSize = blockSize;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a 4-component vector format where each component is a uint32_t. The components will be labeled myVec4u.x,</span></div>
<div class="line"><span class="comment">// myVec4u.y, myVec4u.z, myVec4u.w in the UI</span></div>
<div class="line">info.format           = ElementInspector::formatVector4(eUint32, <span class="stringliteral">&quot;myVec4u&quot;</span>);</div>
<div class="line">info.gridSizeInBlocks = gridSize;</div>
<div class="line">info.minBlock         = inspectedMinBlock;</div>
<div class="line">info.maxBlock         = inspectedMaxBlock;</div>
<div class="line">info.minWarp          = inspectedMinWarp;</div>
<div class="line">info.maxWarp          = inspectedMaxWarp;</div>
<div class="line">info.name             = <span class="stringliteral">&quot;My Compute Inspection&quot;</span>;</div>
<div class="line">g_inspectorElement-&gt;initComputeInspection(0, info);</div>
</div><!-- fragment --><p>To allow variable inspection two buffers need to be made available to the target shader: m_computeShader.updateBufferBinding(eThreadInspection, g_inspectorElement-&gt;getComputeInspectionBuffer(0)); m_computeShader.updateBufferBinding(eThreadMetadata, g_inspectorElement-&gt;getComputeMetadataBuffer(0));</p>
<p>The shader code needs to indicate include the Inspector header along with preprocessor variables to set the inspection mode to Compute, and indicate the binding points for the buffers: </p><div class="fragment"><div class="line"><span class="preprocessor">#define INSPECTOR_MODE_COMPUTE</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_DESCRIPTOR_SET 0</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_INSPECTION_DATA_BINDING 1</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_METADATA_BINDING 2</span></div>
<div class="line"><span class="preprocessor">#include &quot;dh_inspector.h&quot;</span></div>
</div><!-- fragment --><p>The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be unpacked within the Inspector for display according to the specified format. </p><div class="fragment"><div class="line">uint32_t myVariable = myFunction(...);</div>
<div class="line">inspect32BitValue(0, myVariable);</div>
</div><!-- fragment --><p>The inspection is triggered on the host side right after the compute shader invocation: </p><div class="fragment"><div class="line">m_computeShader.dispatchBlocks(cmd, computGridSize, &amp;constants);</div>
<div class="line"> </div>
<div class="line">g_inspectorElement-&gt;inspectComputeVariables(cmd, 0);</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md389"></a>
#####                 FRAGMENT SHADER VARIABLE INSPECTION</h1>
<p>Inspect a fragment shader variable for a given output image resolution. Since the image may have high resolution capturing a variable for all threads may incur large memory consumption and performance loss. The bounding box of the fragments to inspect can be specified using inspectedMin/MaxCoord. IMPORTANT: Overlapping geometry may trigger several fragment shader invocations for a given pixel. The inspection will only store the value of the foremost fragment (with the lowest gl_FragCoord.z). </p><div class="fragment"><div class="line">fragmentInspectionFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(...);</div>
<div class="line">FragmentInspectionInfo info{};</div>
<div class="line">info.name        = <span class="stringliteral">&quot;My Fragment Inspection&quot;</span>;</div>
<div class="line">info.format      = fragmentInspectionFormat;</div>
<div class="line">info.renderSize  = imageSize;</div>
<div class="line">info.minFragment = inspectedMinCoord;</div>
<div class="line">info.maxFragment = inspectedMaxCoord;</div>
<div class="line">g_inspectorElement-&gt;initFragmentInspection(0, info);</div>
</div><!-- fragment --><p>To allow variable inspection two storage buffers need to be declared in the pipeline layout and made available as follows: </p><div class="fragment"><div class="line">std::vector&lt;VkWriteDescriptorSet&gt; writes;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo inspectorInspection{</div>
<div class="line">   g_inspectorElement-&gt;getFragmentInspectionBuffer(0),</div>
<div class="line">   0,</div>
<div class="line">   VK_WHOLE_SIZE};</div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 1, &amp;inspectorInspection));</div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo inspectorMetadata{</div>
<div class="line">   g_inspectorElement-&gt;getFragmentMetadataBuffer(0),</div>
<div class="line">   0,</div>
<div class="line">   VK_WHOLE_SIZE};</div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 2, &amp;inspectorMetadata));</div>
<div class="line"> </div>
<div class="line">vkUpdateDescriptorSets(m_device, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(writes.size()), writes.data(), 0, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>The shader code needs to indicate include the Inspector header along with preprocessor variables to set the inspection mode to Fragment, and indicate the binding points for the buffers: </p><div class="fragment"><div class="line"><span class="preprocessor">#define INSPECTOR_MODE_FRAGMENT</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_DESCRIPTOR_SET 0</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_INSPECTION_DATA_BINDING 1</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_METADATA_BINDING 2</span></div>
<div class="line"><span class="preprocessor">#include &quot;dh_inspector.h&quot;</span></div>
</div><!-- fragment --><p>The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be unpacked within the Inspector for display according to the specified format. </p><div class="fragment"><div class="line">uint32_t myVariable = myFunction(...);</div>
<div class="line">inspect32BitValue(0, myVariable);</div>
</div><!-- fragment --><p>The inspection data for a pixel will only be written if a fragment actually covers that pixel. To avoid ghosting where no fragments are rendered it is useful to clear the inspection data before rendering: </p><div class="fragment"><div class="line">g_inspectorElement-&gt;clearFragmentVariables(cmd, 0);</div>
<div class="line">vkCmdBeginRendering(...);</div>
</div><!-- fragment --><p>The inspection is triggered on the host side right after rendering: </p><div class="fragment"><div class="line">vkCmdEndRendering(cmd);</div>
<div class="line">g_inspectorElement-&gt;inspectFragmentVariables(cmd, 0);</div>
</div><!-- fragment --><hr  />
 <h1><a class="anchor" id="autotoc_md391"></a>
#####                 CUSTOM SHADER VARIABLE INSPECTION</h1>
<p>In case some in-shader data has to be inspected in other shader types, or not on a once-per-thread basis, the custom inspection mode can be used. This mode allows the user to specify the overall size of the generated data as well as an effective inspection window. This mode may be used in conjunction with the COMPUTE and FRAGMENT modes. std::vector&lt;ElementInspector::ValueFormat&gt; customCaptureFormat; </p><div class="fragment"><div class="line">...</div>
<div class="line">ElementInspector::CustomInspectionInfo info{};</div>
<div class="line">info.extent   = totalInspectionSize;</div>
<div class="line">info.format   = customCaptureFormat;</div>
<div class="line">info.minCoord = inspectionWindowMin;</div>
<div class="line">info.maxCoord = inspectionWindowMax;</div>
<div class="line">info.name     = <span class="stringliteral">&quot;My Custom Capture&quot;</span>;</div>
<div class="line">g_inspectorElement-&gt;initCustomInspection(0, info);</div>
</div><!-- fragment --><p>To allow variable inspection two buffers need to be made available to the target pipeline: </p><div class="fragment"><div class="line">std::vector&lt;VkWriteDescriptorSet&gt; writes;</div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo      inspectorInspection{</div>
<div class="line">   g_inspectorElement-&gt;getCustomInspectionBuffer(0),</div>
<div class="line">   0,</div>
<div class="line">   VK_WHOLE_SIZE};</div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 1, &amp;inspectorInspection));</div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo inspectorMetadata{</div>
<div class="line">   g_inspectorElement-&gt;getCustomMetadataBuffer(0),</div>
<div class="line">   0,</div>
<div class="line">   VK_WHOLE_SIZE};</div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 2, &amp;inspectorMetadata));</div>
<div class="line"> </div>
<div class="line">vkUpdateDescriptorSets(m_device, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(writes.size()), writes.data(), 0, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>The shader code needs to indicate include the Inspector header along with preprocessor variables to set the inspection mode to Fragment, and indicate the binding points for the buffers: </p><div class="fragment"><div class="line"><span class="preprocessor">#define INSPECTOR_MODE_CUSTOM</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_DESCRIPTOR_SET 0</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_CUSTOM_INSPECTION_DATA_BINDING 1</span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_CUSTOM_METADATA_BINDING 2</span></div>
<div class="line"><span class="preprocessor">#include &quot;dh_inspector.h&quot;</span></div>
</div><!-- fragment --><p> The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be unpacked within the Inspector for display according to the specified format. </p><div class="fragment"><div class="line">uint32_t myVariable = myFunction(...);</div>
<div class="line">inspectCustom32BitValue(0, myCoordinates, myVariable);</div>
</div><!-- fragment --><p>The inspection is triggered on the host side right after running the pipeline: </p><div class="fragment"><div class="line">g_inspectorElement-&gt;inspectCustomVariables(cmd, 0);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md392"></a>
element_logger.hpp</h1>
<h2><a class="anchor" id="autotoc_md393"></a>
class nvvkhl::ElementLogger</h2>
<blockquote class="doxtable">
<p>This class is an element of the application that can redirect all logs to a <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a> window in the application </p>
</blockquote>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<p>Create the element such that it will be available to the target application</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">static</span> nvvkhl::SampleAppLog g_logger;</div>
<div class="line">nvprintSetCallback([](<span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">char</span>* fmt)</div>
<div class="line">{</div>
<div class="line">  g_logger.addLog(<span class="stringliteral">&quot;%s&quot;</span>, fmt);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">app-&gt;addElement(std::make_unique&lt;nvvkhl::ElementLogger&gt;(&amp;g_logger, <span class="keyword">true</span>));  <span class="comment">// Add logger window</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md394"></a>
element_nvml.hpp</h1>
<h2><a class="anchor" id="autotoc_md395"></a>
class nvvkhl::ElementNvml</h2>
<blockquote class="doxtable">
<p>This class is an element of the application that is responsible for the NVML monitoring. It is using the <code>NVML</code> library to get information about the GPU and display it in the application. </p>
</blockquote>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<h1><a class="anchor" id="autotoc_md396"></a>
element_profiler.hpp</h1>
<h2><a class="anchor" id="autotoc_md397"></a>
class nvvkhl::ElementProfiler</h2>
<blockquote class="doxtable">
<p>This class is an element of the application that is responsible for the profiling of the application. It is using the <code>nvvk::ProfilerVK</code> to profile the time parts of the computation done on the GPU. </p>
</blockquote>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<p>The profiler element, is there to help profiling the time parts of the computation is done on the GPU. To use it, follow those simple steps</p>
<p>In the main() program, create an instance of the profiler and add it to the <a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></p>
<div class="fragment"><div class="line">std::shared_ptr&lt;nvvkhl::ElementProfiler&gt; profiler = std::make_shared&lt;nvvkhl::ElementProfiler&gt;();</div>
<div class="line">app-&gt;addElement(profiler);</div>
</div><!-- fragment --><p>In the application where profiling needs to be done, add profiling sections</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> mySample::onRender(VkCommandBuffer cmd)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">auto</span> sec = m_profiler-&gt;timeRecurring(__FUNCTION__, cmd);</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Subsection</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> sec = m_profiler-&gt;timeRecurring(<span class="stringliteral">&quot;Dispatch&quot;</span>, cmd);</div>
<div class="line">    vkCmdDispatch(cmd, (size.width + (GROUP_SIZE - 1)) / GROUP_SIZE, (size.height + (GROUP_SIZE - 1)) / GROUP_SIZE, 1);</div>
<div class="line">  }</div>
<div class="line">  ...</div>
</div><!-- fragment --><p>This is it and the execution time on the GPU for each part will be showing in the Profiler window.</p>
<h1><a class="anchor" id="autotoc_md398"></a>
element_testing.hpp</h1>
<blockquote class="doxtable">
<p>Todo: Add documentation </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md399"></a>
gbuffer.hpp</h1>
<h2><a class="anchor" id="autotoc_md400"></a>
class nvvkhl::GBuffer</h2>
<blockquote class="doxtable">
<p>This class is an help for creating GBuffers. </p>
</blockquote>
<p>This can be use to create a GBuffer with multiple color images and a depth image. The GBuffer can be used to render the scene in multiple passes, such as deferred rendering.</p>
<p>To use this class, you need to create it and call the <code>create</code> method to create the GBuffer. The <code>create</code> method will create the images and the descriptor set for the GBuffer. The <code>destroy</code> method will destroy the images and the descriptor set.</p>
<p>Note: the <code>getDescriptorSet</code> method can be use to display the image in <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a>. Ex: <code>ImGui::Image((ImTextureID)gbuffer.getDescriptorSet(), ImVec2(128, 128));</code></p>
<h1><a class="anchor" id="autotoc_md401"></a>
glsl_compiler.hpp</h1>
<h2><a class="anchor" id="autotoc_md402"></a>
class nvvkhl::GlslCompiler</h2>
<blockquote class="doxtable">
<p>This class is a wrapper around the shaderc compiler to help compiling GLSL to Spir-V using shaderC </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md403"></a>
gltf_scene_rtx.hpp</h1>
<h2><a class="anchor" id="autotoc_md404"></a>
class nvvkhl::SceneRtx</h2>
<blockquote class="doxtable">
<p>This class is responsible for the ray tracing acceleration structure. </p>
</blockquote>
<p>It is using the <code><a class="el" href="classnvh_1_1gltf_1_1_scene.html">nvh::gltf::Scene</a></code> and <code><a class="el" href="classnvvkhl_1_1_scene_vk.html">nvvkhl::SceneVk</a></code> information to create the acceleration structure.</p>
<h1><a class="anchor" id="autotoc_md405"></a>
gltf_scene_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md406"></a>
class nvvkhl::SceneVk</h2>
<blockquote class="doxtable">
<p>This class is responsible for the Vulkan version of the scene. </p>
</blockquote>
<p>It is using <code>nvvkhl::Scene</code> to create the Vulkan buffers and images.</p>
<h1><a class="anchor" id="autotoc_md407"></a>
hdr_env.hpp</h1>
<h2><a class="anchor" id="autotoc_md408"></a>
class nvvkhl::HdrEnv</h2>
<blockquote class="doxtable">
<p>Load an environment image (HDR) and create an acceleration structure for important light sampling. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md409"></a>
hdr_env_dome.hpp</h1>
<h2><a class="anchor" id="autotoc_md410"></a>
class nvvkhl::HdrEnvDome</h2>
<blockquote class="doxtable">
<p>Use an environment image (HDR) and create the cubic textures for glossy reflection and diffuse illumination. It also has the ability to render the HDR environment, in the background of an image. </p>
</blockquote>
<p>Using 4 compute shaders</p><ul>
<li>hdr_dome: to make the HDR as background</li>
<li>hdr_integrate_brdf : generate the BRDF lookup table</li>
<li>hdr_prefilter_diffuse : integrate the diffuse contribution in a cubemap</li>
<li>hdr_prefilter_glossy : integrate the glossy reflection in a cubemap</li>
</ul>
<h1><a class="anchor" id="autotoc_md411"></a>
pipeline_container.hpp</h1>
<h2><a class="anchor" id="autotoc_md412"></a>
struct nvvkhl::PipelineContainer</h2>
<blockquote class="doxtable">
<p>Small multi-pipeline container </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md413"></a>
scene_camera.hpp</h1>
<h2><a class="anchor" id="autotoc_md414"></a>
Function nvvkhl::setCameraFromScene</h2>
<blockquote class="doxtable">
<p>Set the camera from the scene, if no camera is found, it will fit the camera to the scene. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md415"></a>
sky.hpp</h1>
<h2><a class="anchor" id="autotoc_md416"></a>
class nvvkhl::SimpleSkyDome</h2>
<blockquote class="doxtable">
<p>This class is responsible for a basic sky dome. </p>
</blockquote>
<p>This class can render a basic sky dome with a sun, for both the rasterizer and the ray tracer.</p>
<p>The <code>draw</code> method is responsible for rendering the sky dome for the rasterizer. For ray tracing, there is no need to call this method, as the sky dome is part of the ray tracing shaders (see shaders/dh_sky.h).</p>
<h2><a class="anchor" id="autotoc_md417"></a>
class nvvkhl::PhysicalSkyDome</h2>
<blockquote class="doxtable">
<p>This class is responsible for rendering a physical sky </p>
</blockquote>
<p>This class can render a physical sky dome with a sun, for both the rasterizer and the ray tracer.</p>
<p>The <code>draw</code> method is responsible for rendering the sky dome for the rasterizer. For ray tracing, there is no need to call this method, as the sky dome is part of the ray tracing shaders (see shaders/dh_sky.h).</p>
<h1><a class="anchor" id="autotoc_md418"></a>
tonemap_postprocess.hpp</h1>
<h2><a class="anchor" id="autotoc_md419"></a>
class nvvkhl::TonemapperPostProcess</h2>
<blockquote class="doxtable">
<p>Takes an image in linear RGB, tonemaps it, converts it to sRGB, and applies color correction. </p>
</blockquote>
<p>There are two ways to use it, one which is graphic, the other is compute.</p>
<ul>
<li>The graphic will render a full screen quad with the input image. It is to the application to set the rendering target ( -&gt; G-Buffer0 )</li>
<li>The compute takes an image as input and write to an another one using a compute shader</li>
<li>It is either one or the other, both rendering aren't needed to post-process. If both are provided it is for convenience.</li>
</ul>
<p>Note: It is important in any cases to place a barrier if there is a transition from fragment to compute and compute to fragment to avoid missing results. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:40 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
