<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: nvvk Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacenvvk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nvvk Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_acceleration_structure_geometry_info.html">AccelerationStructureGeometryInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_acceleration_structure_build_data.html">AccelerationStructureBuildData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_blas_builder.html">BlasBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the construction and optimization of Bottom-Level Acceleration Structures (BLAS) for Vulkan Ray Tracing.  <a href="classnvvk_1_1_blas_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_app_window_profiler_v_k.html">AppWindowProfilerVK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_scope_command_buffer.html">ScopeCommandBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_ring_fences.html">RingFences</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_batch_submission.html">BatchSubmission</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_fenced_command_pools.html">FencedCommandPools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_context.html">Context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_debug_util.html">DebugUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_descriptor_set_container.html">DescriptorSetContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_axis_v_k.html">AxisVK</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_dedicated_memory_handle.html">DedicatedMemoryHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_dedicated_memory_allocator.html">DedicatedMemoryAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_d_m_a_memory_allocator.html">DMAMemoryAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_d_m_a_memory_allocator_t_s.html">DMAMemoryAllocatorTS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_mem_allocate_info.html">MemAllocateInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_baked_allocate_info.html">BakedAllocateInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_mem_allocator.html">MemAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_mem_handle_base.html">MemHandleBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_v_m_a_memory_handle.html">VMAMemoryHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_d_m_a_memory_handle.html">DMAMemoryHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_allocation.html">Allocation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_allocation_i_d.html">AllocationID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_gpu_crash_tracker.html">GpuCrashTracker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_graphics_pipeline_generator.html">GraphicsPipelineGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_graphic_shader_object_pipeline.html">GraphicShaderObjectPipeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_ray_picker_k_h_r.html">RayPickerKHR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_sparse_image_page.html">SparseImagePage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_sparse_image.html">SparseImage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_swap_chain_acquire_state.html">SwapChainAcquireState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvk_1_1_swap_chain.html">SwapChain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7aeb6b924bceb7716cfe160d9919811c"><td class="memItemLeft" align="right" valign="top"><a id="a7aeb6b924bceb7716cfe160d9919811c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DescriptorSupport_t</b> = std::underlying_type_t&lt; DescriptorSupport &gt;</td></tr>
<tr class="separator:a7aeb6b924bceb7716cfe160d9919811c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a0ebd04360d8e74757f4710aac2d7c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#ac6a0ebd04360d8e74757f4710aac2d7c">CheckResultCallback</a> = std::function&lt; void(VkResult, const char *, int32_t, const char *)&gt;</td></tr>
<tr class="separator:ac6a0ebd04360d8e74757f4710aac2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287abbf0554cb1ba77cb2254dd33bf1d"><td class="memItemLeft" align="right" valign="top"><a id="a287abbf0554cb1ba77cb2254dd33bf1d"></a>
typedef <a class="el" href="classnvvk_1_1_mem_handle_base.html">MemHandleBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>MemHandle</b></td></tr>
<tr class="separator:a287abbf0554cb1ba77cb2254dd33bf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3270e409c0c87077821791676b5443bf"><td class="memItemLeft" align="right" valign="top"><a id="a3270e409c0c87077821791676b5443bf"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>DescriptorSupport</b> : uint32_t { <b>CORE_1_0</b> = 0
, <b>CORE_1_2</b> = 1
, <b>INDEXING_EXT</b> = 2
 }</td></tr>
<tr class="separator:a3270e409c0c87077821791676b5443bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d87436aa3caaf868ea81f18d455d9c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a6d87436aa3caaf868ea81f18d455d9c1">accelerationStructureBarrier</a> (VkCommandBuffer cmd, VkAccessFlags src, VkAccessFlags dst)</td></tr>
<tr class="separator:a6d87436aa3caaf868ea81f18d455d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8aabfbccb4f4891332ab181c17338d"><td class="memItemLeft" align="right" valign="top"><a id="a0e8aabfbccb4f4891332ab181c17338d"></a>
VkTransformMatrixKHR&#160;</td><td class="memItemRight" valign="bottom"><b>toTransformMatrixKHR</b> (glm::mat4 matrix)</td></tr>
<tr class="separator:a0e8aabfbccb4f4891332ab181c17338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a75f78fb099907601ac9a52d2fa8e4"><td class="memItemLeft" align="right" valign="top"><a id="ae9a75f78fb099907601ac9a52d2fa8e4"></a>
VkDeviceSize&#160;</td><td class="memItemRight" valign="bottom"><b>getMaxScratchSize</b> (const std::vector&lt; <a class="el" href="structnvvk_1_1_acceleration_structure_build_data.html">AccelerationStructureBuildData</a> &gt; &amp;asBuildData)</td></tr>
<tr class="separator:ae9a75f78fb099907601ac9a52d2fa8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935dc6826c929389cbf27025fcc23347"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a935dc6826c929389cbf27025fcc23347">makeAccessMaskPipelineStageFlags</a> (uint32_t accessMask, VkPipelineStageFlags supportedShaderBits)</td></tr>
<tr class="separator:a935dc6826c929389cbf27025fcc23347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94783d4aa49d65107d3272c21adab2b7"><td class="memItemLeft" align="right" valign="top"><a id="a94783d4aa49d65107d3272c21adab2b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmdBegin</b> (VkCommandBuffer cmd, VkCommandBufferUsageFlags flags)</td></tr>
<tr class="separator:a94783d4aa49d65107d3272c21adab2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1769382158c517aa4276ca7bc908de7"><td class="memItemLeft" align="right" valign="top"><a id="ac1769382158c517aa4276ca7bc908de7"></a>
VkSubmitInfo&#160;</td><td class="memItemRight" valign="bottom"><b>makeSubmitInfo</b> (uint32_t numCmds, VkCommandBuffer *cmds, uint32_t numSignals, VkSemaphore *signals)</td></tr>
<tr class="separator:ac1769382158c517aa4276ca7bc908de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26aa3c58917460b3b01239141d6f7eec"><td class="memItemLeft" align="right" valign="top"><a id="a26aa3c58917460b3b01239141d6f7eec"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getVendorName</b> (uint32_t vendorID)</td></tr>
<tr class="separator:a26aa3c58917460b3b01239141d6f7eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fef15c51f953abd10a09421c41a166"><td class="memItemLeft" align="right" valign="top"><a id="a47fef15c51f953abd10a09421c41a166"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getVersionString</b> (uint32_t version)</td></tr>
<tr class="separator:a47fef15c51f953abd10a09421c41a166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95238588708e15481aea5fa5c4c80d0"><td class="memItemLeft" align="right" valign="top"><a id="ac95238588708e15481aea5fa5c4c80d0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getDeviceType</b> (uint32_t deviceType)</td></tr>
<tr class="separator:ac95238588708e15481aea5fa5c4c80d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5281af094d6c3c2d441d9157ec5165b8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a5281af094d6c3c2d441d9157ec5165b8">fileNameSplitter</a> (const char *n)</td></tr>
<tr class="separator:a5281af094d6c3c2d441d9157ec5165b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d4f79e76774fc1ff56c781c617586"><td class="memItemLeft" align="right" valign="top"><a id="a3a8d4f79e76774fc1ff56c781c617586"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>upToLastSpace</b> (const char *n)</td></tr>
<tr class="separator:a3a8d4f79e76774fc1ff56c781c617586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880a9192550ca02b0f8700b41452b8c9"><td class="memItemLeft" align="right" valign="top"><a id="a880a9192550ca02b0f8700b41452b8c9"></a>
DescriptorSupport&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (DescriptorSupport lhs, DescriptorSupport rhs)</td></tr>
<tr class="separator:a880a9192550ca02b0f8700b41452b8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0214a3eaa158ff8327addd050829351c"><td class="memItemLeft" align="right" valign="top"><a id="a0214a3eaa158ff8327addd050829351c"></a>
DescriptorSupport&#160;</td><td class="memItemRight" valign="bottom"><b>operator&amp;</b> (DescriptorSupport lhs, DescriptorSupport rhs)</td></tr>
<tr class="separator:a0214a3eaa158ff8327addd050829351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de59b95424a945a6cd3e2bebef405d3"><td class="memItemLeft" align="right" valign="top"><a id="a2de59b95424a945a6cd3e2bebef405d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSet</b> (DescriptorSupport test, DescriptorSupport query)</td></tr>
<tr class="separator:a2de59b95424a945a6cd3e2bebef405d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158dbebbde3aea9ad16276a25c013893"><td class="memItemLeft" align="right" valign="top"><a id="a158dbebbde3aea9ad16276a25c013893"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAnySet</b> (DescriptorSupport test, DescriptorSupport query)</td></tr>
<tr class="separator:a158dbebbde3aea9ad16276a25c013893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b535dceb807b1c1b4b7789d48caa5c"><td class="memItemLeft" align="right" valign="top">VkDescriptorPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a30b535dceb807b1c1b4b7789d48caa5c">createDescriptorPool</a> (VkDevice device, size_t poolSizeCount, const VkDescriptorPoolSize *poolSizes, uint32_t maxSets)</td></tr>
<tr class="separator:a30b535dceb807b1c1b4b7789d48caa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983b697d08a85e823987976f0cc515cc"><td class="memItemLeft" align="right" valign="top"><a id="a983b697d08a85e823987976f0cc515cc"></a>
VkDescriptorPool&#160;</td><td class="memItemRight" valign="bottom"><b>createDescriptorPool</b> (VkDevice device, const std::vector&lt; VkDescriptorPoolSize &gt; &amp;poolSizes, uint32_t maxSets)</td></tr>
<tr class="separator:a983b697d08a85e823987976f0cc515cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc084dbc6fe22953271e3ed3e6723230"><td class="memItemLeft" align="right" valign="top"><a id="acc084dbc6fe22953271e3ed3e6723230"></a>
VkDescriptorSet&#160;</td><td class="memItemRight" valign="bottom"><b>allocateDescriptorSet</b> (VkDevice device, VkDescriptorPool pool, VkDescriptorSetLayout layout)</td></tr>
<tr class="separator:acc084dbc6fe22953271e3ed3e6723230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2549da5120c84c3b921113491c144ee"><td class="memItemLeft" align="right" valign="top"><a id="ad2549da5120c84c3b921113491c144ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>allocateDescriptorSets</b> (VkDevice device, VkDescriptorPool pool, VkDescriptorSetLayout layout, uint32_t count, std::vector&lt; VkDescriptorSet &gt; &amp;sets)</td></tr>
<tr class="separator:ad2549da5120c84c3b921113491c144ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40a2eb6fea5c88eec7146f277580a5e"><td class="memItemLeft" align="right" valign="top"><a id="aa40a2eb6fea5c88eec7146f277580a5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCheckResultHook</b> (const <a class="el" href="namespacenvvk.html#ac6a0ebd04360d8e74757f4710aac2d7c">CheckResultCallback</a> &amp;callback)</td></tr>
<tr class="separator:aa40a2eb6fea5c88eec7146f277580a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331574fd0a3bd438dbdb0d09c1299d4d"><td class="memItemLeft" align="right" valign="top"><a id="a331574fd0a3bd438dbdb0d09c1299d4d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkResult</b> (VkResult result, const char *<a class="el" href="classmessage.html">message</a>)</td></tr>
<tr class="separator:a331574fd0a3bd438dbdb0d09c1299d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002fd7ca14a5dc769cdc0af1e1f7037b"><td class="memItemLeft" align="right" valign="top"><a id="a002fd7ca14a5dc769cdc0af1e1f7037b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkResult</b> (VkResult result, const char *file, int32_t line)</td></tr>
<tr class="separator:a002fd7ca14a5dc769cdc0af1e1f7037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c6494c03a40255f03c8bc03c535aab"><td class="memItemLeft" align="right" valign="top">VkImageMemoryBarrier&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a15c6494c03a40255f03c8bc03c535aab">makeImageMemoryBarrier</a> (VkImage img, VkAccessFlags srcAccess, VkAccessFlags dstAccess, VkImageLayout oldLayout, VkImageLayout newLayout, VkImageAspectFlags aspectMask)</td></tr>
<tr class="separator:a15c6494c03a40255f03c8bc03c535aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d9c0c0f6d15aea34afeffec8432a82"><td class="memItemLeft" align="right" valign="top"><a id="a06d9c0c0f6d15aea34afeffec8432a82"></a>
VkAccessFlags&#160;</td><td class="memItemRight" valign="bottom"><b>accessFlagsForImageLayout</b> (VkImageLayout layout)</td></tr>
<tr class="separator:a06d9c0c0f6d15aea34afeffec8432a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51145e1729dc06a9243d7094dd97712"><td class="memItemLeft" align="right" valign="top"><a id="ad51145e1729dc06a9243d7094dd97712"></a>
VkPipelineStageFlags&#160;</td><td class="memItemRight" valign="bottom"><b>pipelineStageForLayout</b> (VkImageLayout layout)</td></tr>
<tr class="separator:ad51145e1729dc06a9243d7094dd97712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15eeb0aa61765d6a80a7a9f1258373d"><td class="memItemLeft" align="right" valign="top"><a id="ab15eeb0aa61765d6a80a7a9f1258373d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmdBarrierImageLayout</b> (VkCommandBuffer cmdbuffer, VkImage image, VkImageLayout oldImageLayout, VkImageLayout newImageLayout, const VkImageSubresourceRange &amp;subresourceRange)</td></tr>
<tr class="separator:ab15eeb0aa61765d6a80a7a9f1258373d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba89bf3cd9e6385a29cbd112308582a7"><td class="memItemLeft" align="right" valign="top"><a id="aba89bf3cd9e6385a29cbd112308582a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmdBarrierImageLayout</b> (VkCommandBuffer cmdbuffer, VkImage image, VkImageLayout oldImageLayout, VkImageLayout newImageLayout, VkImageAspectFlags aspectMask)</td></tr>
<tr class="separator:aba89bf3cd9e6385a29cbd112308582a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffd073bfe94c82458fa651ea5761beb"><td class="memItemLeft" align="right" valign="top"><a id="a8ffd073bfe94c82458fa651ea5761beb"></a>
VkImageCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>makeImage2DCreateInfo</b> (const VkExtent2D &amp;size, VkFormat format, VkImageUsageFlags usage, bool mipmaps)</td></tr>
<tr class="separator:a8ffd073bfe94c82458fa651ea5761beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458320bf37f58901c654479f0196e46e"><td class="memItemLeft" align="right" valign="top"><a id="a458320bf37f58901c654479f0196e46e"></a>
VkImageViewCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>makeImage2DViewCreateInfo</b> (VkImage image, VkFormat format, VkImageAspectFlags aspectFlags, uint32_t levels, const void *pNextImageView)</td></tr>
<tr class="separator:a458320bf37f58901c654479f0196e46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff45ac2b304a592c74ae47b9066b3ad"><td class="memItemLeft" align="right" valign="top"><a id="a9ff45ac2b304a592c74ae47b9066b3ad"></a>
VkImageViewCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>makeImageViewCreateInfo</b> (VkImage image, const VkImageCreateInfo &amp;imageInfo, bool isCube)</td></tr>
<tr class="separator:a9ff45ac2b304a592c74ae47b9066b3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8555045a7746de156e4fe15cf1c080c6"><td class="memItemLeft" align="right" valign="top"><a id="a8555045a7746de156e4fe15cf1c080c6"></a>
VkImageCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>makeImage3DCreateInfo</b> (const VkExtent3D &amp;size, VkFormat format, VkImageUsageFlags usage, bool mipmaps)</td></tr>
<tr class="separator:a8555045a7746de156e4fe15cf1c080c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac2d462945f11f250a12d93aec97b0f"><td class="memItemLeft" align="right" valign="top"><a id="afac2d462945f11f250a12d93aec97b0f"></a>
VkImageCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>makeImageCubeCreateInfo</b> (const VkExtent2D &amp;size, VkFormat format, VkImageUsageFlags usage, bool mipmaps)</td></tr>
<tr class="separator:afac2d462945f11f250a12d93aec97b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae0613cd6ae203f19617748a433dcda"><td class="memItemLeft" align="right" valign="top"><a id="adae0613cd6ae203f19617748a433dcda"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmdGenerateMipmaps</b> (VkCommandBuffer cmdBuf, VkImage image, VkFormat imageFormat, const VkExtent2D &amp;size, uint32_t levelCount, uint32_t layerCount, VkImageLayout currentLayout)</td></tr>
<tr class="separator:adae0613cd6ae203f19617748a433dcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c1414cc1a1a54272b1ed958d24f911"><td class="memItemLeft" align="right" valign="top"><a id="a56c1414cc1a1a54272b1ed958d24f911"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>mipLevels</b> (VkExtent2D extent)</td></tr>
<tr class="separator:a56c1414cc1a1a54272b1ed958d24f911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215362cf2553709a5f22259c62f51a67"><td class="memItemLeft" align="right" valign="top"><a id="a215362cf2553709a5f22259c62f51a67"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>mipLevels</b> (VkExtent3D extent)</td></tr>
<tr class="separator:a215362cf2553709a5f22259c62f51a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06910345ffe7e0a81c3a6c376ac7511d"><td class="memItemLeft" align="right" valign="top"><a id="a06910345ffe7e0a81c3a6c376ac7511d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cmdBarrierImageLayout</b> (VkCommandBuffer cmdbuffer, VkImage image, VkImageLayout oldImageLayout, VkImageLayout newImageLayout)</td></tr>
<tr class="separator:a06910345ffe7e0a81c3a6c376ac7511d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2a70efe7d6ae7b93b8cc300f0d4e34"><td class="memItemLeft" align="right" valign="top"><a id="a1f2a70efe7d6ae7b93b8cc300f0d4e34"></a>
<a class="el" href="classnvvk_1_1_dedicated_memory_handle.html">DedicatedMemoryHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>castDedicatedMemoryHandle</b> (<a class="el" href="classnvvk_1_1_mem_handle_base.html">MemHandle</a> memHandle)</td></tr>
<tr class="separator:a1f2a70efe7d6ae7b93b8cc300f0d4e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5b971ce80fa3e16fd89036ad86825e"><td class="memItemLeft" align="right" valign="top"><a id="a3b5b971ce80fa3e16fd89036ad86825e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getMemoryType</b> (const VkPhysicalDeviceMemoryProperties &amp;memoryProperties, uint32_t typeBits, const VkMemoryPropertyFlags &amp;properties)</td></tr>
<tr class="separator:a3b5b971ce80fa3e16fd89036ad86825e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34f3018d909c59a4a0f1c639cc56061"><td class="memItemLeft" align="right" valign="top"><a id="ac34f3018d909c59a4a0f1c639cc56061"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fillBakedAllocateInfo</b> (const VkPhysicalDeviceMemoryProperties &amp;physMemProps, const <a class="el" href="classnvvk_1_1_mem_allocate_info.html">MemAllocateInfo</a> &amp;info, <a class="el" href="structnvvk_1_1_baked_allocate_info.html">BakedAllocateInfo</a> &amp;baked)</td></tr>
<tr class="separator:ac34f3018d909c59a4a0f1c639cc56061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57cc1912e6d0b94dd9e52110d023ea9"><td class="memItemLeft" align="right" valign="top"><a id="ab57cc1912e6d0b94dd9e52110d023ea9"></a>
<a class="el" href="classnvvk_1_1_v_m_a_memory_handle.html">VMAMemoryHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>castVMAMemoryHandle</b> (<a class="el" href="classnvvk_1_1_mem_handle_base.html">MemHandle</a> memHandle)</td></tr>
<tr class="separator:ab57cc1912e6d0b94dd9e52110d023ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65a96db07909620ae5f1889c2cc4a2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#af65a96db07909620ae5f1889c2cc4a2b">getMemoryInfo</a> (const VkPhysicalDeviceMemoryProperties &amp;memoryProperties, const VkMemoryRequirements &amp;memReqs, VkMemoryPropertyFlags properties, VkMemoryAllocateInfo &amp;memInfo, bool preferDevice)</td></tr>
<tr class="separator:af65a96db07909620ae5f1889c2cc4a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae0950dffa629dd8adf5acf2df6dc54"><td class="memItemLeft" align="right" valign="top"><a id="abae0950dffa629dd8adf5acf2df6dc54"></a>
<a class="el" href="classnvvk_1_1_d_m_a_memory_handle.html">DMAMemoryHandle</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>castDMAMemoryHandle</b> (<a class="el" href="classnvvk_1_1_mem_handle_base.html">MemHandle</a> memHandle)</td></tr>
<tr class="separator:abae0950dffa629dd8adf5acf2df6dc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97100510a4dbabdc8390996452197525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a97100510a4dbabdc8390996452197525">nvprintPipelineStats</a> (VkDevice device, VkPipeline pipeline, const char *name, bool verbose)</td></tr>
<tr class="separator:a97100510a4dbabdc8390996452197525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7932f7f10761cd1cfd4f8132b435e7"><td class="memItemLeft" align="right" valign="top"><a id="a0f7932f7f10761cd1cfd4f8132b435e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpPipelineStats</b> (VkDevice device, VkPipeline pipeline, const char *fileName)</td></tr>
<tr class="separator:a0f7932f7f10761cd1cfd4f8132b435e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef433c897f606f431e64c26e31c66dc0"><td class="memItemLeft" align="right" valign="top"><a id="aef433c897f606f431e64c26e31c66dc0"></a>
static std::string&#160;</td><td class="memItemRight" valign="bottom"><b>stringFormat</b> (const char *msg,...)</td></tr>
<tr class="separator:aef433c897f606f431e64c26e31c66dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20c6e53a5c0ddfa8ffc64191c5d2341"><td class="memItemLeft" align="right" valign="top"><a id="ac20c6e53a5c0ddfa8ffc64191c5d2341"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpPipelineInternals</b> (VkDevice device, VkPipeline pipeline, const char *baseFileName)</td></tr>
<tr class="separator:ac20c6e53a5c0ddfa8ffc64191c5d2341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48bef8c10b508bf1a69f7f8bc45456d"><td class="memItemLeft" align="right" valign="top">VkFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#ae48bef8c10b508bf1a69f7f8bc45456d">findSupportedFormat</a> (VkPhysicalDevice physicalDevice, const std::vector&lt; VkFormat &gt; &amp;candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</td></tr>
<tr class="separator:ae48bef8c10b508bf1a69f7f8bc45456d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f42bb5e57efa2c92732e83a7de19b8"><td class="memItemLeft" align="right" valign="top"><a id="ad5f42bb5e57efa2c92732e83a7de19b8"></a>
VkFormat&#160;</td><td class="memItemRight" valign="bottom"><b>findDepthFormat</b> (VkPhysicalDevice physicalDevice)</td></tr>
<tr class="separator:ad5f42bb5e57efa2c92732e83a7de19b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807270960649c0a32963957d75c86f9f"><td class="memItemLeft" align="right" valign="top"><a id="a807270960649c0a32963957d75c86f9f"></a>
VkFormat&#160;</td><td class="memItemRight" valign="bottom"><b>findDepthStencilFormat</b> (VkPhysicalDevice physicalDevice)</td></tr>
<tr class="separator:a807270960649c0a32963957d75c86f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2c11e99bc588736a552b78b0ef6549"><td class="memItemLeft" align="right" valign="top"><a id="a9c2c11e99bc588736a552b78b0ef6549"></a>
VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><b>createRenderPass</b> (VkDevice device, const std::vector&lt; VkFormat &gt; &amp;colorAttachmentFormats, VkFormat depthAttachmentFormat, uint32_t subpassCount, bool clearColor, bool clearDepth, VkImageLayout initialLayout, VkImageLayout finalLayout)</td></tr>
<tr class="separator:a9c2c11e99bc588736a552b78b0ef6549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b6bd71ff1e8bd7fb9cb4ba8f1eba27"><td class="memItemLeft" align="right" valign="top"><a id="a43b6bd71ff1e8bd7fb9cb4ba8f1eba27"></a>
VkSamplerCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>makeSamplerCreateInfo</b> (VkFilter magFilter, VkFilter minFilter, VkSamplerAddressMode addressModeU, VkSamplerAddressMode addressModeV, VkSamplerAddressMode addressModeW, VkBool32 anisotropyEnable, float maxAnisotropy, VkSamplerMipmapMode mipmapMode, float minLod, float maxLod, float mipLodBias, VkBool32 compareEnable, VkCompareOp compareOp, VkBorderColor borderColor, VkBool32 unnormalizedCoordinates)</td></tr>
<tr class="separator:a43b6bd71ff1e8bd7fb9cb4ba8f1eba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4be9c2372f07f7bf258c346947afab"><td class="memItemLeft" align="right" valign="top">VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a4a4be9c2372f07f7bf258c346947afab">createShaderModule</a> (VkDevice device, const uint32_t *binarycode, size_t sizeInBytes, bool doCheck=true)</td></tr>
<tr class="separator:a4a4be9c2372f07f7bf258c346947afab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0059d478a2337f98eb0d811814554c9"><td class="memItemLeft" align="right" valign="top"><a id="aa0059d478a2337f98eb0d811814554c9"></a>
VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><b>createShaderModule</b> (VkDevice device, const void *binarycode, size_t sizeInBytes)</td></tr>
<tr class="separator:aa0059d478a2337f98eb0d811814554c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fce150e373a7ceb926472a8c26b8abb"><td class="memItemLeft" align="right" valign="top"><a id="a6fce150e373a7ceb926472a8c26b8abb"></a>
VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><b>createShaderModule</b> (VkDevice device, const char *binarycode, size_t numInt32)</td></tr>
<tr class="separator:a6fce150e373a7ceb926472a8c26b8abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0d281a1a67226ef1b0ec1d6d52e55b"><td class="memItemLeft" align="right" valign="top"><a id="a8a0d281a1a67226ef1b0ec1d6d52e55b"></a>
VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><b>createShaderModule</b> (VkDevice device, const std::vector&lt; char &gt; &amp;code)</td></tr>
<tr class="separator:a8a0d281a1a67226ef1b0ec1d6d52e55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d1a554c7eb4632a72fb93b69ac5ba9"><td class="memItemLeft" align="right" valign="top"><a id="a61d1a554c7eb4632a72fb93b69ac5ba9"></a>
VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><b>createShaderModule</b> (VkDevice device, const std::vector&lt; uint8_t &gt; &amp;code)</td></tr>
<tr class="separator:a61d1a554c7eb4632a72fb93b69ac5ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad0536496a748656f204b1bdb436c22"><td class="memItemLeft" align="right" valign="top"><a id="adad0536496a748656f204b1bdb436c22"></a>
VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><b>createShaderModule</b> (VkDevice device, const std::vector&lt; uint32_t &gt; &amp;code)</td></tr>
<tr class="separator:adad0536496a748656f204b1bdb436c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4a5b63ed7058f5cb2819f9f7b0f5ed"><td class="memItemLeft" align="right" valign="top"><a id="aae4a5b63ed7058f5cb2819f9f7b0f5ed"></a>
VkShaderModule&#160;</td><td class="memItemRight" valign="bottom"><b>createShaderModule</b> (VkDevice device, const std::string &amp;code)</td></tr>
<tr class="separator:aae4a5b63ed7058f5cb2819f9f7b0f5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8333adb6b43432c365af340d54db388b"><td class="memTemplParams" colspan="2"><a id="a8333adb6b43432c365af340d54db388b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8333adb6b43432c365af340d54db388b"><td class="memTemplItemLeft" align="right" valign="top">VkPipelineShaderStageCreateInfo&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createShaderStageInfo</b> (VkDevice device, const std::vector&lt; T &gt; &amp;code, VkShaderStageFlagBits stage, const char *entryPoint=&quot;main&quot;)</td></tr>
<tr class="separator:a8333adb6b43432c365af340d54db388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a4c6a4598c87c60e7874cffabc63a4"><td class="memItemLeft" align="right" valign="top"><a id="a80a4c6a4598c87c60e7874cffabc63a4"></a>
VkPipelineShaderStageCreateInfo&#160;</td><td class="memItemRight" valign="bottom"><b>createShaderStageInfo</b> (VkDevice device, const std::string &amp;code, VkShaderStageFlagBits stage, const char *entryPoint=&quot;main&quot;)</td></tr>
<tr class="separator:a80a4c6a4598c87c60e7874cffabc63a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07893ad7abcfa555a2b47ce6ace9c28"><td class="memItemLeft" align="right" valign="top"><a id="af07893ad7abcfa555a2b47ce6ace9c28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkResult</b> (vk::Result result, const char *<a class="el" href="classmessage.html">message</a>)</td></tr>
<tr class="separator:af07893ad7abcfa555a2b47ce6ace9c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4786e14337f9e98d45320667aebd65"><td class="memItemLeft" align="right" valign="top"><a id="a3d4786e14337f9e98d45320667aebd65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkResult</b> (vk::Result result, const char *file, int32_t line)</td></tr>
<tr class="separator:a3d4786e14337f9e98d45320667aebd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a262f5eb0ae6944959d7935941ace49ae"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvk.html#a262f5eb0ae6944959d7935941ace49ae">DEFAULT_RING_SIZE</a> = 3</td></tr>
<tr class="separator:a262f5eb0ae6944959d7935941ace49ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ef2aab3f1480f53204f7f6a244cbc"><td class="memItemLeft" align="right" valign="top"><a id="a570ef2aab3f1480f53204f7f6a244cbc"></a>
<a class="el" href="namespacenvvk.html#ac6a0ebd04360d8e74757f4710aac2d7c">CheckResultCallback</a>&#160;</td><td class="memItemRight" valign="bottom"><b>g_checkResultCallback</b></td></tr>
<tr class="separator:a570ef2aab3f1480f53204f7f6a244cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43536637cf9305b80a80a3876fe8e739"><td class="memItemLeft" align="right" valign="top"><a id="a43536637cf9305b80a80a3876fe8e739"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>s_vert_spv</b> []</td></tr>
<tr class="separator:a43536637cf9305b80a80a3876fe8e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202ff7ad3faf12830b843588ff1bbc69"><td class="memItemLeft" align="right" valign="top">static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>s_frag_spv</b> []</td></tr>
<tr class="separator:a202ff7ad3faf12830b843588ff1bbc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec789ee761d3792a3cd44029b542f09"><td class="memItemLeft" align="right" valign="top"><a id="a6ec789ee761d3792a3cd44029b542f09"></a>
static const <a class="el" href="classnvvk_1_1_mem_handle_base.html">MemHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NullMemHandle</b> = nullptr</td></tr>
<tr class="separator:a6ec789ee761d3792a3cd44029b542f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345592a2fcd7a7748fc958f30189203c"><td class="memItemLeft" align="right" valign="top"><a id="a345592a2fcd7a7748fc958f30189203c"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>INVALID_ID_INDEX</b> = ~0</td></tr>
<tr class="separator:a345592a2fcd7a7748fc958f30189203c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md186"></a>
Function nvvk::checkResult</h1>
<blockquote class="doxtable">
<p>Checks Vulkan return codes. On error (a negative result code), it prints a message showing what failed and halts the program. </p>
</blockquote>
<p>Use <code>NVVK_CHECK(result)</code> to automatically log filename/linenumber. @DOC_END</p>
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md202"></a>
class nvvk::RayPickerKHR</h1>
<p><a class="el" href="structnvvk_1_1_ray_picker_k_h_r.html">nvvk::RayPickerKHR</a> is a utility to get hit information under a screen coordinate.</p>
<p>The information returned is:</p><ul>
<li>origin and direction in world space</li>
<li>hitT, the distance of the hit along the ray direction</li>
<li>primitiveID, instanceID and instanceCustomIndex</li>
<li>the barycentric coordinates in the triangle</li>
</ul>
<p>Setting up:</p><ul>
<li>call setup() once with the Vulkan device, and allocator</li>
<li>call setTlas with the TLAS previously build</li>
</ul>
<p>Getting results, for example, on mouse down:</p><ul>
<li>fill the PickInfo structure</li>
<li>call run()</li>
<li>call getResult() to get all the information above</li>
</ul>
<p>Example to set the camera interest point ```cpp <a class="el" href="structnvvk_1_1_ray_picker_k_h_r_1_1_pick_result.html">RayPickerKHR::PickResult</a> pr = m_picker.getResult(); if(pr.instanceID != ~0) // Hit something { glm::vec3 worldPos = pr.worldRayOrigin + pr.worldRayDirection * pr.hitT; glm::vec3 eye, center, up; CameraManip.getLookat(eye, center, up); CameraManip.setLookat(eye, worldPos, up, false); // Nice with CameraManip.updateAnim(); } ``` @DOC_END</p>
<p>@DOC_START</p>
<h1><a class="anchor" id="autotoc_md498"></a>
class nvvkhl::TonemapperPostProcess</h1>
<blockquote class="doxtable">
<p>Takes an image in linear RGB, tonemaps it, converts it to sRGB, and applies color correction. </p>
</blockquote>
<p>There are two ways to use it, one which is graphic, the other is compute.</p>
<ul>
<li>The graphic will render a full screen quad with the input image. It is to the application to set the rendering target ( -&gt; G-Buffer0 )</li>
<li>The compute takes an image as input and write to an another one using a compute shader</li>
<li>It is either one or the other, both rendering aren't needed to post-process. If both are provided it is for convenience.</li>
</ul>
<p>Note: It is important in any cases to place a barrier if there is a transition from fragment to compute and compute to fragment to avoid missing results.</p>
<p>@DOC_END </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac6a0ebd04360d8e74757f4710aac2d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a0ebd04360d8e74757f4710aac2d7c">&#9670;&nbsp;</a></span>CheckResultCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenvvk.html#ac6a0ebd04360d8e74757f4710aac2d7c">nvvk::CheckResultCallback</a> = typedef std::function&lt;void(VkResult, const char*, int32_t, const char*)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md187"></a>
Function nvvk::setCheckResultHook</h1>
<blockquote class="doxtable">
<p>Allow replacing nvvk::checkResult() calls. E.g. to catch </p>
</blockquote>
<p><code>VK_ERROR_DEVICE_LOST</code> and wait for aftermath to write the crash dump. @DOC_END </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6d87436aa3caaf868ea81f18d455d9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d87436aa3caaf868ea81f18d455d9c1">&#9670;&nbsp;</a></span>accelerationStructureBarrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nvvk::accelerationStructureBarrier </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkAccessFlags&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkAccessFlags&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@DOC_START</p>
<h1><a class="anchor" id="autotoc_md165"></a>
&lt;tt&gt;nvvk::accelerationStructureBarrier&lt;/tt&gt; Function</h1>
<p>This function sets up a memory barrier specifically for acceleration structure operations in Vulkan, ensuring proper data synchronization during the build or update phases. It operates between pipeline stages that deal with acceleration structure building.</p>
<h1><a class="anchor" id="autotoc_md166"></a>
&lt;tt&gt;nvvk::toTransformMatrixKHR&lt;/tt&gt; Function</h1>
<p>This function converts a <code>glm::mat4</code> matrix to the matrix format required by acceleration structures in Vulkan.</p>
<h1><a class="anchor" id="autotoc_md167"></a>
&lt;tt&gt;nvvk::AccelerationStructureGeometryInfo&lt;/tt&gt; Structure</h1>
<ul>
<li><b>Purpose</b>: Holds information about acceleration structure geometry, including the geometry structure and build range information.</li>
</ul>
<h1><a class="anchor" id="autotoc_md168"></a>
&lt;tt&gt;nvvk::AccelerationStructureBuildData&lt;/tt&gt; Structure</h1>
<ul>
<li><b>Purpose</b>: Manages the building of Vulkan acceleration structures of a specified type.</li>
<li><b>Key Functions</b>:<ul>
<li><code>addGeometry</code>: Adds a geometry with build range information to the acceleration structure.</li>
<li><code>finalizeGeometry</code>: Configures the build information and calculates the necessary size information.</li>
<li><code>makeCreateInfo</code>: Creates an acceleration structure based on the current build and size information.</li>
<li><code>cmdBuildAccelerationStructure</code>: Builds the acceleration structure in a Vulkan command buffer.</li>
<li><code>cmdUpdateAccelerationStructure</code>: Updates the acceleration structure in a Vulkan command buffer.</li>
<li><code>hasCompactFlag</code>: Checks if the compact flag is set for the build.</li>
</ul>
</li>
<li><p class="startli"><b>Usage</b>:</p><ul>
<li>For each BLAS,<ul>
<li>Add geometry using <code>addGeometry</code>.</li>
<li>Finalize the geometry and get the size requirements using <code>finalizeGeometry</code>.</li>
<li>Keep the max scratch buffer size in mind when creating the scratch buffer.</li>
</ul>
</li>
<li>Create Scratch Buffer using the information returned by finalizeGeometry.</li>
<li>For each BLAS,<ul>
<li>Create the acceleration structure using <code>makeCreateInfo</code>.</li>
</ul>
</li>
</ul>
<p class="startli">@DOC_END </p>
</li>
</ul>

</div>
</div>
<a id="a30b535dceb807b1c1b4b7789d48caa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b535dceb807b1c1b4b7789d48caa5c">&#9670;&nbsp;</a></span>createDescriptorPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkDescriptorPool nvvk::createDescriptorPool </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poolSizeCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDescriptorPoolSize *&#160;</td>
          <td class="paramname"><em>poolSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxSets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md182"></a>
functions in nvvk</h1>
<ul>
<li>createDescriptorPool : wrappers for vkCreateDescriptorPool</li>
<li>allocateDescriptorSet : allocates a single VkDescriptorSet</li>
<li>allocateDescriptorSets : allocates multiple VkDescriptorSets</li>
</ul>
<p>@DOC_END </p>

</div>
</div>
<a id="a4a4be9c2372f07f7bf258c346947afab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4be9c2372f07f7bf258c346947afab">&#9670;&nbsp;</a></span>createShaderModule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkShaderModule nvvk::createShaderModule </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>binarycode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doCheck</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md318"></a>
functions in nvvk</h1>
<ul>
<li>createShaderModule : create the shader module from various binary code inputs</li>
<li>createShaderStageInfo: create the shader module and setup the stage from the incoming binary code @DOC_END </li>
</ul>

</div>
</div>
<a id="a5281af094d6c3c2d441d9157ec5165b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5281af094d6c3c2d441d9157ec5165b8">&#9670;&nbsp;</a></span>fileNameSplitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* nvvk::fileNameSplitter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Macros to help automatically naming variables. Names will be in the form of MyClass::m_myBuffer (in example.cpp:123)</p>
<p>To use:</p><ul>
<li>Debug member class MUST be named 'm_debug'</li>
<li>Individual name: NAME_VK(m_myBuffer.buffer) or with and index NAME_IDX_VK(m_texture.image, i)</li>
<li>Create/associate and name, instead of pipeline = createPipeline(); NAME_VK(pipeline) call CREATE_NAMED_VK(pipeline , createPipeline());</li>
<li>Scope functions can also be automatically named, at the beginning of a function call LABEL_SCOPE_VK( commandBuffer ) </li>
</ul>

</div>
</div>
<a id="ae48bef8c10b508bf1a69f7f8bc45456d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48bef8c10b508bf1a69f7f8bc45456d">&#9670;&nbsp;</a></span>findSupportedFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkFormat nvvk::findSupportedFormat </td>
          <td>(</td>
          <td class="paramtype">VkPhysicalDevice&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; VkFormat &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageTiling&#160;</td>
          <td class="paramname"><em>tiling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkFormatFeatureFlags&#160;</td>
          <td class="paramname"><em>features</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md317"></a>
functions in nvvk</h1>
<ul>
<li>findSupportedFormat : returns supported VkFormat from a list of candidates (returns first match)</li>
<li>findDepthFormat : returns supported depth format (24, 32, 16-bit)</li>
<li>findDepthStencilFormat : returns supported depth-stencil format (24/8, 32/8, 16/8-bit)</li>
<li>createRenderPass : wrapper for vkCreateRenderPass</li>
</ul>
<p>@DOC_END </p>

</div>
</div>
<a id="af65a96db07909620ae5f1889c2cc4a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65a96db07909620ae5f1889c2cc4a2b">&#9670;&nbsp;</a></span>getMemoryInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nvvk::getMemoryInfo </td>
          <td>(</td>
          <td class="paramtype">const VkPhysicalDeviceMemoryProperties &amp;&#160;</td>
          <td class="paramname"><em>memoryProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkMemoryRequirements &amp;&#160;</td>
          <td class="paramname"><em>memReqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryPropertyFlags&#160;</td>
          <td class="paramname"><em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkMemoryAllocateInfo &amp;&#160;</td>
          <td class="paramname"><em>memInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preferDevice</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@DOC_START This framework assumes that memory heaps exists that support:</p>
<ul>
<li>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT &amp; VK_MEMORY_PROPERTY_HOST_COHERENT_BIT for uploading data to the device</li>
<li>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT &amp; VK_MEMORY_PROPERTY_HOST_CACHED_BIT for downloading data from the device</li>
</ul>
<p>This is typical on all major desktop platforms and vendors. See <a href="http://vulkan.gpuinfo.org">http://vulkan.gpuinfo.org</a> for information of various devices and platforms.</p>
<h1><a class="anchor" id="autotoc_md196"></a>
functions in nvvk</h1>
<p>getMemoryInfo : fills the VkMemoryAllocateInfo based on device's memory properties and memory requirements and property flags. Returns <code>true</code> on success. @DOC_END </p>

</div>
</div>
<a id="a935dc6826c929389cbf27025fcc23347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935dc6826c929389cbf27025fcc23347">&#9670;&nbsp;</a></span>makeAccessMaskPipelineStageFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nvvk::makeAccessMaskPipelineStageFlags </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>accessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineStageFlags&#160;</td>
          <td class="paramname"><em>supportedShaderBits</em> = <code>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT|VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT|VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT|VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT|VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT|VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md170"></a>
functions in nvvk</h1>
<ul>
<li>makeAccessMaskPipelineStageFlags : depending on accessMask returns appropriate VkPipelineStageFlagBits</li>
<li>cmdBegin : wraps vkBeginCommandBuffer with VkCommandBufferUsageFlags and implicitly handles VkCommandBufferBeginInfo setup</li>
<li>makeSubmitInfo : VkSubmitInfo struct setup using provided arrays of signals and commandbuffers, leaving rest zeroed @DOC_END </li>
</ul>

</div>
</div>
<a id="a15c6494c03a40255f03c8bc03c535aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c6494c03a40255f03c8bc03c535aab">&#9670;&nbsp;</a></span>makeImageMemoryBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkImageMemoryBarrier nvvk::makeImageMemoryBarrier </td>
          <td>(</td>
          <td class="paramtype">VkImage&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkAccessFlags&#160;</td>
          <td class="paramname"><em>srcAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkAccessFlags&#160;</td>
          <td class="paramname"><em>dstAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>oldLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout&#160;</td>
          <td class="paramname"><em>newLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageAspectFlags&#160;</td>
          <td class="paramname"><em>aspectMask</em> = <code>VK_IMAGE_ASPECT_COLOR_BIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md189"></a>
functions in nvvk</h1>
<ul>
<li>makeImageMemoryBarrier : returns VkImageMemoryBarrier for an image based on provided layouts and access flags.</li>
<li>mipLevels : return number of mips for 2d/3d extent</li>
<li>accessFlagsForImageLayout : helps resource transtions</li>
<li>pipelineStageForLayout : helps resource transitions</li>
<li>cmdBarrierImageLayout : inserts barrier for image transition</li>
<li>cmdGenerateMipmaps : basic mipmap creation for images (meant for one-shot operations)</li>
<li>makeImage2DCreateInfo : aids 2d image creation</li>
<li>makeImage3DCreateInfo : aids 3d descriptor set updating</li>
<li>makeImageCubeCreateInfo : aids cube descriptor set updating</li>
<li>makeImageViewCreateInfo : aids common image view creation, derives info from VkImageCreateInfo</li>
<li>makeImage2DViewCreateInfo : aids 2d image view creation @DOC_END </li>
</ul>

</div>
</div>
<a id="a97100510a4dbabdc8390996452197525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97100510a4dbabdc8390996452197525">&#9670;&nbsp;</a></span>nvprintPipelineStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nvvk::nvprintPipelineStats </td>
          <td>(</td>
          <td class="paramtype">VkDevice&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md197"></a>
functions in nvvk</h1>
<ul>
<li>nvprintPipelineStats : prints stats of the pipeline using VK_KHR_pipeline_executable_properties (don't forget to enable extension and set VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR)</li>
<li>dumpPipelineStats : dumps stats of the pipeline using VK_KHR_pipeline_executable_properties to a text file (don't forget to enable extension and set VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR)</li>
<li>dumpPipelineBinCodes : dumps shader binaries using VK_KHR_pipeline_executable_properties to multiple binary files (don't forget to enable extension and set VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR) @DOEC_END </li>
</ul>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a262f5eb0ae6944959d7935941ace49ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262f5eb0ae6944959d7935941ace49ae">&#9670;&nbsp;</a></span>DEFAULT_RING_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t nvvk::DEFAULT_RING_SIZE = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md173"></a>
class &lt;strong&gt;nvvk::Ring...&lt;/strong&gt;</h1>
<p>In real-time processing, the CPU typically generates commands in advance to the GPU and send them in batches for execution.</p>
<p>To avoid having the CPU to wait for the GPU'S completion and let it "race ahead" we make use of double, or tripple-buffering techniques, where we cycle through a pool of resources every frame. We know that those resources are currently not in use by the GPU and can therefore manipulate them directly.</p>
<p>Especially in Vulkan it is the developer's responsibility to avoid such access of resources that are in-flight.</p>
<p>The "Ring" classes cycle through a pool of resources. The default value is set to allow two frames in-flight, assuming one fence is used per-frame. @DOC_END </p>

</div>
</div>
<a id="a202ff7ad3faf12830b843588ff1bbc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202ff7ad3faf12830b843588ff1bbc69">&#9670;&nbsp;</a></span>s_frag_spv</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t nvvk::s_frag_spv[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0x07230203, 0x00010500, 0x0008000a, 0x00000012, 0x00000000, 0x00020011, 0x00000001, 0x0006000b, 0x00000001,</div>
<div class="line">    0x4c534c47, 0x6474732e, 0x3035342e, 0x00000000, 0x0003000e, 0x00000000, 0x00000001, 0x0007000f, 0x00000004,</div>
<div class="line">    0x00000004, 0x6e69616d, 0x00000000, 0x00000009, 0x0000000c, 0x00030010, 0x00000004, 0x00000007, 0x00030003,</div>
<div class="line">    0x00000002, 0x000001c2, 0x00040005, 0x00000004, 0x6e69616d, 0x00000000, 0x00040005, 0x00000009, 0x6c6f4366,</div>
<div class="line">    0x0000726f, 0x00050005, 0x0000000a, 0x65746e69, 0x6c6f7072, 0x00746e61, 0x00050006, 0x0000000a, 0x00000000,</div>
<div class="line">    0x6f6c6f43, 0x00000072, 0x00030005, 0x0000000c, 0x00006e49, 0x00040047, 0x00000009, 0x0000001e, 0x00000000,</div>
<div class="line">    0x00030047, 0x0000000a, 0x00000002, 0x00040047, 0x0000000c, 0x0000001e, 0x00000000, 0x00020013, 0x00000002,</div>
<div class="line">    0x00030021, 0x00000003, 0x00000002, 0x00030016, 0x00000006, 0x00000020, 0x00040017, 0x00000007, 0x00000006,</div>
<div class="line">    0x00000004, 0x00040020, 0x00000008, 0x00000003, 0x00000007, 0x0004003b, 0x00000008, 0x00000009, 0x00000003,</div>
<div class="line">    0x0003001e, 0x0000000a, 0x00000007, 0x00040020, 0x0000000b, 0x00000001, 0x0000000a, 0x0004003b, 0x0000000b,</div>
<div class="line">    0x0000000c, 0x00000001, 0x00040015, 0x0000000d, 0x00000020, 0x00000001, 0x0004002b, 0x0000000d, 0x0000000e,</div>
<div class="line">    0x00000000, 0x00040020, 0x0000000f, 0x00000001, 0x00000007, 0x00050036, 0x00000002, 0x00000004, 0x00000000,</div>
<div class="line">    0x00000003, 0x000200f8, 0x00000005, 0x00050041, 0x0000000f, 0x00000010, 0x0000000c, 0x0000000e, 0x0004003d,</div>
<div class="line">    0x00000007, 0x00000011, 0x00000010, 0x0003003e, 0x00000009, 0x00000011, 0x000100fd, 0x00010038}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvvk.html">nvvk</a></li>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:48 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
