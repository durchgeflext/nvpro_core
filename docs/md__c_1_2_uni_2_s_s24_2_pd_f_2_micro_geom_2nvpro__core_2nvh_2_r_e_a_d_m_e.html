<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nvpro_core<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_uni_2_s_s24_2_pd_f_2_micro_geom_2nvpro__core_2nvh_2_r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Table of Contents</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md102"></a></p><ul>
<li>alignment.hpp</li>
<li>appwindowcamerainertia.hpp</li>
<li>appwindowprofiler.hpp</li>
<li>bitarray.hpp</li>
<li>boundingbox.hpp</li>
<li>cameracontrol.hpp</li>
<li>camerainertia.hpp</li>
<li>cameramanipulator.hpp</li>
<li>commandlineparser.hpp</li>
<li>fileoperations.hpp</li>
<li>geometry.hpp</li>
<li>gltfscene.hpp</li>
<li>inputparser.h</li>
<li>misc.hpp</li>
<li>nvml_monitor.hpp</li>
<li>nvprint.hpp</li>
<li>parallel_work.hpp</li>
<li>parametertools.hpp</li>
<li>primitives.hpp</li>
<li>profiler.hpp</li>
<li>radixsort.hpp</li>
<li>shaderfilemanager.hpp</li>
<li>threading.hpp</li>
<li>timesampler.hpp</li>
<li>trangeallocator.hpp</li>
</ul>
<h1><a class="anchor" id="autotoc_md103"></a>
alignment.hpp</h1>
<p>Contains functions for aligning numbers to power-of-two boundaries. </p>
<h2><a class="anchor" id="autotoc_md104"></a>
Function <code>is_aligned&lt;integral&gt;(x, a)</code></h2>
<p>Returns whether <code>x</code> is a multiple of <code>a</code>. <code>a</code> must be a power of two. </p>
<h2><a class="anchor" id="autotoc_md105"></a>
Function <code>align_up&lt;integral&gt;(x, a)</code></h2>
<p>Rounds <code>x</code> up to a multiple of <code>a</code>. <code>a</code> must be a power of two. </p>
<h2><a class="anchor" id="autotoc_md106"></a>
Function <code>align_down&lt;integral&gt;(x, a)</code></h2>
<p>Rounds <code>x</code> down to a multiple of <code>a</code>. <code>a</code> must be a power of two.</p>
<h1><a class="anchor" id="autotoc_md107"></a>
appwindowcamerainertia.hpp</h1>
<h2><a class="anchor" id="autotoc_md108"></a>
class AppWindowCameraInertia</h2>
<blockquote class="doxtable">
<p>&zwj; <a class="el" href="class_app_window_camera_inertia.html">AppWindowCameraInertia</a> is a Window base for samples, adding a camera with inertia </p>
</blockquote>
<p>It derives the Window for this sample</p>
<h1><a class="anchor" id="autotoc_md109"></a>
appwindowprofiler.hpp</h1>
<h2><a class="anchor" id="autotoc_md110"></a>
class nvh::AppWindowProfiler</h2>
<p><a class="el" href="classnvh_1_1_app_window_profiler.html">nvh::AppWindowProfiler</a> provides an alternative utility wrapper class around <a class="el" href="class_n_v_p_window.html">NVPWindow</a>. It is useful to derive single-window applications from and is used by some but not all nvpro-samples.</p>
<p>Further functionality is provided :</p><ul>
<li>built-in profiler/timer reporting to console</li>
<li>command-line argument parsing as well as config file parsing using the ParameterTools see AppWindowProfiler::setupParameters() for built-in commands</li>
<li>benchmark/automation mode using ParameterTools</li>
<li>screenshot creation</li>
<li>logfile based on devicename (depends on context)</li>
<li>optional context/swapchain interface the derived classes nvvk/appwindowprofiler_vk and nvgl/appwindowprofiler_gl make use of this</li>
</ul>
<h1><a class="anchor" id="autotoc_md111"></a>
bitarray.hpp</h1>
<h2><a class="anchor" id="autotoc_md112"></a>
class nvh::BitArray</h2>
<blockquote class="doxtable">
<p>&zwj;The <a class="el" href="classnvh_1_1_bit_array.html">nvh::BitArray</a> class implements a tightly packed boolean array using single bits stored in uint64_t values. </p>
</blockquote>
<p>Whenever you want large boolean arrays this representation is preferred for cache-efficiency. The Visitor and OffsetVisitor traversal mechanisms make use of cpu intrinsics to speed up iteration over bits.</p>
<p>Example: </p><div class="fragment"><div class="line">BitArray modifiedObjects(1024);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set some bits</span></div>
<div class="line">modifiedObjects.setBit(24,<span class="keyword">true</span>);</div>
<div class="line">modifiedObjects.setBit(37,<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterate over all set bits using the built-in traversal mechanism</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyVisitor {</div>
<div class="line"><span class="keywordtype">void</span> operator()( <span class="keywordtype">size_t</span> index ){</div>
<div class="line">    <span class="comment">// called with the index of a set bit</span></div>
<div class="line">    myObjects[index].update();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyVisitor visitor;</div>
<div class="line">modifiedObjects.traverseBits(visitor);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md113"></a>
boundingbox.hpp</h1>
<div class="fragment"><div class="line">::Bbox</div>
</div><!-- fragment --><p> is a class to create bounding boxes. It grows by adding 3d vector, can combine other bound boxes. And it returns information, like its volume, its center, the min, max, etc..</p>
<h1><a class="anchor" id="autotoc_md114"></a>
cameracontrol.hpp</h1>
<h2><a class="anchor" id="autotoc_md115"></a>
class nvh::CameraControl</h2>
<blockquote class="doxtable">
<p>&zwj;<a class="el" href="classnvh_1_1_camera_control.html">nvh::CameraControl</a> is a utility class to create a viewmatrix based on mouse inputs. </p>
</blockquote>
<p>It can operate in perspective or orthographic mode (<code>m_sceneOrtho==true</code>).</p>
<p>perspective:</p><ul>
<li>LMB: rotate</li>
<li>RMB or WHEEL: zoom via dolly movement</li>
<li>MMB: pan/move within camera plane</li>
</ul>
<p>ortho:</p><ul>
<li>LMB: pan/move within camera plane</li>
<li>RMB or WHEEL: zoom via dolly movement, application needs to use <code>m_sceneOrthoZoom</code> for projection matrix adjustment</li>
<li>MMB: rotate</li>
</ul>
<p>The camera can be orbiting (<code>m_useOrbit==true</code>) around <code>m_sceneOrbit</code> or otherwise provide "first person/fly through"-like controls.</p>
<p>Speed of movement/rotation etc. is influenced by <code>m_sceneDimension</code> as well as the sensitivity values.</p>
<h1><a class="anchor" id="autotoc_md116"></a>
camerainertia.hpp</h1>
<h2><a class="anchor" id="autotoc_md117"></a>
struct InertiaCamera</h2>
<blockquote class="doxtable">
<p>&zwj; Struct that offers a camera moving with some inertia effect around a target point </p>
</blockquote>
<p><a class="el" href="struct_inertia_camera.html">InertiaCamera</a> exposes a mix of pseudo polar rotation around a target point and some other movements to translate the target point, zoom in and out.</p>
<p>Either the keyboard or mouse can be used for all of the moves.</p>
<h1><a class="anchor" id="autotoc_md118"></a>
cameramanipulator.hpp</h1>
<h2><a class="anchor" id="autotoc_md119"></a>
class nvh::CameraManipulator</h2>
<p>nvh::CameraManipulator is a camera manipulator help class It allow to simply do</p><ul>
<li>Orbit (LMB)</li>
<li>Pan (LMB + CTRL | MMB)</li>
<li>Dolly (LMB + SHIFT | RMB)</li>
<li>Look Around (LMB + ALT | LMB + CTRL + SHIFT)</li>
</ul>
<p>In a various ways:</p><ul>
<li>examiner(orbit around object)</li>
<li>walk (look up or down but stays on a plane)</li>
<li>fly ( go toward the interest point)</li>
</ul>
<p>Do use the camera manipulator, you need to do the following</p><ul>
<li>Call setWindowSize() at creation of the application and when the window size change</li>
<li>Call setLookat() at creation to initialize the camera look position</li>
<li>Call setMousePosition() on application mouse down</li>
<li>Call mouseMove() on application mouse move</li>
</ul>
<p>Retrieve the camera matrix by calling getMatrix()</p>
<p>See: appbase_vkpp.hpp</p>
<p>Note: There is a singleton <code>CameraManip</code> which can be use across the entire application</p>
<div class="fragment"><div class="line"><span class="comment">// Retrieve/set camera information</span></div>
<div class="line">CameraManip.getLookat(eye, center, up);</div>
<div class="line">CameraManip.setLookat(eye, center, glm::vec3(m_upVector == 0, m_upVector == 1, m_upVector == 2));</div>
<div class="line">CameraManip.getFov();</div>
<div class="line">CameraManip.setSpeed(navSpeed);</div>
<div class="line">CameraManip.setMode(navMode == 0 ? nvh::CameraManipulator::Examine : <a class="code hl_namespace" href="namespacenvh.html">nvh</a>::CameraManipulator::Fly);</div>
<div class="line"><span class="comment">// On mouse down, keep mouse coordinates</span></div>
<div class="line">CameraManip.setMousePosition(x, y);</div>
<div class="line"><span class="comment">// On mouse move and mouse button down</span></div>
<div class="line"><span class="keywordflow">if</span>(m_inputs.lmb || m_inputs.rmb || m_inputs.mmb)</div>
<div class="line">{</div>
<div class="line">CameraManip.mouseMove(x, y, m_inputs);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Wheel changes the FOV</span></div>
<div class="line">CameraManip.wheel(delta &gt; 0 ? 1 : -1, m_inputs);</div>
<div class="line"><span class="comment">// Retrieve the matrix to push to the shader</span></div>
<div class="line">m_ubo.view = CameraManip.getMatrix();</div>
<div class="line">````</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">## commandlineparser.hpp</span></div>
<div class="line">Command line parser.</div>
<div class="ttc" id="anamespacenvh_html"><div class="ttname"><a href="namespacenvh.html">nvh</a></div><div class="ttdoc">@DOC_SKIP (keyword to exclude this file from automatic README.md generation)</div><div class="ttdef"><b>Definition</b> alignment.hpp:31</div></div>
</div><!-- fragment --><p> cpp std::string inFilename = ""; bool printHelp = false; CommandLineParser args("Test Parser"); args.addArgument({"-f", "--filename"}, &amp;inFilename, "Input filename"); args.addArgument({"-h", "--help"}, &amp;printHelp, "Print Help"); bool result = args.parse(argc, argv); </p><div class="fragment"><div class="line">## fileoperations.hpp</div>
<div class="line">### functions in nvh</div>
<div class="line"> </div>
<div class="line">- nvh::fileExists : check if file exists</div>
<div class="line">- nvh::findFile : finds filename in provided search directories</div>
<div class="line">- nvh::loadFile : (multiple overloads) loads file as std::string, binary or text, can also search in provided directories</div>
<div class="line">- nvh::getFileName : splits filename from filename with path</div>
<div class="line">- nvh::getFilePath : splits filepath from filename with path</div>
<div class="line"> </div>
<div class="line">## geometry.hpp</div>
<div class="line">### namespace nvh::geometry</div>
<div class="line">The geometry namespace provides a few procedural mesh primitives</div>
<div class="line">that are subdivided.</div>
<div class="line"> </div>
<div class="line">nvh::geometry::Mesh template uses the provided TVertex which must have a</div>
<div class="line">constructor from nvh::geometry::Vertex. You can also use nvh::geometry::Vertex</div>
<div class="line">directly.</div>
<div class="line"> </div>
<div class="line">It provides triangle indices, as well as outline line indices. The outline indices</div>
<div class="line">are typical feature lines (rectangle for plane, some circles for sphere/torus).</div>
<div class="line"> </div>
<div class="line">All basic primitives are within -1,1 ranges along the axis they use</div>
<div class="line"> </div>
<div class="line">- nvh::geometry::Plane (x,y subdivision)</div>
<div class="line">- nvh::geometry::Box (x,y,z subdivision, made of 6 planes)</div>
<div class="line">- nvh::geometry::Sphere (lat,long subdivision)</div>
<div class="line">- nvh::geometry::Torus (inner, outer circle subdivision)</div>
<div class="line">- nvh::geometry::RandomMengerSponge (subdivision, tree depth, probability)</div>
<div class="line"> </div>
<div class="line">Example:</div>
</div><!-- fragment --><p> cpp // single primitive nvh::geometry::Box&lt;nvh::geometry::Vertex&gt; box(4,4,4);</p>
<p>// construct from primitives</p>
<div class="fragment"><div class="line">## gltfscene.hpp</div>
<div class="line"> </div>
<div class="line">### nvh::gltf::Scene</div>
<div class="line"> </div>
<div class="line">The Scene class is responsible for loading and managing a glTF scene.</div>
<div class="line">- It is used to load a glTF file and parse it into a scene representation.</div>
<div class="line">- It can be used to save the scene back to a glTF file.</div>
<div class="line">- It can be used to manage the animations of the scene.</div>
<div class="line">- What it returns is a list of RenderNodes, RenderPrimitives, RenderCameras, and RenderLights.</div>
<div class="line">-  RenderNodes are the instances of the primitives in the scene that will be rendered.</div>
<div class="line">-  RenderPrimitives are the unique primitives in the scene.</div>
<div class="line"> </div>
<div class="line">Note: The Scene class is a more advanced and light weight version of the GltfScene class.</div>
<div class="line">      But it is to the user to retrieve the primitive data from the RenderPrimitives.</div>
<div class="line">      Check the tinygltf_utils.hpp for more information on how to extract the primitive data.</div>
<div class="line"> </div>
<div class="line">### `nvh::GltfScene` **DEPRECATED**</div>
<div class="line"> </div>
<div class="line">  These utilities are for loading glTF models in a</div>
<div class="line">  canonical scene representation. From this representation</div>
<div class="line">  you would create the appropriate 3D API resources (buffers</div>
<div class="line">  and textures).</div>
</div><!-- fragment --><p> cpp // Typical Usage // Load the GLTF Scene using TinyGLTF</p>
<p>tinygltf::Model gltfModel; tinygltf::TinyGLTF gltfContext; fileLoaded = gltfContext.LoadASCIIFromFile(&amp;gltfModel, &amp;error, &amp;warn, m_filename);</p>
<p>// Fill the data in the gltfScene gltfScene.getMaterials(tmodel); gltfScene.getDrawableNodes(tmodel, GltfAttributes::Normal | GltfAttributes::Texcoord_0);</p>
<p>// Todo in App: // create buffers for vertices and indices, from gltfScene.m_position, gltfScene.m_index // create textures from images: using tinygltf directly // create descriptorSet for material using directly gltfScene.m_materials </p><div class="fragment"><div class="line">## inputparser.h</div>
<div class="line">### class InputParser</div>
<div class="line">&gt; InputParser is a Simple command line parser</div>
<div class="line"> </div>
<div class="line">Example of usage for: test.exe -f name.txt -size 200 100</div>
<div class="line"> </div>
<div class="line">Parsing the command line: mandatory &#39;-f&#39; for the filename of the scene</div>
</div><!-- fragment --><p> cpp nvh::InputParser parser(argc, argv); std::string filename = parser.getString("-f"); if(filename.empty()) filename = "default.txt"; if(parser.exist("-size") { auto values = parser.getInt2("-size"); </p><div class="fragment"><div class="line">## misc.hpp</div>
<div class="line">### functions in nvh</div>
<div class="line"> </div>
<div class="line">- mipMapLevels : compute number of mip maps</div>
<div class="line">- stringFormat : sprintf for std::string</div>
<div class="line">- frand : random float using rand()</div>
<div class="line">- permutation : fills uint vector with random permutation of values [0... vec.size-1]</div>
<div class="line"> </div>
<div class="line">## nvml_monitor.hpp</div>
<div class="line"> </div>
<div class="line">Capture the GPU load and memory for all GPUs on the system.</div>
<div class="line"> </div>
<div class="line">Usage:</div>
<div class="line">- There should be only one instance of NvmlMonitor</div>
<div class="line">- call refresh() in each frame. It will not pull more measurement that the interval(ms)</div>
<div class="line">- isValid() : return if it can be used</div>
<div class="line">- nbGpu()   : return the number of GPU in the computer</div>
<div class="line">- getGpuInfo()     : static info about the GPU</div>
<div class="line">- getDeviceMemory() : memory consumption info</div>
<div class="line">- getDeviceUtilization() : GPU and memory utilization</div>
<div class="line">- getDevicePerformanceState() : clock speeds and throttle reasons</div>
<div class="line">- getDevicePowerState() : power, temperature and fan speed</div>
<div class="line"> </div>
<div class="line">Measurements:</div>
<div class="line">- Uses a cycle buffer.</div>
<div class="line">- Offset is the last measurement</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## nvprint.hpp</div>
<div class="line">Multiple functions and macros that should be used for logging purposes,</div>
<div class="line">rather than `printf`. These can print to multiple places at once, produce</div>
<div class="line">breakpoints on certain types of messages, and more.</div>
<div class="line"> </div>
<div class="line">### Function `nvprintf` etc.</div>
<div class="line"> </div>
<div class="line">Configuration:</div>
<div class="line">- `nvprintSetLevel` : sets default loglevel</div>
<div class="line">- `nvprintGetLevel` : gets default loglevel</div>
<div class="line">- `nvprintSetLogFileName` : sets log filename</div>
<div class="line">- `nvprintSetLogging` : sets file logging state</div>
<div class="line">- `nvprintSetCallback` : sets custom callback</div>
<div class="line"> </div>
<div class="line">### Printf-style functions and macros.</div>
<div class="line">These take `printf`-style specifiers.</div>
<div class="line">- `nvprintf` : prints at default loglevel</div>
<div class="line">- `nvprintfLevel` : `nvprintfLevel` print at a certain loglevel</div>
<div class="line">- `LOGI` : macro that does `nvprintfLevel(LOGLEVEL_INFO)`</div>
<div class="line">- `LOGW` : macro that does `nvprintfLevel(LOGLEVEL_WARNING)`</div>
<div class="line">- `LOGE` : macro that does `nvprintfLevel(LOGLEVEL_ERROR)`</div>
<div class="line">- `LOGE_FILELINE` : macro that does `nvprintfLevel(LOGLEVEL_ERROR)` combined with filename/line</div>
<div class="line">- `LOGD` : macro that does `nvprintfLevel(LOGLEVEL_DEBUG)` (only in debug builds)</div>
<div class="line">- `LOGOK` : macro that does `nvprintfLevel(LOGLEVEL_OK)`</div>
<div class="line">- `LOGSTATS` : macro that does `nvprintfLevel(LOGLEVEL_STATS)`</div>
<div class="line"> </div>
<div class="line">### `std::print`-style functions and macros.</div>
<div class="line">These take [`std::format`-style specifiers](https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification).</div>
<div class="line">- `nvprintLevel` : print at a certain loglevel</div>
<div class="line">- `PRINTI` : macro that does `nvprintLevel(LOGLEVEL_INFO)`</div>
<div class="line">- `PRINTW` : macro that does `nvprintLevel(LOGLEVEL_WARNING)`</div>
<div class="line">- `PRINTE` : macro that does `nvprintLevel(LOGLEVEL_ERROR)`</div>
<div class="line">- `PRINTE_FILELINE` : macro that does `nvprintLevel(LOGLEVEL_ERROR)` combined with filename/line</div>
<div class="line">- `PRINTD` : macro that does `nvprintLevel(LOGLEVEL_DEBUG)` (only in debug builds)</div>
<div class="line">- `PRINTOK` : macro that does `nvprintLevel(LOGLEVEL_OK)`</div>
<div class="line">- `PRINTSTATS` : macro that does `nvprintLevel(LOGLEVEL_STATS)`</div>
<div class="line"> </div>
<div class="line">### Safety:</div>
<div class="line">On error, all functions print an error message.</div>
<div class="line"> </div>
<div class="line">All functions are thread-safe.</div>
<div class="line"> </div>
<div class="line">`Printf`-style functions have annotations that should produce warnings at</div>
<div class="line">compile-time or when performing static analysis. Their format strings may be</div>
<div class="line">dynamic - but this can be bad if an adversary can choose the content of the</div>
<div class="line">format string.</div>
<div class="line"> </div>
<div class="line">`std::print`-style functions are safer: they produce compile-time errors, and</div>
<div class="line">their format strings must be compile-time constants. Dynamic formatting</div>
<div class="line">should be performed outside of printing, like this:</div>
</div><!-- fragment --><p> cpp ImGui::InputText("Enter a format string: ", userFormat, sizeof(userFormat)); try { std::string formatted = fmt::vformat(userFormat, ...); } catch (const std::exception&amp; e) { (error handling...) } PRINTI("{}", formatted); </p><div class="fragment"><div class="line">### Text encoding:</div>
<div class="line">Printing to the Windows debug console is the only operation that assumes a</div>
<div class="line">text encoding; the input is assumed to be UTF-8. In all other cases, strings</div>
<div class="line">are copied into the output.</div>
<div class="line"> </div>
<div class="line">## parallel_work.hpp</div>
<div class="line">Distributes batches of loops over BATCHSIZE items across multiple threads. numItems reflects the total number</div>
<div class="line">of items to process.</div>
<div class="line"> </div>
<div class="line">batches: fn (uint64_t itemIndex, uint32_t threadIndex)</div>
<div class="line">         callback does single item</div>
<div class="line">ranges:  fn (uint64_t itemBegin, uint64_t itemEnd, uint32_t threadIndex)</div>
<div class="line">         callback does loop `for (uint64_t itemIndex = itemBegin; itemIndex &lt; itemEnd; itemIndex++)`</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## parametertools.hpp</div>
<div class="line">### class nvh::ParameterList</div>
<div class="line"> </div>
<div class="line">The nvh::ParameterList helps parsing commandline arguments</div>
<div class="line">or commandline arguments stored within ascii config files.</div>
<div class="line"> </div>
<div class="line">Parameters always update the values they point to, and optionally</div>
<div class="line">can trigger a callback that can be provided per-parameter.</div>
</div><!-- fragment --><p> cpp ParameterList list; std::string modelFilename; float modelScale;</p>
<p>list.addFilename(".gltf|model filename", &amp;modelFilename); list.add("scale|model scale", &amp;modelScale);</p>
<p>list.applyTokens(3, {"blah.gltf","-scale","4"}, "-", "/assets/"); </p><div class="fragment"><div class="line">Use in combination with the ParameterSequence class to iterate</div>
<div class="line">sequences of parameter changes for benchmarking/automation.</div>
<div class="line">### class nvh::ParameterSequence</div>
<div class="line"> </div>
<div class="line">The nvh::ParameterSequence processes provided tokens in sequences.</div>
<div class="line">The sequences are terminated by a special &quot;separator&quot; token.</div>
<div class="line">All tokens between the last iteration and the separator are applied</div>
<div class="line">to the provided ParameterList.</div>
<div class="line">Useful to process commands in sequences (automation, benchmarking etc.).</div>
<div class="line"> </div>
<div class="line">Example:</div>
</div><!-- fragment --><p> cpp ParameterSequence sequence; ParameterList list; int mode; list.add("mode", &amp;mode);</p>
<p>std::vector&lt;const char*&gt; tokens; ParameterList::tokenizeString("benchmark simple -mode 10 benchmark complex -mode 20", tokens); sequence.init(&amp;list, tokens);</p>
<p>// 1 means our separator is followed by one argument (simple/complex) // "-" as parameters in the string are prefixed with -</p>
<p>while(!sequence.advanceIteration("benchmark", 1, "-")) { printf("%d %s mode %d\n", sequence.getIteration(), sequence.getSeparatorArg(0), mode); }</p>
<p>// would print: // 0 simple mode 10 // 1 complex mode 20 </p><div class="fragment"><div class="line">## primitives.hpp</div>
<div class="line">### struct `nvh::PrimitiveMesh`</div>
<div class="line">  - Common primitive type, made of vertices: position, normal and texture coordinates.</div>
<div class="line">  - All primitives are triangles, and each 3 indices is forming a triangle.</div>
<div class="line"> </div>
<div class="line">### struct `nvh::Node`</div>
<div class="line">  - Structure to hold a reference to a mesh, with a material and transformation.</div>
<div class="line"> </div>
<div class="line">Primitives that can be created:</div>
<div class="line">* Tetrahedron</div>
<div class="line">* Icosahedron</div>
<div class="line">* Octahedron</div>
<div class="line">* Plane</div>
<div class="line">* Cube</div>
<div class="line">* SphereUv</div>
<div class="line">* Cone</div>
<div class="line">* SphereMesh</div>
<div class="line">* Torus</div>
<div class="line"> </div>
<div class="line">Node creator: returns the instance and the position</div>
<div class="line">* MengerSponge</div>
<div class="line">* SunFlower</div>
<div class="line"> </div>
<div class="line">Other utilities</div>
<div class="line">* mergeNodes</div>
<div class="line">* removeDuplicateVertices</div>
<div class="line">* wobblePrimitive</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## profiler.hpp</div>
<div class="line">### class nvh::Profiler</div>
<div class="line"> </div>
<div class="line">&gt; The nvh::Profiler class is designed to measure timed sections.</div>
<div class="line"> </div>
<div class="line">Each section has a cpu and gpu time. Gpu times are typically provided</div>
<div class="line">by derived classes for each individual api (e.g. OpenGL, Vulkan etc.).</div>
<div class="line"> </div>
<div class="line">There is functionality to pretty print the sections with their nesting level.</div>
<div class="line">Multiple profilers can reference the same database, so one profiler</div>
<div class="line">can serve as master that they others contribute to. Typically the</div>
<div class="line">base class measuring only CPU time could be the master, and the api</div>
<div class="line">derived classes reference it to share the same database.</div>
<div class="line"> </div>
<div class="line">Profiler::Clock can be used standalone for time measuring.</div>
<div class="line"> </div>
<div class="line">## radixsort.hpp</div>
<div class="line">### function nvh::radixsort</div>
<div class="line"> </div>
<div class="line">The radixsort function sorts the provided keys based on</div>
<div class="line">BYTES many bytes stored inside TKey starting at BYTEOFFSET.</div>
<div class="line">The sorting result is returned as indices into the keys array.</div>
<div class="line"> </div>
<div class="line">For example:</div>
</div><!-- fragment --><p> cpp struct MyData { uint32_t objectIdentifier; uint16_t objectSortKey; };</p>
<p>// 4-byte offset of objectSortKey within MyData // 2-byte size of sorting key</p>
<p>result = radixsort&lt;4,2&gt;(keys, indicesIn, indicesTemp);</p>
<p>// after sorting the following is true</p>
<p>keys[result[i]].objectSortKey &lt; keys[result[i + 1]].objectSortKey</p>
<p>// result can point either to indicesIn or indicesTemp (we swap the arrays // after each byte iteration) </p><div class="fragment"><div class="line">## shaderfilemanager.hpp</div>
<div class="line">### class nvh::ShaderFileManager</div>
<div class="line"> </div>
<div class="line">The nvh::ShaderFileManager class is meant to be derived from to create the actual api-specific</div>
<div class="line">shader/program managers.</div>
<div class="line"> </div>
<div class="line">The ShaderFileManager provides a system to find/load shader files.</div>
<div class="line">It also allows resolving #include instructions in HLSL/GLSL source files.</div>
<div class="line">Such includes can be registered before pointing to strings in memory.</div>
<div class="line"> </div>
<div class="line">If m_handleIncludePasting is true, then `#include`s are replaced by</div>
<div class="line">the include file contents (recursively) before presenting the</div>
<div class="line">loaded shader source code to the caller. Otherwise, the include file</div>
<div class="line">loader is still available but `#include`s are left unchanged.</div>
<div class="line"> </div>
<div class="line">Furthermore it handles injecting prepended strings (typically used</div>
<div class="line">for #defines) after the #version statement of GLSL files,</div>
<div class="line">regardless of m_handleIncludePasting&#39;s value.</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## threading.hpp</div>
<div class="line">### class nvh::delayed_call</div>
<div class="line">Class returned by delay_noreturn_for to track the thread created and possibly reset the</div>
<div class="line">delay timer.</div>
<div class="line"> Delay a call to a void function for sleep_duration.</div>
<div class="line"> </div>
<div class="line"> `return`: A delayed_call object that holds the running thread.</div>
<div class="line"> </div>
<div class="line">Example:</div>
</div><!-- fragment --><p> cpp // Create or update a delayed call to callback. Useful to consolidate multiple events into one call. if(!m_delayedCall.delay_for(delay)) m_delayedCall = nvh::delay_noreturn_for(delay, callback); </p><div class="fragment"><div class="line">## timesampler.hpp</div>
<div class="line">### struct TimeSampler</div>
<div class="line">TimeSampler does time sampling work</div>
<div class="line">### struct nvh::Stopwatch</div>
<div class="line">&gt; Timer in milliseconds.</div>
<div class="line"> </div>
<div class="line">Starts the timer at creation and the elapsed time is retrieved by calling `elapsed()`.</div>
<div class="line">The timer can be reset if it needs to start timing later in the code execution.</div>
<div class="line"> </div>
<div class="line">Usage:</div>
<div class="line">````cpp</div>
<div class="line">{</div>
<div class="line">  nvh::Stopwatch sw;</div>
<div class="line">  ... work ...</div>
<div class="line">  LOGI(&quot;Elapsed: %f ms\n&quot;, sw.elapsed()); // --&gt; Elapsed: 128.157 ms</div>
<div class="line">}</div>
<div class="line">````</div>
<div class="line"> </div>
<div class="line">## trangeallocator.hpp</div>
<div class="line">### class nvh::TRangeAllocator</div>
<div class="line"> </div>
<div class="line">The nvh::TRangeAllocator&lt;GRANULARITY&gt; template allows to sub-allocate ranges from a fixed</div>
<div class="line">maximum size. Ranges are allocated at GRANULARITY and are merged back on freeing.</div>
<div class="line">Its primary use is within allocators that sub-allocate from fixed-size blocks.</div>
<div class="line"> </div>
<div class="line">The implementation is based on [MakeID by Emil Persson](http://www.humus.name/3D/MakeID.h).</div>
<div class="line"> </div>
<div class="line">Example :</div>
</div><!-- fragment --><p> cpp <a class="el" href="classnvh_1_1_t_range_allocator.html">TRangeAllocator&lt;256&gt;</a> range;</p>
<p>// initialize to a certain range range.init(range.alignedSize(128 * 1024 * 1024));</p>
<p>...</p>
<p>// allocate a sub range // example uint32_t size = vertexBufferSize; uint32_t alignment = vertexAlignment;</p>
<p>uint32_t allocOffset; uint32_t allocSize; uint32_t alignedOffset;</p>
<p>if (range.subAllocate(size, alignment, allocOffset, alignedOffset, allocSize)) { ... use the allocation space // [alignedOffset + size] is guaranteed to be within [allocOffset + allocSize] }</p>
<p>// give back the memory range for re-use range.subFree(allocOffset, allocSize);</p>
<p>...</p>
<p>// at the end cleanup range.deinit(); ``` </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 3 2025 15:08:46 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
