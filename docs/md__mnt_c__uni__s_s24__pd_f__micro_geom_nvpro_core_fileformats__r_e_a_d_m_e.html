<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__mnt_c__uni__s_s24__pd_f__micro_geom_nvpro_core_fileformats__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Table of Contents </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#khr_dfh">khr_df.h</a></li>
<li><a href="#nv_ddsh">nv_dds.h</a></li>
<li><a href="#nv_ktxh">nv_ktx.h</a></li>
<li><a href="#texture_formatsh">texture_formats.h</a></li>
<li><a href="#tinygltf_utilshpp">tinygltf_utils.hpp</a></li>
<li><a href="#tiny_converterhpp">tiny_converter.hpp</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
khr_df.h</h1>
<blockquote class="doxtable">
<p>The Khronos Data Format header, from <a href="https://registry.khronos.org/DataFormat/">https://registry.khronos.org/DataFormat/</a>. </p>
</blockquote>
<p>This header defines a structure that can describe the layout of image formats in memory. This means that the data format is transparent to the application, and the expectation is that this should be used when the layout is defined external to the API. Many Khronos APIs deliberately keep the internal layout of images opaque, to allow proprietary layouts and optimisations. This structure is not appropriate for describing opaque layouts.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
nv_dds.h</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
nv_dds 2.1.1</h2>
<blockquote class="doxtable">
<p>A small yet complete library for reading and writing DDS files. </p>
</blockquote>
<p>Other than the C++ standard library, nv_dds only requires five files: dxgiformat.h, nv_dds.h, nv_dds.cpp, texture_formats.h, and texture_formats.cpp.</p>
<p>To load a DDS file, use <code>Image::readFromFile()</code>:</p>
<div class="fragment"><div class="line">nv_dds::Image image;</div>
<div class="line">nv_dds::ErrorWithText maybeError = image.readFromFile(<span class="stringliteral">&quot;data/image.dds&quot;</span>, {});</div>
<div class="line"><span class="keywordflow">if</span>(maybeError.has_value())</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Do something with the error message, maybeError.value()</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Access subresources using image.subresource(...), and upload them</span></div>
<div class="line">  <span class="comment">// to the GPU using your graphics API of choice.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><code>Image</code>'s format field is a DXGI format. If you need to use this data with another API, you can use the functions in texture_formats.h to look up the corresponding API format.</p>
<p>To write a DDS file, use <code>Image::writeToFile()</code>:</p>
<div class="fragment"><div class="line">nv_dds::ErrorWithText maybe_error = image.writeToFile(<span class="stringliteral">&quot;output.dds&quot;</span>, {});</div>
<div class="line"><span class="keywordflow">if</span>(maybe_error.has_value())</div>
<div class="line">{</div>
<div class="line">  LOGE(<span class="stringliteral">&quot;Failed to write to output.dds! The DDS writer reported: %s\n&quot;</span>,</div>
<div class="line">       maybe_error.value().c_str());</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>Image</code> also provides functions to read and write streams. Each of these read and write functions supports various settings; see <code>ReadSettings</code> and <code>WriteSettings</code>.</p>
<p>Images can also be created from raw data: </p><div class="fragment"><div class="line">nv_dds::Image image;</div>
<div class="line">image.allocate(1,  <span class="comment">// _numMips</span></div>
<div class="line">               1,  <span class="comment">// _numLayers</span></div>
<div class="line">               1); <span class="comment">// _numFaces</span></div>
<div class="line">image.subresource(0, 0, 0) <span class="comment">// mip, layer, face</span></div>
<div class="line">  .create(512, 512, 1, subresource_data); <span class="comment">// width, height, depth, data</span></div>
<div class="line">  = nv_dds::Subresource(512, 512, 1, subresource_data); <span class="comment">// width, height, depth, data</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
Limitations</h3>
<p>Not currently supported:</p><ul>
<li>Multi-plane YUV textures with chroma subsampling (e.g. <code>DXGI_FORMAT_R8G8_B8G8_UNORM</code>)</li>
<li>Paletted textures</li>
<li>DirectDraw Surface versions before DX9</li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
Changes from nv_dds 1.0</h3>
<p>nv_dds adds support for many more formats, fixes many issues, and now aims to be secure against untrusted input, so it's worth updating. However, the API has almost entirely changed, and now looks much more like nv_ktx's API:</p>
<ul>
<li><code>CSurface</code> is now <code>nv_dds::Subresource</code></li>
<li><code>CDDSImage</code> is now <code>nv_dds::Image</code></li>
<li><code>CTexture</code> (representing a mip chain) has been moved to part of <code>Image</code>.</li>
<li>Images can no longer be flipped. It turns out the code for this only worked for mips whose height was a multiple of the block size; in all other cases, flipping a block-compressed image across the y axis requires decompressing and recompressing it, which is outside the scope of nv_dds. (We recommend flipping your sampling y axis instead; if flipping compressed image data is absolutely necessary, consider using a library such as NVTT.)</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
nv_ktx.h</h1>
<blockquote class="doxtable">
<p>A mostly self-contained reader and writer for KTX2 files and reader for KTX1 files. </p>
</blockquote>
<p>Relies on Vulkan (for KTX2), GL (for KTX1), and the Khronos Data Format.</p>
<p>Sample usage for reading files:</p>
<div class="fragment"><div class="line">KTXImage     image;</div>
<div class="line">ErrorWithText maybe_error = image.readFromFile(<span class="stringliteral">&quot;data/image.ktx2&quot;</span>, {});</div>
<div class="line"><span class="keywordflow">if</span>(maybe_error.has_value())</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Do something with the error message, maybe_error.value()</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Access subresources using image.subresource(...), and upload them</span></div>
<div class="line">  <span class="comment">// to the GPU using your graphics API of choice.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Define <code>NVP_SUPPORTS_ZSTD</code>, <code>NVP_SUPPORTS_GZLIB</code>, and <code>NVP_SUPPORTS_BASISU</code> to include the Zstd, Zlib, and Basis Universal headers respectively, and to enable reading these formats. This will also enable writing Zstd and Basis Universal-compressed formats. If you're using this inside the nvpro-samples framework, you can add all three quickly by adding <code>_add_package_KTX()</code> to your dependencies in CMakeLists.txt.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
texture_formats.h</h1>
<p>Provides:</p><ul>
<li>Methods for translating texture format names between DirectX, Vulkan, and OpenGL.</li>
<li>A method for getting the size of a Vulkan subresource using linear tiling.</li>
<li>The extended ASTC values for DXGI_FORMAT.</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
tinygltf_utils.hpp</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
namespace &lt;tt&gt;tinygltf::utils&lt;/tt&gt;</h2>
<blockquote class="doxtable">
<p>Utility functions for extracting structs from tinygltf's representation of glTF. </p>
</blockquote>
<p>#### Function <code>getValue&lt;T&gt;</code> </p><blockquote class="doxtable">
<p>Gets the value of type T for the attribute <code>name</code>. </p>
</blockquote>
<p>This function retrieves the value of the specified attribute from a tinygltf::Value and stores it in the provided result variable.</p>
<p>Parameters:</p><ul>
<li>value: The <code>tinygltf::Value</code> from which to retrieve the attribute.</li>
<li>name: The name of the attribute to retrieve.</li>
<li>result: The variable to store the retrieved value in. </li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Function &lt;tt&gt;getValue(..., float&amp; result)&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Specialization of <code>getValue()</code> for float type. </p>
</blockquote>
<p>Retrieves the value of the specified attribute as a float and stores it in the result variable. </p>
<h3><a class="anchor" id="autotoc_md11"></a>
Function &lt;tt&gt;getValue(..., tinygltf::TextureInfo&amp; result)&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Specialization of <code>getValue()</code> for <code>nvvkhl::Gltf::Texture</code> type. </p>
</blockquote>
<p>Retrieves the texture attribute values and stores them in the result variable. </p>
<h3><a class="anchor" id="autotoc_md12"></a>
Function &lt;tt&gt;setValue&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Sets attribute <code>key</code> to value <code>val</code>. </p>
</blockquote>
<p>#### Function <code>setValue(... tinygltf::TextureInfo)</code> </p><blockquote class="doxtable">
<p>Sets attribute <code>key</code> to a JSON object with an <code>index</code> and <code>texCoord</code> set from the members of <code>textureInfo</code>. </p>
</blockquote>
<p>#### Function <code>getArrayValue&lt;T&gt;</code> </p><blockquote class="doxtable">
<p>Gets the value of type T for the attribute <code>name</code>. </p>
</blockquote>
<p>This function retrieves the array value of the specified attribute from a <code>tinygltf::Value</code> and stores it in the provided result variable. It is used for types such as <code>glm::vec3</code>, <code>glm::vec4</code>, <code>glm::mat4</code>, etc.</p>
<p>Parameters:</p><ul>
<li>value: The <code>tinygltf::Value</code> from which to retrieve the attribute.</li>
<li>name: The name of the attribute to retrieve.</li>
<li>result: The variable to store the retrieved array value in. </li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
Function &lt;tt&gt;setArrayValue&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Sets attribute <code>name</code> of the given <code>value</code> to an array with the first <code>numElements</code> elements from the <code>array</code> pointer. </p>
</blockquote>
<p>#### Function <code>convertToTinygltfValue</code> </p><blockquote class="doxtable">
<p>Converts a vector of elements to a <code>tinygltf::Value</code>. </p>
</blockquote>
<p>This function converts a given array of float elements into a <code>tinygltf::Value::Array</code>, suitable for use within the tinygltf library.</p>
<p>Parameters:</p><ul>
<li>numElements: The number of elements in the array.</li>
<li>elements: A pointer to the array of float elements.</li>
</ul>
<p>Returns:</p><ul>
<li>A <code>tinygltf::Value</code> representing the array of elements. </li>
</ul>
<h3><a class="anchor" id="autotoc_md14"></a>
Function &lt;tt&gt;getNodeTRS&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Retrieves the translation, rotation, and scale of a GLTF node. </p>
</blockquote>
<p>This function extracts the translation, rotation, and scale (TRS) properties from the given GLTF node. If the node has a matrix defined, it decomposes the matrix to obtain these properties. Otherwise, it directly retrieves the TRS values from the node's properties.</p>
<p>Parameters:</p><ul>
<li>node: The GLTF node from which to extract the TRS properties.</li>
<li>translation: Output parameter for the translation vector.</li>
<li>rotation: Output parameter for the rotation quaternion.</li>
<li>scale: Output parameter for the scale vector.</li>
<li>## Function <code>setNodeTRS</code> <blockquote class="doxtable">
<p>Sets the translation, rotation, and scale of a GLTF node. </p>
</blockquote>
This function sets the translation, rotation, and scale (TRS) properties of the given GLTF node using the provided values.</li>
</ul>
<p>Parameters:</p><ul>
<li>node: The GLTF node to modify.</li>
<li>translation: The translation vector to set.</li>
<li>rotation: The rotation quaternion to set.</li>
<li>scale: The scale vector to set.</li>
<li>## Function <code>getNodeMatrix</code> <blockquote class="doxtable">
<p>Retrieves the transformation matrix of a GLTF node. </p>
</blockquote>
This function computes the transformation matrix for the given GLTF node. If the node has a direct matrix defined, it returns that matrix as defined in the specification. Otherwise, it computes the matrix from the node's translation, rotation, and scale (TRS) properties.</li>
</ul>
<p>Parameters:</p><ul>
<li>node: The GLTF node for which to retrieve the transformation matrix.</li>
</ul>
<p>Returns:</p><ul>
<li>The transformation matrix of the node. </li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
Function &lt;tt&gt;generatePrimitiveKey&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Generates a unique key for a GLTF primitive based on its attributes. </p>
</blockquote>
<p>This function creates a unique string key for the given GLTF primitive by concatenating its attribute keys and values. This is useful for caching the primitive data, thereby avoiding redundancy.</p>
<p>Parameters:</p><ul>
<li>primitive: The GLTF primitive for which to generate the key.</li>
</ul>
<p>Returns:</p><ul>
<li>A unique string key representing the primitive's attributes. </li>
</ul>
<h3><a class="anchor" id="autotoc_md16"></a>
Function &lt;tt&gt;traverseSceneGraph&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Traverses the scene graph and calls the provided functions for each element. </p>
</blockquote>
<p>This utility function recursively traverses the scene graph starting from the specified node ID. It calls the provided functions for cameras, lights, and meshes when encountered. The traversal can be stopped early if any function returns <code>true</code>.</p>
<p>Parameters:</p><ul>
<li>model: The GLTF model containing the scene graph.</li>
<li>nodeID: The ID of the node to start traversal from.</li>
<li>parentMat: The transformation matrix of the parent node.</li>
<li>fctCam: Function to call when a camera is encountered. Can be <code>nullptr</code>.</li>
<li>fctLight: Function to call when a light is encountered. Can be <code>nullptr</code>.</li>
<li>fctMesh: Function to call when a mesh is encountered. Can be <code>nullptr</code>. </li>
</ul>
<h3><a class="anchor" id="autotoc_md17"></a>
Function &lt;tt&gt;getVertexCount&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Returns the number of vertices in a primitive. </p>
</blockquote>
<p>This function retrieves the number of vertices for the given GLTF primitive by accessing the "POSITION" attribute in the model's accessors.</p>
<p>Parameters:</p><ul>
<li>model: The GLTF model containing the primitive data.</li>
<li>primitive: The GLTF primitive for which to retrieve the vertex count.</li>
</ul>
<p>Returns:</p><ul>
<li>The number of vertices in the primitive. </li>
</ul>
<h3><a class="anchor" id="autotoc_md18"></a>
Function &lt;tt&gt;getIndexCount&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Returns the number of indices in a primitive. </p>
</blockquote>
<p>This function retrieves the number of indices for the given GLTF primitive by accessing the indices in the model's accessors. If no indices are present, it returns the number of vertices instead.</p>
<p>Parameters:</p><ul>
<li>model: The GLTF model containing the primitive data.</li>
<li>primitive: The GLTF primitive for which to retrieve the index count.</li>
</ul>
<p>Returns:</p><ul>
<li>The number of indices in the primitive, or the number of vertices if no indices are present. </li>
</ul>
<h3><a class="anchor" id="autotoc_md19"></a>
Function &lt;tt&gt;hasElementName&lt;MapType&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Check if the map has the specified element. </p>
</blockquote>
<p>Can be used for extensions, extras, or any other map. Returns <code>true</code> if the map has the specified element, <code>false</code> otherwise. </p>
<h3><a class="anchor" id="autotoc_md20"></a>
Function &lt;tt&gt;getElementValue&lt;MapType&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Get the value of the specified element from the map. </p>
</blockquote>
<p>Can be <code>extensions</code>, <code>extras</code>, or any other map. Returns the value of the element. </p>
<h3><a class="anchor" id="autotoc_md21"></a>
Function &lt;tt&gt;getBufferDataSpan&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Retrieves the buffer data for the specified accessor from the GLTF model and returns it as a span of type <code>T</code>. </p>
</blockquote>
<p>The function assumes that the buffer data is of type <code>T</code>. It also performs assertions to ensure that the accessor and buffer data are compatible; these will be ignored if assertions are off.</p>
<p>Example usage:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> accessorIndex = primitive.attributes.at(<span class="stringliteral">&quot;POSITION&quot;</span>);</div>
<div class="line">std::span&lt;const glm::vec3&gt; positions = tinygltf::utils::getBufferDataSpan&lt;glm::vec3&gt;(model, accessorIndex);</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md22"></a>
Function &lt;tt&gt;forEachSparseValue&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Calls a function (such as a lambda function) for each <code>(index, value)</code> pair in a sparse accessor. </p>
</blockquote>
<p>It's only potentially called for indices from <code>accessorFirstElement</code> through <code>accessorFirstElement + numElementsToProcess - 1</code>. </p>
<h3><a class="anchor" id="autotoc_md23"></a>
Function &lt;tt&gt;copyAccessorData&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Copies accessor elements <code>accessorFirstElement</code> through <code>accessorFirstElement + numElementsToCopy - 1</code> to <code>outData</code> elements <code>outFirstElement</code> through <code>outFirstElement + numElementsToCopy - 1</code>. </p>
</blockquote>
<p>This handles sparse accessors correctly! It's intended as a replacement for what would be <code>memcpy(..., &amp;buffer.data[...], ...)</code> calls.</p>
<p>However, it performs no conversion: it assumes (but does not check) that accessor's elements are of type <code>T</code>. For instance, <code>T</code> should be a struct of two floats for a <code>VEC2</code> float accessor.</p>
<p>This is range-checked, so elements that would be out-of-bounds are not copied. We assume <code>size_t</code> overflow does not occur.</p>
<p>Note that <code>outDataSizeInT</code> is the number of elements in the <code>outDataBuffer</code>, while <code>numElementsToCopy</code> is the number of elements to copy, not the number of elements in <code>accessor</code>. </p>
<h3><a class="anchor" id="autotoc_md24"></a>
Function &lt;tt&gt;copyAccessorData&lt;T&gt;(std::vector&lt;T&gt;&amp; outData, ...)&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Same as <code>copyAccessorData(T*, ...)</code>, but taking a vector. </p>
</blockquote>
<p>#### Function <code>getAccessorData&lt;T&gt;</code> </p><blockquote class="doxtable">
<p>Appends all the values of <code>accessor</code> to <code>attribVec</code>, with conversion to type <code>T</code>. </p>
</blockquote>
<p>Returns <code>false</code> if the accessor is invalid. <code>T</code> must be one of the following types:</p><ul>
<li>Float vectors: <code>float</code>, <code>glm::vec2</code>, <code>glm::vec3</code>, or <code>glm::vec4</code>.</li>
<li>Unsigned integer vectors: <code>uint32_t</code>, <code>glm::uvec2</code>, <code>glm::uvec3</code>, or <code>glm::uvec4</code>.</li>
<li>Signed integer vectors: <code>int32_t</code>, <code>glm::ivec2</code>, <code>glm::ivec3</code>, or <code>glm::ivec4</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md25"></a>
Function &lt;tt&gt;getAccessorData2&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Returns a span with all the values of <code>accessor</code>. </p>
</blockquote>
<p>This is like <code>getAccessorData&lt;T&gt;</code>, except it has a fast path if it can use the buffer's data directly.</p>
<p>If the values needed conversion, re-packing, or had a sparse accessor, uses the provided std::vector for storage. This vector must remain alive as long as the pointer is in use.</p>
<p>Returns a span with nullptr data and 0 length if the accessor is invalid.</p>
<p><code>T</code> must be one of the following types:</p><ul>
<li>Float vectors: <code>float</code>, <code>glm::vec2</code>, <code>glm::vec3</code>, or <code>glm::vec4</code>.</li>
<li>Unsigned integer vectors: <code>uint32_t</code>, <code>glm::uvec2</code>, <code>glm::uvec3</code>, or <code>glm::uvec4</code>.</li>
<li>Signed integer vectors: <code>int32_t</code>, <code>glm::ivec2</code>, <code>glm::ivec3</code>, or <code>glm::ivec4</code>. </li>
</ul>
<h3><a class="anchor" id="autotoc_md26"></a>
Function &lt;tt&gt;getAttribute&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Appends all the values of <code>attribName</code> to <code>attribVec</code>. </p>
</blockquote>
<p>Returns <code>false</code> if the attribute is missing or invalid. <code>T</code> must be <code>glm::vec2</code>, <code>glm::vec3</code>, or <code>glm::vec4</code>. </p>
<h3><a class="anchor" id="autotoc_md27"></a>
Function &lt;tt&gt;appendData&lt;T&gt;&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Appends data from <code>inData</code> to the binary buffer <code>buffer</code> and returns the number of bytes of data added. </p>
</blockquote>
<p><code>T</code> should be a type like <code>std::vector</code>. </p>
<h3><a class="anchor" id="autotoc_md28"></a>
Function &lt;tt&gt;getTextureImageIndex&lt;/tt&gt;</h3>
<blockquote class="doxtable">
<p>Retrieves the image index of a texture, accounting for extensions such as <code>MSFT_texture_dds</code> and <code><a class="el" href="struct_k_h_r__texture__basisu.html">KHR_texture_basisu</a></code>. Retrieves the visibility of a node using <code><a class="el" href="struct_k_h_r__node__visibility.html">KHR_node_visibility</a></code>. </p>
</blockquote>
<p>Does not search up the node hierarchy, so e.g. if node A points to node B and node A is set to invisible and node B is set to visible, then <code>getNodeVisibility(B)</code> will return <code><a class="el" href="struct_k_h_r__node__visibility.html">KHR_node_visibility</a>{true}</code> even though node B would not be visible due to node A. </p>
<h3><a class="anchor" id="autotoc_md29"></a>
Function &lt;tt&gt;getIndex&lt;/tt&gt;</h3>
<p>Return the index of the vertex in the buffer </p>
<h3><a class="anchor" id="autotoc_md30"></a>
Function &lt;tt&gt;getAttributeData&lt;/tt&gt;</h3>
<p>Return the data of the attribute: position, normal, ... </p>
<h3><a class="anchor" id="autotoc_md31"></a>
Function &lt;tt&gt;createTangentAttribute&lt;/tt&gt;</h3>
<p>Create a tangent attribute for the primitive </p>
<h3><a class="anchor" id="autotoc_md32"></a>
Function &lt;tt&gt;simpleCreateTangents&lt;/tt&gt;</h3>
<p>Compute tangents based on the texture coordinates, using also position and normal attributes</p>
<h1><a class="anchor" id="autotoc_md33"></a>
tiny_converter.hpp</h1>
<p>Class <a class="el" href="class_tiny_converter.html">TinyConverter</a></p>
<blockquote class="doxtable">
<p>This class is used to convert a tinyobj::ObjReader to a tinygltf::Model. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:40 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
