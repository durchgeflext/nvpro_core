<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: nvvk::Context Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classnvvk_1_1_context.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classnvvk_1_1_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvvk::Context Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;context_vk.hpp&gt;</code></p>
<div class="dynheader">
Collaboration diagram for nvvk::Context:</div>
<div class="dyncontent">
<div class="center"><img src="classnvvk_1_1_context__coll__graph.png" border="0" usemap="#anvvk_1_1_context_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_context_1_1_features11_old.html">Features11Old</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_context_1_1_physical_device_info.html">PhysicalDeviceInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_context_1_1_properties11_old.html">Properties11Old</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af5ba8898e6bda6b0bf9079844700584e"><td class="memItemLeft" align="right" valign="top"><a id="af5ba8898e6bda6b0bf9079844700584e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Context</b> (<a class="el" href="classnvvk_1_1_context.html">Context</a> const &amp;)=delete</td></tr>
<tr class="separator:af5ba8898e6bda6b0bf9079844700584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3fa0737560586ad296908fe63311ad"><td class="memItemLeft" align="right" valign="top"><a id="adf3fa0737560586ad296908fe63311ad"></a>
<a class="el" href="classnvvk_1_1_context.html">Context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classnvvk_1_1_context.html">Context</a> const &amp;)=delete</td></tr>
<tr class="separator:adf3fa0737560586ad296908fe63311ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff7af33b3897c2b10ee8bd8761664565"><td class="memItemLeft" align="right" valign="top"><a id="aff7af33b3897c2b10ee8bd8761664565"></a>
<a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createQueue</b> (VkQueueFlags requiredFlags, const std::string &amp;debugName, float priority=1.0f)</td></tr>
<tr class="separator:aff7af33b3897c2b10ee8bd8761664565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd387d152cb79e00e22a22572543ab47"><td class="memItemLeft" align="right" valign="top"><a id="afd387d152cb79e00e22a22572543ab47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator VkDevice</b> () const</td></tr>
<tr class="separator:afd387d152cb79e00e22a22572543ab47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096451806bfb8bbe86b99b8f81b64afc"><td class="memItemLeft" align="right" valign="top"><a id="a096451806bfb8bbe86b99b8f81b64afc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (const ContextCreateInfo &amp;info)</td></tr>
<tr class="separator:a096451806bfb8bbe86b99b8f81b64afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41206039aeeb8462611be8419d1b040"><td class="memItemLeft" align="right" valign="top"><a id="ab41206039aeeb8462611be8419d1b040"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deinit</b> ()</td></tr>
<tr class="separator:ab41206039aeeb8462611be8419d1b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1e5c04a5b092aa52c6157297d3610b"><td class="memItemLeft" align="right" valign="top"><a id="aaf1e5c04a5b092aa52c6157297d3610b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initInstance</b> (const ContextCreateInfo &amp;info)</td></tr>
<tr class="separator:aaf1e5c04a5b092aa52c6157297d3610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468d5718e162992d43728be3b9dea2a5"><td class="memItemLeft" align="right" valign="top"><a id="a468d5718e162992d43728be3b9dea2a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initDevice</b> (uint32_t deviceIndex, const ContextCreateInfo &amp;info)</td></tr>
<tr class="separator:a468d5718e162992d43728be3b9dea2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c4712c554751d6f7ee977fba56468d"><td class="memItemLeft" align="right" valign="top"><a id="af2c4712c554751d6f7ee977fba56468d"></a>
std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getCompatibleDevices</b> (const ContextCreateInfo &amp;info)</td></tr>
<tr class="separator:af2c4712c554751d6f7ee977fba56468d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c5cbae7e7260e97c3f2921d9d76888"><td class="memItemLeft" align="right" valign="top"><a id="ad0c5cbae7e7260e97c3f2921d9d76888"></a>
std::vector&lt; VkPhysicalDevice &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPhysicalDevices</b> ()</td></tr>
<tr class="separator:ad0c5cbae7e7260e97c3f2921d9d76888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7723ef1d9811fdb1aca8e317a6d2a6a5"><td class="memItemLeft" align="right" valign="top"><a id="a7723ef1d9811fdb1aca8e317a6d2a6a5"></a>
std::vector&lt; VkPhysicalDeviceGroupProperties &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPhysicalDeviceGroups</b> ()</td></tr>
<tr class="separator:a7723ef1d9811fdb1aca8e317a6d2a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cb4395b665aea468b38f074d77f1d9"><td class="memItemLeft" align="right" valign="top"><a id="a66cb4395b665aea468b38f074d77f1d9"></a>
std::vector&lt; VkExtensionProperties &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInstanceExtensions</b> ()</td></tr>
<tr class="separator:a66cb4395b665aea468b38f074d77f1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24edc4794ea657d11c67cc37e62697b0"><td class="memItemLeft" align="right" valign="top"><a id="a24edc4794ea657d11c67cc37e62697b0"></a>
std::vector&lt; VkLayerProperties &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getInstanceLayers</b> ()</td></tr>
<tr class="separator:a24edc4794ea657d11c67cc37e62697b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07b65ccaac6676d98179728d6ea5acd"><td class="memItemLeft" align="right" valign="top"><a id="ab07b65ccaac6676d98179728d6ea5acd"></a>
std::vector&lt; VkExtensionProperties &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getDeviceExtensions</b> (VkPhysicalDevice physicalDevice)</td></tr>
<tr class="separator:ab07b65ccaac6676d98179728d6ea5acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c13d056606c39267e2cae0a6bf186f"><td class="memItemLeft" align="right" valign="top"><a id="a36c13d056606c39267e2cae0a6bf186f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printPhysicalDeviceProperties</b> (const VkPhysicalDeviceProperties &amp;properties)</td></tr>
<tr class="separator:a36c13d056606c39267e2cae0a6bf186f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c22140f1e19a704074a49e6472fb00a"><td class="memItemLeft" align="right" valign="top"><a id="a2c22140f1e19a704074a49e6472fb00a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasMandatoryExtensions</b> (VkPhysicalDevice physicalDevice, const ContextCreateInfo &amp;info, bool bVerbose)</td></tr>
<tr class="separator:a2c22140f1e19a704074a49e6472fb00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf90f8c85846978ca9c74e53597cf5cf"><td class="memItemLeft" align="right" valign="top"><a id="abf90f8c85846978ca9c74e53597cf5cf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setGCTQueueWithPresent</b> (VkSurfaceKHR surface)</td></tr>
<tr class="separator:abf90f8c85846978ca9c74e53597cf5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6932664448f373b263c041030e44dff9"><td class="memItemLeft" align="right" valign="top"><a id="a6932664448f373b263c041030e44dff9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasDeviceExtension</b> (const char *name) const</td></tr>
<tr class="separator:a6932664448f373b263c041030e44dff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544694daf81aec81b7298b7b73ab513d"><td class="memItemLeft" align="right" valign="top"><a id="a544694daf81aec81b7298b7b73ab513d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasInstanceExtension</b> (const char *name) const</td></tr>
<tr class="separator:a544694daf81aec81b7298b7b73ab513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111343dd1185ae8d31dcffb0fc127764"><td class="memItemLeft" align="right" valign="top"><a id="a111343dd1185ae8d31dcffb0fc127764"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreDebugMessage</b> (int32_t msgID)</td></tr>
<tr class="separator:a111343dd1185ae8d31dcffb0fc127764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c4092ad8d213ae25371f108710e9af"><td class="memItemLeft" align="right" valign="top"><a id="ac0c4092ad8d213ae25371f108710e9af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDebugSeverityFilterMask</b> (int32_t severity)</td></tr>
<tr class="separator:ac0c4092ad8d213ae25371f108710e9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a04e9259b4f2205d2e720d8bdc4136736"><td class="memItemLeft" align="right" valign="top"><a id="a04e9259b4f2205d2e720d8bdc4136736"></a>
VkInstance&#160;</td><td class="memItemRight" valign="bottom"><b>m_instance</b> {VK_NULL_HANDLE}</td></tr>
<tr class="separator:a04e9259b4f2205d2e720d8bdc4136736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9a90138ee7608f1e4f127ccc2ef75b"><td class="memItemLeft" align="right" valign="top"><a id="aed9a90138ee7608f1e4f127ccc2ef75b"></a>
VkDevice&#160;</td><td class="memItemRight" valign="bottom"><b>m_device</b> {VK_NULL_HANDLE}</td></tr>
<tr class="separator:aed9a90138ee7608f1e4f127ccc2ef75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a5a13881fbe7ce3442eb5c938ad0f6"><td class="memItemLeft" align="right" valign="top"><a id="ab7a5a13881fbe7ce3442eb5c938ad0f6"></a>
VkPhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><b>m_physicalDevice</b> {VK_NULL_HANDLE}</td></tr>
<tr class="separator:ab7a5a13881fbe7ce3442eb5c938ad0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d19205312f8b12ffbf3f43650d2df0"><td class="memItemLeft" align="right" valign="top"><a id="a65d19205312f8b12ffbf3f43650d2df0"></a>
<a class="el" href="structnvvk_1_1_context_1_1_physical_device_info.html">PhysicalDeviceInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_physicalInfo</b></td></tr>
<tr class="separator:a65d19205312f8b12ffbf3f43650d2df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe67909248bbd7d8b9beadcbbbe9dca"><td class="memItemLeft" align="right" valign="top"><a id="acbe67909248bbd7d8b9beadcbbbe9dca"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_apiMajor</b> = 0</td></tr>
<tr class="separator:acbe67909248bbd7d8b9beadcbbbe9dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a91550f99e6722e401e19c2a10c136f"><td class="memItemLeft" align="right" valign="top"><a id="a3a91550f99e6722e401e19c2a10c136f"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_apiMinor</b> = 0</td></tr>
<tr class="separator:a3a91550f99e6722e401e19c2a10c136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6a251cb92579be5a6f61eaa8591474"><td class="memItemLeft" align="right" valign="top"><a id="acc6a251cb92579be5a6f61eaa8591474"></a>
<a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_queueGCT</b></td></tr>
<tr class="separator:acc6a251cb92579be5a6f61eaa8591474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bff00884ded93bbe921983a51e6da8"><td class="memItemLeft" align="right" valign="top"><a id="af0bff00884ded93bbe921983a51e6da8"></a>
<a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_queueT</b></td></tr>
<tr class="separator:af0bff00884ded93bbe921983a51e6da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b94f74decdb8bc04cbb6b4f784d7c6"><td class="memItemLeft" align="right" valign="top"><a id="a01b94f74decdb8bc04cbb6b4f784d7c6"></a>
<a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_queueC</b></td></tr>
<tr class="separator:a01b94f74decdb8bc04cbb6b4f784d7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@DOC_START To run a Vulkan application, you need to create the Vulkan instance and device. This is done using the <code><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a></code>, which wraps the creation of <code>VkInstance</code> and <code>VkDevice</code>.</p>
<p>First, any application needs to specify how instance and device should be created: Version, layers, instance and device extensions influence the features available. This is done through a temporary and intermediate class that will allow you to gather all the required conditions for the device creation. @DOC_END @DOC_START </p>
<h1><a class="anchor" id="autotoc_md178"></a>
struct ContextCreateInfo</h1>
<p>This structure allows the application to specify a set of features that are expected for the creation of</p><ul>
<li>VkInstance</li>
<li>VkDevice</li>
</ul>
<p>It is consumed by the <code>nvvk::Context::init</code> function.</p>
<p>Example on how to populate information in it :</p>
<div class="fragment"><div class="line">    nvvk::ContextCreateInfo ctxInfo;</div>
<div class="line">    ctxInfo.setVersion(1, 2);</div>
<div class="line">    ctxInfo.addInstanceExtension(VK_KHR_SURFACE_EXTENSION_NAME, <span class="keyword">false</span>);</div>
<div class="line">    ctxInfo.addInstanceExtension(VK_KHR_WIN32_SURFACE_EXTENSION_NAME, <span class="keyword">false</span>);</div>
<div class="line">    ctxInfo.addDeviceExtension(VK_KHR_SWAPCHAIN_EXTENSION_NAME, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">adding an extension with a feature <span class="keyword">struct</span>:</div>
<div class="line"> </div>
<div class="line">    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR pipePropFeatures = {</div>
<div class="line">        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR};</div>
<div class="line">Be aware of the lifetime of the pointer of the feature <span class="keyword">struct</span>.</div>
<div class="line">ctxInfo stores the pointer directly and context init functions use it <span class="keywordflow">for</span> read &amp; write access.</div>
<div class="line">    ctxInfo.addDeviceExtension(VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME, <span class="keyword">true</span>, &amp;pipePropFeatures);</div>
<div class="line"> </div>
<div class="line">disabling a feature:</div>
<div class="line"> </div>
<div class="line">This callback is called after the feature structs were filled with physical device information</div>
<div class="line">and prior logical device creation.</div>
<div class="line">The callback iterates over all feature structs, including those from</div>
<div class="line">the vulkan versions.</div>
<div class="line">    ctxInfo.fnDisableFeatures = [](VkStructureType sType, <span class="keywordtype">void</span> *pFeatureStruct)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span>(sType){</div>
<div class="line">      <span class="keywordflow">case</span> VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">auto</span>* features11 = <span class="keyword">reinterpret_cast&lt;</span>VkPhysicalDeviceVulkan11Features<span class="keyword">&gt;</span>(pFeatureStruct);</div>
<div class="line">at <span class="keyword">this</span> point the <span class="keyword">struct </span>is populated with what the device supports</div>
<div class="line">and therefore it is only legal to disable features, not enable them.</div>
<div class="line">          </div>
<div class="line">let&#39;s say we wanted to disable multiview</div>
<div class="line">          features11-&gt;multiView = VK_FALSE;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line">    };</div>
</div><!-- fragment --><p>then you are ready to create initialize <code><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a></code></p>
<blockquote class="doxtable">
<p>Note: In debug builds, the extension <code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code> and the layer <code>VK_LAYER_KHRONOS_validation</code> are added to help finding issues early. </p>
</blockquote>
<p>@DOC_END */</p>
<p>static const VkDeviceDiagnosticsConfigFlagsNV defaultAftermathFlags = (VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV // Additional information about the resource related to a GPU virtual address | VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV // Automatic checkpoints for all draw calls (ADD OVERHEAD) | VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV // instructs the shader compiler to generate debug information (ADD OVERHEAD) | VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV);</p>
<p>struct ContextCreateInfo { // aftermathFlags != 0 will enable GPU crash dumps when Aftermath is available via SUPPORT_AFTERMATH // No-op when Aftermath is not available. ContextCreateInfo(bool bUseValidation = true);</p>
<p>void setVersion(uint32_t major, uint32_t minor);</p>
<p>void addInstanceExtension(const char* name, bool optional = false); void addInstanceLayer(const char* name, bool optional = false);</p>
<p>// Add a extension to be enabled at context creation time. If 'optional' is // false, context creation will fail if the extension is not supported by the // device. If the extension requires a feature struct, pass the initialized // struct to 'pFeatureStruct'. If 'version' = 0: don't care, otherwise check // against equality (useful for provisional exts) // // IMPORTANT: The 'pFeatureStruct' pointer will be stored and the object will // later be written to! Make sure the pointer is still valid when // Context::Init() gets called with the ContextCreateInfo object. All // pFeatureStruct objects will be chained together and filled out with the // actual device capabilities during Context::Init(). void addDeviceExtension(const char* name, bool optional = false, void* pFeatureStruct = nullptr, uint32_t version = 0);</p>
<p>void removeInstanceExtension(const char* name); void removeInstanceLayer(const char* name); void removeDeviceExtension(const char* name);</p>
<p>// by default-constructor three queues are requested, // if you want more/different setups manipulate the requestedQueues vector // or use this function. void addRequestedQueue(VkQueueFlags flags, uint32_t count = 1, float priority = 1.0f);</p>
<p>// this callback is run after extension and version related feature structs were queried for their support // from the physical device and prior using them for device creation. It allows custom logic for disabling // certain features. // Be aware that enabling a feature is not legal within this function, only disabling. std::function&lt;void(VkStructureType sType, void* pFeatureStruct)&gt; fnDisableFeatures = nullptr;</p>
<p>// Configure additional device creation with these variables and functions</p>
<p>// use device groups bool useDeviceGroups = false;</p>
<p>// which compatible device or device group to pick // only used by All-in-one Context::init(...) uint32_t compatibleDeviceIndex = 0;</p>
<p>// instance properties std::string appEngine = "nvpro-sample"; std::string appTitle = "nvpro-sample";</p>
<p>// may impact performance hence disable by default bool disableRobustBufferAccess = true;</p>
<p>// Information printed at Context::init time bool verboseCompatibleDevices = true; bool verboseUsed = true; // Print what is used bool verboseAvailable = // Print what is available </p><pre class="fragment">true;
</pre><p>// Will Enable GPU crash dumps when Aftermath is available. // No-op when Aftermath has not been made available via SUPPORT_AFTERMATH in CMakeLists.txt bool enableAftermath = true; VkDeviceDiagnosticsConfigFlagsNV aftermathFlags = defaultAftermathFlags;</p>
<p>struct Entry { Entry(const char* entryName, bool isOptional = false, void* pointerFeatureStruct = nullptr, uint32_t checkVersion = 0) : name(entryName) , optional(isOptional) , pFeatureStruct(pointerFeatureStruct) , version(checkVersion) { }</p>
<p>std::string name; bool optional{false}; void* pFeatureStruct{nullptr}; uint32_t version{0}; };</p>
<p>uint32_t apiMajor{1}; uint32_t apiMinor{1};</p>
<p>using EntryArray = std::vector&lt;Entry&gt;; EntryArray instanceLayers; EntryArray instanceExtensions; EntryArray deviceExtensions; void* deviceCreateInfoExt{nullptr}; void* instanceCreateInfoExt{nullptr};</p>
<p>struct QueueSetup { VkQueueFlags requiredFlags = 0; uint32_t count = 0; float priority = 1.0; }; using QueueArray = std::vector&lt;QueueSetup&gt;;</p>
<p>// this array defines how many queues are required for the provided queue flags // reset / add new entries if changes are desired // // ContextCreateInfo constructor adds 1 queue per default queue flag below QueueArray requestedQueues;</p>
<p>// leave 0 and no default queue will be created VkQueueFlags defaultQueueGCT = VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT; VkQueueFlags defaultQueueT = VK_QUEUE_TRANSFER_BIT; VkQueueFlags defaultQueueC = VK_QUEUE_COMPUTE_BIT; float defaultPriorityGCT = 1.0f; float defaultPriorityT = 1.0f; float defaultPriorityC = 1.0f; };</p>
<p>////////////////////////////////////////////////////////////////////////// /** @DOC_START </p>
<h1><a class="anchor" id="autotoc_md179"></a>
class nvvk::Context</h1>
<p><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a> class helps creating the Vulkan instance and to choose the logical device for the mandatory extensions. First is to fill the <code>ContextCreateInfo</code> structure, then call:</p>
<div class="fragment"><div class="line"><span class="comment">// Creating the Vulkan instance and device</span></div>
<div class="line">nvvk::ContextCreateInfo ctxInfo;</div>
<div class="line">... see above ...</div>
<div class="line"> </div>
<div class="line">nvvk::Context vkctx;</div>
<div class="line">vkctx.init(ctxInfo);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// after init the ctxInfo is no longer needed</span></div>
</div><!-- fragment --><p>At this point, the class will have created the <code>VkInstance</code> and <code>VkDevice</code> according to the information passed. It will also keeps track or have query the information of:</p>
<p>Physical Device information that you can later query : <code><a class="el" href="structnvvk_1_1_context_1_1_physical_device_info.html">PhysicalDeviceInfo</a></code> in which lots of <code>VkPhysicalDevice...</code> are stored <code>VkInstance</code> : the one instance being used for the program <code>VkPhysicalDevice</code> : physical device(s) used for the logical device creation. In case of more than one physical device, we have a std::vector for this purpose... <code>VkDevice</code> : the logical device instantiated <code>VkQueue</code> : By default, 3 queues are created, one per family: Graphic-Compute-Transfer, Compute and Transfer. For any additionnal queue, they need to be requested with <code>ContextCreateInfo::addRequestedQueue()</code>. This is creating information of the best suitable queues, but not creating them. To create the additional queues, <code>Context::createQueue()</code> <b>must be call after</b> creating the Vulkan context. The following queues are always created and can be directly accessed without calling createQueue : <code><a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a> m_queueGCT</code> : Graphics/Compute/Transfer <a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a> + family index <code><a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a> m_queueT</code> : async Transfer <a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a> + family index <code><a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a> m_queueC</code> : async Compute <a class="el" href="structnvvk_1_1_context_1_1_queue.html">Queue</a> + family index maintains what extensions are finally available implicitly hooks up the debug callback</p>
<h2><a class="anchor" id="autotoc_md180"></a>
Choosing the device</h2>
<p>When there are multiple devices, the <code>init</code> method is choosing the first compatible device available, but it is also possible the choose another one. </p><div class="fragment"><div class="line">vkctx.initInstance(deviceInfo); </div>
<div class="line"><span class="comment">// Find all compatible devices</span></div>
<div class="line"><span class="keyword">auto</span> compatibleDevices = vkctx.getCompatibleDevices(deviceInfo);</div>
<div class="line">assert(!compatibleDevices.empty());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use first compatible device</span></div>
<div class="line">vkctx.initDevice(compatibleDevices[0], deviceInfo);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md181"></a>
Multi-GPU</h2>
<p>When multiple graphic cards should be used as a single device, the <code>ContextCreateInfo::useDeviceGroups</code> need to be set to <code>true</code>. The above methods will transparently create the <code>VkDevice</code> using <code>VkDeviceGroupDeviceCreateInfo</code>. Especially in the context of NVLink connected cards this is useful.</p>
<p>@DOC_END </p>
</div><hr/>The documentation for this class was generated from the following files:<ul>
<li>context_vk.hpp</li>
<li>context_vk.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvvk.html">nvvk</a></li><li class="navelem"><a class="el" href="classnvvk_1_1_context.html">Context</a></li>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:48 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
