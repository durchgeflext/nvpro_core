<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__mnt_c__uni__s_s24__pd_f__micro_geom_nvpro_core_nvh__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Table of Contents </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#alignmenthpp">alignment.hpp</a></li>
<li><a href="#appwindowcamerainertiahpp">appwindowcamerainertia.hpp</a></li>
<li><a href="#appwindowprofilerhpp">appwindowprofiler.hpp</a></li>
<li><a href="#bitarrayhpp">bitarray.hpp</a></li>
<li><a href="#boundingboxhpp">boundingbox.hpp</a></li>
<li><a href="#cameracontrolhpp">cameracontrol.hpp</a></li>
<li><a href="#camerainertiahpp">camerainertia.hpp</a></li>
<li><a href="#cameramanipulatorhpp">cameramanipulator.hpp</a></li>
<li><a href="#commandlineparserhpp">commandlineparser.hpp</a></li>
<li><a href="#fileoperationshpp">fileoperations.hpp</a></li>
<li><a href="#geometryhpp">geometry.hpp</a></li>
<li><a href="#gltfscenehpp">gltfscene.hpp</a></li>
<li><a href="#inputparserh">inputparser.h</a></li>
<li><a href="#mischpp">misc.hpp</a></li>
<li><a href="#nvml_monitorhpp">nvml_monitor.hpp</a></li>
<li><a href="#nvprinthpp">nvprint.hpp</a></li>
<li><a href="#parallel_workhpp">parallel_work.hpp</a></li>
<li><a href="#parametertoolshpp">parametertools.hpp</a></li>
<li><a href="#primitiveshpp">primitives.hpp</a></li>
<li><a href="#profilerhpp">profiler.hpp</a></li>
<li><a href="#radixsorthpp">radixsort.hpp</a></li>
<li><a href="#shaderfilemanagerhpp">shaderfilemanager.hpp</a></li>
<li><a href="#stacktracehpp">stacktrace.hpp</a></li>
<li><a href="#threadinghpp">threading.hpp</a></li>
<li><a href="#timesamplerhpp">timesampler.hpp</a></li>
<li><a href="#trangeallocatorhpp">trangeallocator.hpp</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md98"></a>
alignment.hpp</h1>
<p>Contains functions for aligning numbers to power-of-two boundaries. </p>
<h2><a class="anchor" id="autotoc_md99"></a>
Function &lt;tt&gt;is_aligned&lt;integral&gt;(x, a)&lt;/tt&gt;</h2>
<p>Returns whether <code>x</code> is a multiple of <code>a</code>. <code>a</code> must be a power of two. </p>
<h2><a class="anchor" id="autotoc_md100"></a>
Function &lt;tt&gt;align_up&lt;integral&gt;(x, a)&lt;/tt&gt;</h2>
<p>Rounds <code>x</code> up to a multiple of <code>a</code>. <code>a</code> must be a power of two. </p>
<h2><a class="anchor" id="autotoc_md101"></a>
Function &lt;tt&gt;align_down&lt;integral&gt;(x, a)&lt;/tt&gt;</h2>
<p>Rounds <code>x</code> down to a multiple of <code>a</code>. <code>a</code> must be a power of two.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
appwindowcamerainertia.hpp</h1>
<h2><a class="anchor" id="autotoc_md103"></a>
class AppWindowCameraInertia</h2>
<blockquote class="doxtable">
<p><a class="el" href="class_app_window_camera_inertia.html">AppWindowCameraInertia</a> is a Window base for samples, adding a camera with inertia </p>
</blockquote>
<p>It derives the Window for this sample</p>
<h1><a class="anchor" id="autotoc_md104"></a>
appwindowprofiler.hpp</h1>
<h2><a class="anchor" id="autotoc_md105"></a>
class nvh::AppWindowProfiler</h2>
<p><a class="el" href="classnvh_1_1_app_window_profiler.html">nvh::AppWindowProfiler</a> provides an alternative utility wrapper class around <a class="el" href="class_n_v_p_window.html">NVPWindow</a>. It is useful to derive single-window applications from and is used by some but not all nvpro-samples.</p>
<p>Further functionality is provided :</p><ul>
<li>built-in profiler/timer reporting to console</li>
<li>command-line argument parsing as well as config file parsing using the ParameterTools see AppWindowProfiler::setupParameters() for built-in commands</li>
<li>benchmark/automation mode using ParameterTools</li>
<li>screenshot creation</li>
<li>logfile based on devicename (depends on context)</li>
<li>optional context/swapchain interface the derived classes nvvk/appwindowprofiler_vk and nvgl/appwindowprofiler_gl make use of this</li>
</ul>
<h1><a class="anchor" id="autotoc_md106"></a>
bitarray.hpp</h1>
<h2><a class="anchor" id="autotoc_md107"></a>
class nvh::BitArray</h2>
<blockquote class="doxtable">
<p>The <a class="el" href="classnvh_1_1_bit_array.html">nvh::BitArray</a> class implements a tightly packed boolean array using single bits stored in uint64_t values. </p>
</blockquote>
<p>Whenever you want large boolean arrays this representation is preferred for cache-efficiency. The Visitor and OffsetVisitor traversal mechanisms make use of cpu intrinsics to speed up iteration over bits.</p>
<p>Example: </p><div class="fragment"><div class="line">BitArray modifiedObjects(1024);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set some bits</span></div>
<div class="line">modifiedObjects.setBit(24,<span class="keyword">true</span>);</div>
<div class="line">modifiedObjects.setBit(37,<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// iterate over all set bits using the built-in traversal mechanism</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyVisitor {</div>
<div class="line"><span class="keywordtype">void</span> operator()( <span class="keywordtype">size_t</span> index ){</div>
<div class="line">    <span class="comment">// called with the index of a set bit</span></div>
<div class="line">    myObjects[index].update();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyVisitor visitor;</div>
<div class="line">modifiedObjects.traverseBits(visitor);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md108"></a>
boundingbox.hpp</h1>
<div class="fragment"><div class="line"> {nvh::Bbox```}</div>
<div class="line">It grows by adding 3d vector, can combine other bound boxes.</div>
<div class="line">And it returns information, like its volume, its center, the min, max, etc..</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## cameracontrol.hpp</div>
<div class="line">### class nvh::CameraControl</div>
<div class="line"> </div>
<div class="line">&gt; nvh::CameraControl is a utility class to create a viewmatrix based on mouse inputs.</div>
<div class="line"> </div>
<div class="line">It can operate in perspective or orthographic mode (`m_sceneOrtho==true`).</div>
<div class="line"> </div>
<div class="line">perspective:</div>
<div class="line">- LMB: rotate</div>
<div class="line">- RMB or WHEEL: zoom via dolly movement</div>
<div class="line">- MMB: pan/move within camera plane</div>
<div class="line"> </div>
<div class="line">ortho:</div>
<div class="line">- LMB: pan/move within camera plane</div>
<div class="line">- RMB or WHEEL: zoom via dolly movement, application needs to use `m_sceneOrthoZoom` for projection matrix adjustment</div>
<div class="line">- MMB: rotate</div>
<div class="line"> </div>
<div class="line">The camera can be orbiting (`m_useOrbit==true`) around `m_sceneOrbit` or</div>
<div class="line">otherwise provide &quot;first person/fly through&quot;-like controls.</div>
<div class="line"> </div>
<div class="line">Speed of movement/rotation etc. is influenced by `m_sceneDimension` as well as the</div>
<div class="line">sensitivity values.</div>
<div class="line"> </div>
<div class="line">## camerainertia.hpp</div>
<div class="line">### struct InertiaCamera</div>
<div class="line">&gt;  Struct that offers a camera moving with some inertia effect around a target point</div>
<div class="line"> </div>
<div class="line">InertiaCamera exposes a mix of pseudo polar rotation around a target point and</div>
<div class="line">some other movements to translate the target point, zoom in and out.</div>
<div class="line"> </div>
<div class="line">Either the keyboard or mouse can be used for all of the moves.</div>
<div class="line"> </div>
<div class="line">## cameramanipulator.hpp</div>
<div class="line">### class nvh::CameraManipulator</div>
<div class="line"> </div>
<div class="line">nvh::CameraManipulator is a camera manipulator help class</div>
<div class="line">It allow to simply do</div>
<div class="line">- Orbit        (LMB)</div>
<div class="line">- Pan          (LMB + CTRL  | MMB)</div>
<div class="line">- Dolly        (LMB + SHIFT | RMB)</div>
<div class="line">- Look Around  (LMB + ALT   | LMB + CTRL + SHIFT)</div>
<div class="line"> </div>
<div class="line">In a various ways:</div>
<div class="line">- examiner(orbit around object)</div>
<div class="line">- walk (look up or down but stays on a plane)</div>
<div class="line">- fly ( go toward the interest point)</div>
<div class="line"> </div>
<div class="line">Do use the camera manipulator, you need to do the following</div>
<div class="line">- Call setWindowSize() at creation of the application and when the window size change</div>
<div class="line">- Call setLookat() at creation to initialize the camera look position</div>
<div class="line">- Call setMousePosition() on application mouse down</div>
<div class="line">- Call mouseMove() on application mouse move</div>
<div class="line"> </div>
<div class="line">Retrieve the camera matrix by calling getMatrix()</div>
<div class="line"> </div>
<div class="line">See: appbase_vkpp.hpp</div>
<div class="line"> </div>
<div class="line">Note: There is a singleton `CameraManip` which can be use across the entire application</div>
<div class="line"> </div>
<div class="line">```cpp</div>
<div class="line">// Retrieve/set camera information</div>
<div class="line">CameraManip.getLookat(eye, center, up);</div>
<div class="line">CameraManip.setLookat(eye, center, glm::vec3(m_upVector == 0, m_upVector == 1, m_upVector == 2));</div>
<div class="line">CameraManip.getFov();</div>
<div class="line">CameraManip.setSpeed(navSpeed);</div>
<div class="line">CameraManip.setMode(navMode == 0 ? nvh::CameraManipulator::Examine : nvh::CameraManipulator::Fly);</div>
<div class="line">// On mouse down, keep mouse coordinates</div>
<div class="line">CameraManip.setMousePosition(x, y);</div>
<div class="line">// On mouse move and mouse button down</div>
<div class="line">if(m_inputs.lmb || m_inputs.rmb || m_inputs.mmb)</div>
<div class="line">{</div>
<div class="line">CameraManip.mouseMove(x, y, m_inputs);</div>
<div class="line">}</div>
<div class="line">// Wheel changes the FOV</div>
<div class="line">CameraManip.wheel(delta &gt; 0 ? 1 : -1, m_inputs);</div>
<div class="line">// Retrieve the matrix to push to the shader</div>
<div class="line">m_ubo.view = CameraManip.getMatrix();</div>
<div class="line">````</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">## commandlineparser.hpp</div>
<div class="line">Command line parser.</div>
<div class="line">```cpp</div>
<div class="line">    std::string            inFilename{};</div>
<div class="line">    bool                   printHelp = false;</div>
<div class="line">    glm::ivec2             winSize   = {1280, 720};</div>
<div class="line">    int8_t                 color[3];</div>
<div class="line">    nvh::CommandLineParser cli(&quot;Test Parser&quot;);</div>
<div class="line">    cli.addArgument({&quot;-f&quot;, &quot;--filename&quot;}, &amp;inFilename, &quot;Input filename&quot;);</div>
<div class="line">    cli.addArgument({&quot;--winSize&quot;}, &amp;winSize, &quot;Size of window&quot;,</div>
<div class="line">                    [&amp;]() { glfwSetWindowSize(nullptr, winSize[0], winSize[1]); });</div>
<div class="line">    cli.addArgument({&quot;--callback&quot;}, 1, &quot;Callback with one argument&quot;,</div>
<div class="line">                    [&amp;inFilename](std::vector&lt;std::string&gt; const&amp; args) { inFilename = args[0]; });</div>
<div class="line">    cli.addArgument({&quot;--color&quot;}, 3, &quot;Clear color &quot;, [&amp;color](std::vector&lt;std::string&gt; const&amp; args) {</div>
<div class="line">      std::stringstream(args[0]) &gt;&gt; color[0];</div>
<div class="line">      std::stringstream(args[1]) &gt;&gt; color[1];</div>
<div class="line">      std::stringstream(args[2]) &gt;&gt; color[2];</div>
<div class="line">    });</div>
<div class="line">    cli.addFilename(&quot;.gltf&quot;, &amp;inFilename, &quot;Input filename with extension&quot;);</div>
<div class="line">    bool result = cli.parse(argc, argv);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md109"></a>
fileoperations.hpp</h1>
<h2><a class="anchor" id="autotoc_md110"></a>
functions in nvh</h2>
<ul>
<li>nvh::fileExists : check if file exists</li>
<li>nvh::findFile : finds filename in provided search directories</li>
<li>nvh::loadFile : (multiple overloads) loads file as std::string, binary or text, can also search in provided directories</li>
<li>nvh::getFileName : splits filename from filename with path</li>
<li>nvh::getFilePath : splits filepath from filename with path</li>
</ul>
<h1><a class="anchor" id="autotoc_md111"></a>
geometry.hpp</h1>
<h2><a class="anchor" id="autotoc_md112"></a>
namespace nvh::geometry</h2>
<p>The geometry namespace provides a few procedural mesh primitives that are subdivided.</p>
<p><a class="el" href="classnvh_1_1geometry_1_1_mesh.html">nvh::geometry::Mesh</a> template uses the provided TVertex which must have a constructor from <a class="el" href="structnvh_1_1geometry_1_1_vertex.html">nvh::geometry::Vertex</a>. You can also use <a class="el" href="structnvh_1_1geometry_1_1_vertex.html">nvh::geometry::Vertex</a> directly.</p>
<p>It provides triangle indices, as well as outline line indices. The outline indices are typical feature lines (rectangle for plane, some circles for sphere/torus).</p>
<p>All basic primitives are within -1,1 ranges along the axis they use</p>
<ul>
<li><a class="el" href="classnvh_1_1geometry_1_1_plane.html">nvh::geometry::Plane</a> (x,y subdivision)</li>
<li><a class="el" href="classnvh_1_1geometry_1_1_box.html">nvh::geometry::Box</a> (x,y,z subdivision, made of 6 planes)</li>
<li><a class="el" href="classnvh_1_1geometry_1_1_sphere.html">nvh::geometry::Sphere</a> (lat,long subdivision)</li>
<li><a class="el" href="classnvh_1_1geometry_1_1_torus.html">nvh::geometry::Torus</a> (inner, outer circle subdivision)</li>
<li><a class="el" href="classnvh_1_1geometry_1_1_random_menger_sponge.html">nvh::geometry::RandomMengerSponge</a> (subdivision, tree depth, probability)</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// single primitive</span></div>
<div class="line"><a class="code" href="classnvh_1_1geometry_1_1_box.html">nvh::geometry::Box&lt;nvh::geometry::Vertex&gt;</a> box(4,4,4);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// construct from primitives</span></div>
<div class="ttc" id="aclassnvh_1_1geometry_1_1_box_html"><div class="ttname"><a href="classnvh_1_1geometry_1_1_box.html">nvh::geometry::Box</a></div><div class="ttdef"><b>Definition:</b> geometry.hpp:220</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md113"></a>
gltfscene.hpp</h1>
<h2><a class="anchor" id="autotoc_md114"></a>
nvh::gltf::Scene</h2>
<p>The Scene class is responsible for loading and managing a glTF scene.</p><ul>
<li>It is used to load a glTF file and parse it into a scene representation.</li>
<li>It can be used to save the scene back to a glTF file.</li>
<li>It can be used to manage the animations of the scene.</li>
<li>What it returns is a list of RenderNodes, RenderPrimitives, RenderCameras, and RenderLights.</li>
<li>RenderNodes are the instances of the primitives in the scene that will be rendered.</li>
<li>RenderPrimitives are the unique primitives in the scene.</li>
</ul>
<p>Note: The Scene class is a more advanced and light weight version of the GltfScene class. But it is to the user to retrieve the primitive data from the RenderPrimitives. Check the tinygltf_utils.hpp for more information on how to extract the primitive data.</p>
<h2><a class="anchor" id="autotoc_md115"></a>
&lt;tt&gt;nvh::GltfScene&lt;/tt&gt; &lt;strong&gt;DEPRECATED&lt;/strong&gt;</h2>
<p>These utilities are for loading glTF models in a canonical scene representation. From this representation you would create the appropriate 3D API resources (buffers and textures).</p>
<div class="fragment"><div class="line"><span class="comment">// Typical Usage</span></div>
<div class="line"><span class="comment">// Load the GLTF Scene using TinyGLTF</span></div>
<div class="line"> </div>
<div class="line">tinygltf::Model    gltfModel;</div>
<div class="line">tinygltf::TinyGLTF gltfContext;</div>
<div class="line">fileLoaded = gltfContext.LoadASCIIFromFile(&amp;gltfModel, &amp;error, &amp;warn, m_filename);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill the data in the gltfScene</span></div>
<div class="line">gltfScene.getMaterials(tmodel);</div>
<div class="line">gltfScene.getDrawableNodes(tmodel, GltfAttributes::Normal | GltfAttributes::Texcoord_0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Todo in App:</span></div>
<div class="line"><span class="comment">//   create buffers for vertices and indices, from gltfScene.m_position, gltfScene.m_index</span></div>
<div class="line"><span class="comment">//   create textures from images: using tinygltf directly</span></div>
<div class="line"><span class="comment">//   create descriptorSet for material using directly gltfScene.m_materials</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md116"></a>
inputparser.h</h1>
<h2><a class="anchor" id="autotoc_md117"></a>
class InputParser</h2>
<blockquote class="doxtable">
<p>InputParser is a Simple command line parser </p>
</blockquote>
<p>Example of usage for: test.exe -f name.txt -size 200 100</p>
<p>Parsing the command line: mandatory '-f' for the filename of the scene</p>
<div class="fragment"><div class="line">nvh::InputParser parser(argc, argv);</div>
<div class="line">std::string filename = parser.getString(<span class="stringliteral">&quot;-f&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(filename.empty())  filename = <span class="stringliteral">&quot;default.txt&quot;</span>;</div>
<div class="line"><span class="keywordflow">if</span>(parser.exist(<span class="stringliteral">&quot;-size&quot;</span>) {</div>
<div class="line">      auto values = parser.getInt2(<span class="stringliteral">&quot;-size&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md118"></a>
misc.hpp</h1>
<h2><a class="anchor" id="autotoc_md119"></a>
functions in nvh</h2>
<ul>
<li>mipMapLevels : compute number of mip maps</li>
<li>stringFormat : sprintf for std::string</li>
<li>frand : random float using rand()</li>
<li>permutation : fills uint vector with random permutation of values [0... vec.size-1]</li>
</ul>
<h1><a class="anchor" id="autotoc_md120"></a>
nvml_monitor.hpp</h1>
<p>Capture the GPU load and memory for all GPUs on the system.</p>
<p>Usage:</p><ul>
<li>There should be only one instance of NvmlMonitor</li>
<li>call refresh() in each frame. It will not pull more measurement that the interval(ms)</li>
<li>isValid() : return if it can be used</li>
<li>nbGpu() : return the number of GPU in the computer</li>
<li>getGpuInfo() : static info about the GPU</li>
<li>getDeviceMemory() : memory consumption info</li>
<li>getDeviceUtilization() : GPU and memory utilization</li>
<li>getDevicePerformanceState() : clock speeds and throttle reasons</li>
<li>getDevicePowerState() : power, temperature and fan speed</li>
</ul>
<p>Measurements:</p><ul>
<li>Uses a cycle buffer.</li>
<li>Offset is the last measurement</li>
</ul>
<h1><a class="anchor" id="autotoc_md121"></a>
nvprint.hpp</h1>
<p>Multiple functions and macros that should be used for logging purposes, rather than <code>printf</code>. These can print to multiple places at once, produce breakpoints on certain types of messages, and more.</p>
<h2><a class="anchor" id="autotoc_md122"></a>
Function &lt;tt&gt;nvprintf&lt;/tt&gt; etc.</h2>
<p>Configuration:</p><ul>
<li><code>nvprintSetLevel</code> : sets default loglevel</li>
<li><code>nvprintGetLevel</code> : gets default loglevel</li>
<li><code>nvprintSetLogFileName</code> : sets log filename</li>
<li><code>nvprintSetLogging</code> : sets file logging state</li>
<li><code>nvprintSetCallback</code> : sets custom callback</li>
</ul>
<h2><a class="anchor" id="autotoc_md123"></a>
Printf-style functions and macros.</h2>
<p>These take <code>printf</code>-style specifiers.</p><ul>
<li><code>nvprintf</code> : prints at default loglevel</li>
<li><code>nvprintfLevel</code> : <code>nvprintfLevel</code> print at a certain loglevel</li>
<li><code>LOGI</code> : macro that does <code>nvprintfLevel(LOGLEVEL_INFO)</code></li>
<li><code>LOGW</code> : macro that does <code>nvprintfLevel(LOGLEVEL_WARNING)</code></li>
<li><code>LOGE</code> : macro that does <code>nvprintfLevel(LOGLEVEL_ERROR)</code></li>
<li><code>LOGE_FILELINE</code> : macro that does <code>nvprintfLevel(LOGLEVEL_ERROR)</code> combined with filename/line</li>
<li><code>LOGD</code> : macro that does <code>nvprintfLevel(LOGLEVEL_DEBUG)</code> (only in debug builds)</li>
<li><code>LOGOK</code> : macro that does <code>nvprintfLevel(LOGLEVEL_OK)</code></li>
<li><code>LOGSTATS</code> : macro that does <code>nvprintfLevel(LOGLEVEL_STATS)</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md124"></a>
&lt;tt&gt;std::print&lt;/tt&gt;-style functions and macros.</h2>
<p>These take <a href="https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification"><code>std::format</code>-style specifiers</a>.</p><ul>
<li><code>nvprintLevel</code> : print at a certain loglevel</li>
<li><code>PRINTI</code> : macro that does <code>nvprintLevel(LOGLEVEL_INFO)</code></li>
<li><code>PRINTW</code> : macro that does <code>nvprintLevel(LOGLEVEL_WARNING)</code></li>
<li><code>PRINTE</code> : macro that does <code>nvprintLevel(LOGLEVEL_ERROR)</code></li>
<li><code>PRINTE_FILELINE</code> : macro that does <code>nvprintLevel(LOGLEVEL_ERROR)</code> combined with filename/line</li>
<li><code>PRINTD</code> : macro that does <code>nvprintLevel(LOGLEVEL_DEBUG)</code> (only in debug builds)</li>
<li><code>PRINTOK</code> : macro that does <code>nvprintLevel(LOGLEVEL_OK)</code></li>
<li><code>PRINTSTATS</code> : macro that does <code>nvprintLevel(LOGLEVEL_STATS)</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md125"></a>
Safety:</h2>
<p>On error, all functions print an error message.</p>
<p>All functions are thread-safe.</p>
<p><code>Printf</code>-style functions have annotations that should produce warnings at compile-time or when performing static analysis. Their format strings may be dynamic - but this can be bad if an adversary can choose the content of the format string.</p>
<p><code>std::print</code>-style functions are safer: they produce compile-time errors, and their format strings must be compile-time constants. Dynamic formatting should be performed outside of printing, like this:</p>
<div class="fragment"><div class="line">ImGui::InputText(<span class="stringliteral">&quot;Enter a format string: &quot;</span>, userFormat, <span class="keyword">sizeof</span>(userFormat));</div>
<div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">  std::string formatted = fmt::vformat(userFormat, ...);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line">{</div>
<div class="line">  (error handling...)</div>
<div class="line">}</div>
<div class="line">PRINTI(<span class="stringliteral">&quot;{}&quot;</span>, formatted);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md126"></a>
Text encoding:</h2>
<p>Printing to the Windows debug console is the only operation that assumes a text encoding; the input is assumed to be UTF-8. In all other cases, strings are copied into the output.</p>
<h1><a class="anchor" id="autotoc_md127"></a>
parallel_work.hpp</h1>
<p>Distributes batches of loops over BATCHSIZE items across multiple threads. numItems reflects the total number of items to process.</p>
<div class="fragment"><div class="line">batches:         fn (uint64_t itemIndex)</div>
<div class="line">                 callback does single item</div>
<div class="line"> </div>
<div class="line">batches_indexed: fn (uint64_t itemIndex, uint32_t threadIndex)</div>
<div class="line">                 callback does single item</div>
<div class="line">                 uses at most get_thread_pool().thread_count() threads</div>
<div class="line"> </div>
<div class="line">ranges:          fn (uint64_t itemBegin, uint64_t itemEnd, uint32_t threadIndex)</div>
<div class="line">                 callback does loop: <span class="keywordflow">for</span> (uint64_t itemIndex = itemBegin; itemIndex &lt; itemEnd; itemIndex++)</div>
<div class="line">                 uses at most get_thread_pool().get_thread_count() threads</div>
</div><!-- fragment --><p><code>BATCHSIZE</code> will also be used as the threshold for when to switch from single-threaded to multi-threaded execution. For this reason, it should be set to a power of 2 around where multi-threaded is faster than single-threaded for the given function. Some examples are:</p><ul>
<li>8192 for trivial workloads (a * x + y)</li>
<li>2048 for animation workloads (multiplication by a single matrix)</li>
<li>512 for more computationally heavy workloads (run XTEA)</li>
<li>1 for full parallelization (load an image)</li>
</ul>
<p>If numThreads is equal to 1, runs single-threaded. Otherwise, <code>numThreads</code> is ignored.</p>
<p>All functions here are thread-safe. However, if the callback does synchronization (e.g. locking, mutexes), then it is only safe to use batches_indexed and ranges.</p>
<h1><a class="anchor" id="autotoc_md128"></a>
parametertools.hpp</h1>
<h2><a class="anchor" id="autotoc_md129"></a>
class nvh::ParameterList</h2>
<p>The <a class="el" href="classnvh_1_1_parameter_list.html">nvh::ParameterList</a> helps parsing commandline arguments or commandline arguments stored within ascii config files.</p>
<p>Parameters always update the values they point to, and optionally can trigger a callback that can be provided per-parameter.</p>
<div class="fragment"><div class="line">ParameterList list;</div>
<div class="line">std::string   modelFilename;</div>
<div class="line"><span class="keywordtype">float</span>         modelScale;</div>
<div class="line"> </div>
<div class="line">list.addFilename(<span class="stringliteral">&quot;.gltf|model filename&quot;</span>, &amp;modelFilename);</div>
<div class="line">list.add(<span class="stringliteral">&quot;scale|model scale&quot;</span>, &amp;modelScale);</div>
<div class="line"> </div>
<div class="line">list.applyTokens(3, {<span class="stringliteral">&quot;blah.gltf&quot;</span>,<span class="stringliteral">&quot;-scale&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>}, <span class="stringliteral">&quot;-&quot;</span>, <span class="stringliteral">&quot;/assets/&quot;</span>);</div>
</div><!-- fragment --><p>Use in combination with the ParameterSequence class to iterate sequences of parameter changes for benchmarking/automation. </p>
<h2><a class="anchor" id="autotoc_md130"></a>
class nvh::ParameterSequence</h2>
<p>The <a class="el" href="classnvh_1_1_parameter_sequence.html">nvh::ParameterSequence</a> processes provided tokens in sequences. The sequences are terminated by a special "separator" token. All tokens between the last iteration and the separator are applied to the provided ParameterList. Useful to process commands in sequences (automation, benchmarking etc.).</p>
<p>Example:</p>
<div class="fragment"><div class="line">ParameterSequence sequence;</div>
<div class="line">ParameterList     list;</div>
<div class="line"><span class="keywordtype">int</span>               mode;</div>
<div class="line">list.add(<span class="stringliteral">&quot;mode&quot;</span>, &amp;mode);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;const char*&gt; tokens;</div>
<div class="line">ParameterList::tokenizeString(<span class="stringliteral">&quot;benchmark simple -mode 10 benchmark complex -mode 20&quot;</span>, tokens);</div>
<div class="line">sequence.init(&amp;list, tokens);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// 1 means our separator is followed by one argument (simple/complex)</span></div>
<div class="line">   <span class="comment">// &quot;-&quot; as parameters in the string are prefixed with -</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(!sequence.advanceIteration(<span class="stringliteral">&quot;benchmark&quot;</span>, 1, <span class="stringliteral">&quot;-&quot;</span>)) {</div>
<div class="line">  printf(<span class="stringliteral">&quot;%d %s mode %d\n&quot;</span>, sequence.getIteration(), sequence.getSeparatorArg(0), mode);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// would print:</span></div>
<div class="line"><span class="comment">//   0 simple mode 10</span></div>
<div class="line"><span class="comment">//   1 complex mode 20</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md131"></a>
primitives.hpp</h1>
<h2><a class="anchor" id="autotoc_md132"></a>
struct &lt;tt&gt;nvh::PrimitiveMesh&lt;/tt&gt;</h2>
<ul>
<li>Common primitive type, made of vertices: position, normal and texture coordinates.</li>
<li>All primitives are triangles, and each 3 indices is forming a triangle.</li>
</ul>
<h2><a class="anchor" id="autotoc_md133"></a>
struct &lt;tt&gt;nvh::Node&lt;/tt&gt;</h2>
<ul>
<li>Structure to hold a reference to a mesh, with a material and transformation.</li>
</ul>
<p>Primitives that can be created:</p><ul>
<li>Tetrahedron</li>
<li>Icosahedron</li>
<li>Octahedron</li>
<li>Plane</li>
<li>Cube</li>
<li>SphereUv</li>
<li>Cone</li>
<li>SphereMesh</li>
<li>Torus</li>
</ul>
<p>Node creator: returns the instance and the position</p><ul>
<li>MengerSponge</li>
<li>SunFlower</li>
</ul>
<p>Other utilities</p><ul>
<li>mergeNodes</li>
<li>removeDuplicateVertices</li>
<li>wobblePrimitive</li>
</ul>
<h1><a class="anchor" id="autotoc_md134"></a>
profiler.hpp</h1>
<h2><a class="anchor" id="autotoc_md135"></a>
class nvh::Profiler</h2>
<blockquote class="doxtable">
<p>The <a class="el" href="classnvh_1_1_profiler.html">nvh::Profiler</a> class is designed to measure timed sections. </p>
</blockquote>
<p>Each section has a cpu and gpu time. Gpu times are typically provided by derived classes for each individual api (e.g. OpenGL, Vulkan etc.).</p>
<p>There is functionality to pretty print the sections with their nesting level. Multiple profilers can reference the same database, so one profiler can serve as master that they others contribute to. Typically the base class measuring only CPU time could be the master, and the api derived classes reference it to share the same database.</p>
<p>Profiler::Clock can be used standalone for time measuring.</p>
<h1><a class="anchor" id="autotoc_md136"></a>
radixsort.hpp</h1>
<h2><a class="anchor" id="autotoc_md137"></a>
function nvh::radixsort</h2>
<p>The radixsort function sorts the provided keys based on BYTES many bytes stored inside TKey starting at BYTEOFFSET. The sorting result is returned as indices into the keys array.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyData {</div>
<div class="line">  uint32_t objectIdentifier;</div>
<div class="line">  uint16_t objectSortKey;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4-byte offset of objectSortKey within MyData</span></div>
<div class="line"><span class="comment">// 2-byte size of sorting key</span></div>
<div class="line"> </div>
<div class="line">result = radixsort&lt;4,2&gt;(keys, indicesIn, indicesTemp);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// after sorting the following is true</span></div>
<div class="line"> </div>
<div class="line">keys[result[i]].objectSortKey &lt; keys[result[i + 1]].objectSortKey</div>
<div class="line"> </div>
<div class="line"><span class="comment">// result can point either to indicesIn or indicesTemp (we swap the arrays</span></div>
<div class="line"><span class="comment">// after each byte iteration)</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md138"></a>
shaderfilemanager.hpp</h1>
<h2><a class="anchor" id="autotoc_md139"></a>
class nvh::ShaderFileManager</h2>
<p>The <a class="el" href="classnvh_1_1_shader_file_manager.html">nvh::ShaderFileManager</a> class is meant to be derived from to create the actual api-specific shader/program managers.</p>
<p>The ShaderFileManager provides a system to find/load shader files. It also allows resolving #include instructions in HLSL/GLSL source files. Such includes can be registered before pointing to strings in memory.</p>
<p>If m_handleIncludePasting is true, then <code>#include</code>s are replaced by the include file contents (recursively) before presenting the loaded shader source code to the caller. Otherwise, the include file loader is still available but <code>#include</code>s are left unchanged.</p>
<p>Furthermore it handles injecting prepended strings (typically used for #defines) after the #version statement of GLSL files, regardless of m_handleIncludePasting's value.</p>
<h1><a class="anchor" id="autotoc_md140"></a>
stacktrace.hpp</h1>
<h2><a class="anchor" id="autotoc_md141"></a>
function nvh::getStacktrace</h2>
<blockquote class="doxtable">
<p>Returns a string listing the function call stack at the current point. </p>
</blockquote>
<p><code>numFramesToSkip</code> is the number of frames around the call to <code>getStacktrace</code> to skip.</p>
<p>Returns "&lt;stacktrace not supported on this system&gt;" if there's no available backtrace backend. On internal error, returns an empty string.</p>
<h1><a class="anchor" id="autotoc_md142"></a>
threading.hpp</h1>
<h2><a class="anchor" id="autotoc_md143"></a>
class nvh::delayed_call</h2>
<p>Class returned by delay_noreturn_for to track the thread created and possibly reset the delay timer. Delay a call to a void function for sleep_duration.</p>
<p><code>return</code>: A delayed_call object that holds the running thread.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Create or update a delayed call to callback. Useful to consolidate multiple events into one call.</span></div>
<div class="line"><span class="keywordflow">if</span>(!m_delayedCall.delay_for(delay))</div>
<div class="line">  m_delayedCall = nvh::delay_noreturn_for(delay, callback);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md144"></a>
timesampler.hpp</h1>
<h2><a class="anchor" id="autotoc_md145"></a>
struct TimeSampler</h2>
<p><a class="el" href="struct_time_sampler.html">TimeSampler</a> does time sampling work </p>
<h2><a class="anchor" id="autotoc_md146"></a>
struct nvh::Stopwatch</h2>
<blockquote class="doxtable">
<p>Timer in milliseconds. </p>
</blockquote>
<p>Starts the timer at creation and the elapsed time is retrieved by calling <code>elapsed()</code>. The timer can be reset if it needs to start timing later in the code execution.</p>
<p>Usage: </p><div class="fragment"><div class="line">{</div>
<div class="line">  nvh::Stopwatch sw;</div>
<div class="line">  ... work ...</div>
<div class="line">  LOGI(<span class="stringliteral">&quot;Elapsed: %f ms\n&quot;</span>, sw.elapsed()); <span class="comment">// --&gt; Elapsed: 128.157 ms</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md147"></a>
trangeallocator.hpp</h1>
<h2><a class="anchor" id="autotoc_md148"></a>
class nvh::TRangeAllocator</h2>
<p>The nvh::TRangeAllocator&lt;GRANULARITY&gt; template allows to sub-allocate ranges from a fixed maximum size. Ranges are allocated at GRANULARITY and are merged back on freeing. Its primary use is within allocators that sub-allocate from fixed-size blocks.</p>
<p>The implementation is based on <a href="http://www.humus.name/3D/MakeID.h">MakeID by Emil Persson</a>.</p>
<p>Example :</p>
<div class="fragment"><div class="line">TRangeAllocator&lt;256&gt; range;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize to a certain range</span></div>
<div class="line">range.init(range.alignedSize(128 * 1024 * 1024));</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allocate a sub range</span></div>
<div class="line"><span class="comment">// example</span></div>
<div class="line">uint32_t size = vertexBufferSize;</div>
<div class="line">uint32_t alignment = vertexAlignment;</div>
<div class="line"> </div>
<div class="line">uint32_t allocOffset;</div>
<div class="line">uint32_t allocSize;</div>
<div class="line">uint32_t alignedOffset;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (range.subAllocate(size, alignment, allocOffset, alignedOffset, allocSize)) {</div>
<div class="line">  ... use the allocation space</div>
<div class="line">  <span class="comment">// [alignedOffset + size] is guaranteed to be within [allocOffset + allocSize]</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// give back the memory range for re-use</span></div>
<div class="line">range.subFree(allocOffset, allocSize);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// at the end cleanup</span></div>
<div class="line">range.deinit();</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:40 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
