<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: nvvkhl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacenvvkhl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nvvkhl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_nvml_monitor.html">NvmlMonitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_alloc_vma.html">AllocVma</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_app_swapchain.html">AppSwapchain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_queue_info.html">QueueInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_app_base.html">AppBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_i_app_element.html">IAppElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_application_create_info.html">ApplicationCreateInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_application.html">Application</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_benchmark_parameters.html">ElementBenchmarkParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_element_camera.html">ElementCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_dbg_printf.html">ElementDbgPrintf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_default_menu.html">ElementDefaultMenu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_default_window_title.html">ElementDefaultWindowTitle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_inspector_internal.html">ElementInspectorInternal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_inspector.html">ElementInspector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_average_circular_buffer.html">AverageCircularBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_element_nvml.html">ElementNvml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_profiler.html">ElementProfiler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_element_testing.html">ElementTesting</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_g_buffer.html">GBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_glsl_includer.html">GlslIncluder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_glsl_compiler.html">GlslCompiler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_scene_rtx.html">SceneRtx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_scene_vk.html">SceneVk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_hdr_env.html">HdrEnv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_hdr_env_dome.html">HdrEnvDome</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_pipeline_container.html">PipelineContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_sky_base.html">SkyBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_simple_sky_dome.html">SimpleSkyDome</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvvkhl_1_1_physical_sky_dome.html">PhysicalSkyDome</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnvvkhl_1_1_tonemapper_post_process.html">TonemapperPostProcess</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5734d9b6635afdabcd48a90f2b90db2a"><td class="memItemLeft" align="right" valign="top"><a id="a5734d9b6635afdabcd48a90f2b90db2a"></a>
VkCommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><b>beginSingleTimeCommands</b> (VkDevice device, VkCommandPool cmdPool)</td></tr>
<tr class="separator:a5734d9b6635afdabcd48a90f2b90db2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae590804c80e346526b4caeb9febedc50"><td class="memItemLeft" align="right" valign="top"><a id="ae590804c80e346526b4caeb9febedc50"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>endSingleTimeCommands</b> (VkCommandBuffer cmd, VkDevice device, VkCommandPool cmdPool, VkQueue queue)</td></tr>
<tr class="separator:ae590804c80e346526b4caeb9febedc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0423ae5f4449f1f914c8f8cf44025218"><td class="memTemplParams" colspan="2"><a id="a0423ae5f4449f1f914c8f8cf44025218"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0423ae5f4449f1f914c8f8cf44025218"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>addSurfaceExtensions</b> (std::vector&lt; T &gt; &amp;instanceExtensions)</td></tr>
<tr class="separator:a0423ae5f4449f1f914c8f8cf44025218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351888995caf387c2454c4af067cc1a5"><td class="memTemplParams" colspan="2"><a id="a351888995caf387c2454c4af067cc1a5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a351888995caf387c2454c4af067cc1a5"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createCopyName</b> (const std::string &amp;originalName, const std::vector&lt; T &gt; &amp;existingOriginals, const std::vector&lt; T &gt; &amp;copies)</td></tr>
<tr class="separator:a351888995caf387c2454c4af067cc1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e303727a367249f4ed4bb393ed2efd0"><td class="memItemLeft" align="right" valign="top"><a id="a3e303727a367249f4ed4bb393ed2efd0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>memoryBarrier</b> (VkCommandBuffer cmd)</td></tr>
<tr class="separator:a3e303727a367249f4ed4bb393ed2efd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ec584fdf8da74135a8f337e430a870"><td class="memItemLeft" align="right" valign="top"><a id="aa7ec584fdf8da74135a8f337e430a870"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>imguiPushActiveButtonStyle</b> (bool active)</td></tr>
<tr class="separator:aa7ec584fdf8da74135a8f337e430a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d436614787619005d1ff3ba5cf65767"><td class="memItemLeft" align="right" valign="top"><a id="a2d436614787619005d1ff3ba5cf65767"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>imguiPopActiveButtonStyle</b> ()</td></tr>
<tr class="separator:a2d436614787619005d1ff3ba5cf65767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68789949a388260fb187f1a1577aba31"><td class="memItemLeft" align="right" valign="top"><a id="a68789949a388260fb187f1a1577aba31"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkFormatFlag</b> (const std::vector&lt; <a class="el" href="structnvvkhl_1_1_element_inspector_1_1_value_format.html">ElementInspector::ValueFormat</a> &gt; &amp;format)</td></tr>
<tr class="separator:a68789949a388260fb187f1a1577aba31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8f5dc5f05e1951ae4fd5f44e96a262"><td class="memItemLeft" align="right" valign="top"><a id="aad8f5dc5f05e1951ae4fd5f44e96a262"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>sanitizeExtent</b> (glm::uvec3 &amp;extent)</td></tr>
<tr class="separator:aad8f5dc5f05e1951ae4fd5f44e96a262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a644f7a1c75d0352b8c0e3886284537"><td class="memItemLeft" align="right" valign="top"><a id="a6a644f7a1c75d0352b8c0e3886284537"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>tooltip</b> (const std::string &amp;text, ImGuiHoveredFlags flags=ImGuiHoveredFlags_DelayNormal)</td></tr>
<tr class="separator:a6a644f7a1c75d0352b8c0e3886284537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853ff2749875f6b08f13665e4881c199"><td class="memTemplParams" colspan="2"><a id="a853ff2749875f6b08f13665e4881c199"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a853ff2749875f6b08f13665e4881c199"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>updateFormat</b> (T &amp;inspection, const std::vector&lt; <a class="el" href="structnvvkhl_1_1_element_inspector_internal_1_1_value_format.html">nvvkhl::ElementInspectorInternal::ValueFormat</a> &gt; &amp;newFormat)</td></tr>
<tr class="separator:a853ff2749875f6b08f13665e4881c199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eb35ee2334b48a347e205bf1daf917"><td class="memTemplParams" colspan="2"><a id="ab7eb35ee2334b48a347e205bf1daf917"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7eb35ee2334b48a347e205bf1daf917"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imguiCopy</b> (<a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a> *app, T &amp;src, const std::vector&lt; T &gt; &amp;existingOriginals, std::vector&lt; T &gt; &amp;copies)</td></tr>
<tr class="separator:ab7eb35ee2334b48a347e205bf1daf917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b904135aba764b62c5ddf478d51d2e"><td class="memItemLeft" align="right" valign="top"><a id="a20b904135aba764b62c5ddf478d51d2e"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>imguiButton</b> (const std::string &amp;text, const std::string &amp;tooltipText, bool useActiveButtonStyle, bool isActive, bool useIconic, bool enlargeFont, ImVec2 buttonSize=ImVec2(0, 0))</td></tr>
<tr class="separator:a20b904135aba764b62c5ddf478d51d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d60ddd4b33ee2430d7db0ed2c4f002"><td class="memTemplParams" colspan="2"><a id="a60d60ddd4b33ee2430d7db0ed2c4f002"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a60d60ddd4b33ee2430d7db0ed2c4f002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imguiElementShowButtons</b> (std::vector&lt; T &gt; &amp;elements, std::vector&lt; T &gt; &amp;elementsCopies)</td></tr>
<tr class="separator:a60d60ddd4b33ee2430d7db0ed2c4f002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf7142f5217947d3c001ff3a0cb4556"><td class="memTemplParams" colspan="2"><a id="afcf7142f5217947d3c001ff3a0cb4556"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afcf7142f5217947d3c001ff3a0cb4556"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imguiElementShowImageButtons</b> (std::vector&lt; T &gt; &amp;elements, std::vector&lt; T &gt; &amp;elementsCopies)</td></tr>
<tr class="separator:afcf7142f5217947d3c001ff3a0cb4556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87756c8d39411d08dc0f7fe9356a446a"><td class="memItemLeft" align="right" valign="top"><a id="a87756c8d39411d08dc0f7fe9356a446a"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCapturedBlockIndex</b> (uint32_t absoluteBlockIndex, const glm::uvec3 &amp;gridSize, const glm::uvec3 &amp;minBlock, const glm::uvec3 &amp;maxBlock)</td></tr>
<tr class="separator:a87756c8d39411d08dc0f7fe9356a446a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763370ed80fe45c56c07fac354228870"><td class="memItemLeft" align="right" valign="top"><a id="a763370ed80fe45c56c07fac354228870"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>wangHash</b> (uint32_t seed)</td></tr>
<tr class="separator:a763370ed80fe45c56c07fac354228870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60fc47e37a39f450a9af6f98a3fafd4"><td class="memTemplParams" colspan="2"><a id="ae60fc47e37a39f450a9af6f98a3fafd4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae60fc47e37a39f450a9af6f98a3fafd4"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>colorFromValue</b> (const T &amp;v)</td></tr>
<tr class="separator:ae60fc47e37a39f450a9af6f98a3fafd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d5a21dfbfe8e6a9fc4043f9f34cd14"><td class="memItemLeft" align="right" valign="top"><a id="a16d5a21dfbfe8e6a9fc4043f9f34cd14"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>imguiBufferCell</b> (const uint8_t *content, const <a class="el" href="structnvvkhl_1_1_element_inspector_internal_1_1_value_format.html">ElementInspectorInternal::ValueFormat</a> &amp;format, std::string &amp;outString, ImU32 &amp;outBackgroundColor)</td></tr>
<tr class="separator:a16d5a21dfbfe8e6a9fc4043f9f34cd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224dc6378bce3548e21271c2677c9ff1"><td class="memItemLeft" align="right" valign="top"><a id="a224dc6378bce3548e21271c2677c9ff1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatType</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a224dc6378bce3548e21271c2677c9ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f9bb22c5efd4a4c93feb45f2b27c6a"><td class="memTemplParams" colspan="2"><a id="a27f9bb22c5efd4a4c93feb45f2b27c6a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27f9bb22c5efd4a4c93feb45f2b27c6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sanitizeFilterMax</b> (uint8_t *minValue, uint8_t *maxValue)</td></tr>
<tr class="separator:a27f9bb22c5efd4a4c93feb45f2b27c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396cf016d322fdbd2e3a50a023f7b650"><td class="memItemLeft" align="right" valign="top"><a id="a396cf016d322fdbd2e3a50a023f7b650"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sanitizeFilterBounds</b> (const std::vector&lt; <a class="el" href="structnvvkhl_1_1_element_inspector_internal_1_1_value_format.html">ElementInspectorInternal::ValueFormat</a> &gt; &amp;format, uint8_t *filterMin, uint8_t *filterMax)</td></tr>
<tr class="separator:a396cf016d322fdbd2e3a50a023f7b650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98836f8626dd663baba8385f98f2661"><td class="memItemLeft" align="right" valign="top"><a id="aa98836f8626dd663baba8385f98f2661"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>metricFormatter</b> (double value, char *buff, int size, void *data)</td></tr>
<tr class="separator:aa98836f8626dd663baba8385f98f2661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ec237de2e7629008add7c535e27e3c"><td class="memItemLeft" align="right" valign="top"><a id="a64ec237de2e7629008add7c535e27e3c"></a>
std::vector&lt; nvvkhl_shaders::EnvAccel &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createEnvironmentAccel</b> (float *&amp;pixels, const uint32_t &amp;width, const uint32_t &amp;height, float &amp;average, float &amp;integral)</td></tr>
<tr class="separator:a64ec237de2e7629008add7c535e27e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb047c453f301e8d26480fa12528587"><td class="memItemLeft" align="right" valign="top"><a id="aacb047c453f301e8d26480fa12528587"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>buildAliasmap</b> (const std::vector&lt; float &gt; &amp;data, std::vector&lt; nvvkhl_shaders::EnvAccel &gt; &amp;accel)</td></tr>
<tr class="separator:aacb047c453f301e8d26480fa12528587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9b7ae1280e2f2a82be151f203550ee"><td class="memItemLeft" align="right" valign="top"><a id="a3e9b7ae1280e2f2a82be151f203550ee"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>luminance</b> (const float *color)</td></tr>
<tr class="separator:a3e9b7ae1280e2f2a82be151f203550ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98091a31da506a69def3f35716d2bd3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenvvkhl.html#a98091a31da506a69def3f35716d2bd3b">setCameraFromScene</a> (const std::string &amp;m_filename, const nvh::GltfScene &amp;m_scene)</td></tr>
<tr class="separator:a98091a31da506a69def3f35716d2bd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd8eb8158b650c868f4b538c59a7601"><td class="memItemLeft" align="right" valign="top"><a id="a3bd8eb8158b650c868f4b538c59a7601"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setCamera</b> (const std::string &amp;m_filename, const std::vector&lt; <a class="el" href="structnvh_1_1gltf_1_1_render_camera.html">nvh::gltf::RenderCamera</a> &gt; &amp;cameras, const <a class="el" href="structnvh_1_1_bbox.html">nvh::Bbox</a> &amp;sceneBbox)</td></tr>
<tr class="separator:a3bd8eb8158b650c868f4b538c59a7601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b416018fa1e21eea20dd74088efa308"><td class="memItemLeft" align="right" valign="top"><a id="a8b416018fa1e21eea20dd74088efa308"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>skyParametersUI</b> (nvvkhl_shaders::SimpleSkyParameters &amp;params)</td></tr>
<tr class="separator:a8b416018fa1e21eea20dd74088efa308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0bcb5b257233244c2f5919424530ff"><td class="memItemLeft" align="right" valign="top"><a id="a8e0bcb5b257233244c2f5919424530ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>physicalSkyUI</b> (nvvkhl_shaders::PhysicalSkyParameters &amp;params)</td></tr>
<tr class="separator:a8e0bcb5b257233244c2f5919424530ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9e115782117081a15d8fa5537689cd4b"><td class="memItemLeft" align="right" valign="top"><a id="a9e115782117081a15d8fa5537689cd4b"></a>
static const ImVec4&#160;</td><td class="memItemRight" valign="bottom"><b>highlightColor</b> = ImVec4(118.f / 255.f, 185.f / 255.f, 0.f, 1.f)</td></tr>
<tr class="separator:a9e115782117081a15d8fa5537689cd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094bdd0ddcaceea75221d03b0f0f8ada"><td class="memItemLeft" align="right" valign="top"><a id="a094bdd0ddcaceea75221d03b0f0f8ada"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>isActiveButtonPushed</b> = false</td></tr>
<tr class="separator:a094bdd0ddcaceea75221d03b0f0f8ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@DOC_START</p>
<p>Capture the GPU load and memory for all GPUs on the system.</p>
<p>Usage:</p><ul>
<li>There should be only one instance of <a class="el" href="classnvvkhl_1_1_nvml_monitor.html">NvmlMonitor</a></li>
<li>call refresh() in each frame. It will not pull more measurement that the interval(ms)</li>
<li>isValid() : return if it can be used</li>
<li>nbGpu() : return the number of GPU in the computer</li>
<li>getGpuInfo() : static info about the GPU</li>
<li>getDeviceMemory() : memory consumption info</li>
<li>getDeviceUtilization() : GPU and memory utilization</li>
<li>getDevicePerformanceState() : clock speeds and throttle reasons</li>
<li>getDevicePowerState() : power, temperature and fan speed</li>
</ul>
<p>Measurements:</p><ul>
<li>Uses a cycle buffer.</li>
<li>Offset is the last measurement</li>
</ul>
<p>@DOC_END</p>
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md325"></a>
class nvvkhl::ElementCamera</h1>
<p>This class is an element of the application that is responsible for the camera manipulation. It is using the <code>nvh::CameraManipulator</code> to handle the camera movement and interaction.</p>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<p>@DOC_END</p>
<p>@DOC_START</p>
<h1><a class="anchor" id="autotoc_md329"></a>
class nvvkhl::ElementInspector</h1>
<hr  />
<p> This element is used to facilitate GPU debugging by inspection of:</p><ul>
<li>Image contents</li>
<li>Buffer contents</li>
<li>Variables in compute shaders</li>
<li>Variables in fragment shaders</li>
</ul>
<p>IMPORTANT NOTE: if used in a multi threaded environment synchronization needs to be performed externally by the application.</p>
<h2><a class="anchor" id="autotoc_md331"></a>
Basic usage:</h2>
<h2><a class="anchor" id="autotoc_md332"></a>
###                 INITIALIZATION</h2>
<p>Create the element as a global variable, and add it to the applications </p><div class="fragment"><div class="line">std::shared_ptr&lt;ElementInspector&gt; g_inspectorElement = std::make_shared&lt;ElementInspector&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> main(...)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  app-&gt;addElement(g_inspectorElement);</div>
<div class="line">  ...</div>
<div class="line"> }</div>
</div><!-- fragment --><p> Upon attachment of the main app element, initialize the Inspector and specify the number of buffers, images, compute shader variables and fragment shader variables that it will need to inspect </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> onAttach(<a class="code" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a>* app)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  ...</div>
<div class="line">   ElementInspector::InitInfo initInfo{};</div>
<div class="line">   initInfo.allocator     = m_alloc.get();</div>
<div class="line">   initInfo.imageCount    = imageInspectionCount;</div>
<div class="line">   initInfo.bufferCount   = bufferInspectionCount;</div>
<div class="line">   initInfo.computeCount  = computeInspectionCount;</div>
<div class="line">   initInfo.fragmentCount = fragmentInspectionCount;</div>
<div class="line">   initInfo.customCount   = customInspectionCount;</div>
<div class="line">   initInfo.device = m_app-&gt;getDevice();</div>
<div class="line">   initInfo.graphicsQueueFamilyIndex = m_app-&gt;getQueueGCT().familyIndex;</div>
<div class="line"> </div>
<div class="line">   g_inspectorElement-&gt;init(initInfo);</div>
<div class="line">  ...</div>
<div class="line"> }</div>
<div class="ttc" id="aclassnvvkhl_1_1_application_html"><div class="ttname"><a href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></div><div class="ttdef"><b>Definition:</b> application.hpp:163</div></div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md334"></a>
###                 BUFFER INSPECTION</h2>
<p>Each inspection needs to be initialized before use: Inspect a buffer of size bufferSize, where each entry contains 5 values. The buffer format specifies the data structure of the entries. The following format is the equivalent of </p><div class="fragment"><div class="line"><span class="keyword">struct</span></div>
<div class="line">{</div>
<div class="line">uint32_t counterU32;</div>
<div class="line"><span class="keywordtype">float</span>    counterF32;</div>
<div class="line">int16_t  anI16Value;</div>
<div class="line">uint16_t myU16;</div>
<div class="line">int32_t  anI32;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">bufferFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(5);</div>
<div class="line">bufferFormat[0] = {ElementInspector::eUint32, <span class="stringliteral">&quot;counterU32&quot;</span>};</div>
<div class="line">bufferFormat[1] = {ElementInspector::eFloat32, <span class="stringliteral">&quot;counterF32&quot;</span>};</div>
<div class="line">bufferFormat[2] = {ElementInspector::eInt16, <span class="stringliteral">&quot;anI16Value&quot;</span>};</div>
<div class="line">bufferFormat[3] = {ElementInspector::eUint16, <span class="stringliteral">&quot;myU16&quot;</span>};</div>
<div class="line">bufferFormat[4] = {ElementInspector::eInt32, <span class="stringliteral">&quot;anI32&quot;</span>};</div>
<div class="line">ElementInspector::BufferInspectionInfo info{};</div>
<div class="line">info.entryCount   = bufferSize;</div>
<div class="line">info.format       = bufferFormat;</div>
<div class="line">info.name         = <span class="stringliteral">&quot;myBuffer&quot;</span>;</div>
<div class="line">info.sourceBuffer = m_buffer.buffer;</div>
<div class="line">g_inspectorElement-&gt;initBufferInspection(0, info);</div>
</div><!-- fragment --><p>When the inspection is desired, simply add it to the current command buffer. Required barriers are added internally. IMPORTANT: the buffer MUST have been created with the VK_BUFFER_USAGE_TRANSFER_SRC_BIT flag </p><div class="fragment"><div class="line">g_inspectorElement-&gt;inspectBuffer(cmd, 0);</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md336"></a>
###                 IMAGE INSPECTION</h2>
<p>Inspection of the image stored in m_texture, with format RGBA32F. Other formats can be specified using the syntax above </p><div class="fragment"><div class="line">ElementInspector::ImageInspectionInfo info{};</div>
<div class="line">info.createInfo  = create_info;</div>
<div class="line">info.format      = g_inspectorElement-&gt;formatRGBA32();</div>
<div class="line">info.name        = <span class="stringliteral">&quot;MyImageInspection&quot;</span>;</div>
<div class="line">info.sourceImage = m_texture.image;</div>
<div class="line">g_inspectorElement-&gt;initImageInspection(0, info);</div>
</div><!-- fragment --><p>When the inspection is desired, simply add it to the current command buffer. Required barriers are added internally. </p><div class="fragment"><div class="line">g_inspectorElement-&gt;inspectImage(cmd, 0, imageCurrentLayout);</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md338"></a>
###                 COMPUTE SHADER VARIABLE INSPECTION</h2>
<p>Inspect a compute shader variable for a given 3D grid and block size (use 1 for unused dimensions). This mode applies to shaders where invocation IDs (e.g. gl_LocalInvocationID) are defined, such as compute, mesh and task shaders. Since grids may contain many threads capturing a variable for all threads may incur large memory consumption and performance loss. The blocks to inspect, and the warps within those blocks can be specified using inspectedMin/MaxBlocks and inspectedMin/MaxWarp. </p><div class="fragment"><div class="line">computeInspectionFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(...); </div>
<div class="line">ElementInspector::ComputeInspectionInfo info{}; info.blockSize = blockSize;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a 4-component vector format where each component is a uint32_t. The components will be labeled myVec4u.x,</span></div>
<div class="line"><span class="comment">// myVec4u.y, myVec4u.z, myVec4u.w in the UI </span></div>
<div class="line">info.format           = ElementInspector::formatVector4(eUint32, <span class="stringliteral">&quot;myVec4u&quot;</span>); </div>
<div class="line">info.gridSizeInBlocks = gridSize; </div>
<div class="line">info.minBlock         = inspectedMinBlock; </div>
<div class="line">info.maxBlock         = inspectedMaxBlock; </div>
<div class="line">info.minWarp          = inspectedMinWarp; </div>
<div class="line">info.maxWarp          = inspectedMaxWarp; </div>
<div class="line">info.name             = <span class="stringliteral">&quot;My Compute Inspection&quot;</span>; </div>
<div class="line">g_inspectorElement-&gt;initComputeInspection(0, info);</div>
</div><!-- fragment --><p>To allow variable inspection two buffers need to be made available to the target shader: m_computeShader.updateBufferBinding(eThreadInspection, g_inspectorElement-&gt;getComputeInspectionBuffer(0)); m_computeShader.updateBufferBinding(eThreadMetadata, g_inspectorElement-&gt;getComputeMetadataBuffer(0));</p>
<p>The shader code needs to indicate include the Inspector header along with preprocessor variables to set the inspection mode to Compute, and indicate the binding points for the buffers: </p><div class="fragment"><div class="line"><span class="preprocessor">#define INSPECTOR_MODE_COMPUTE </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_DESCRIPTOR_SET 0 </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_INSPECTION_DATA_BINDING 1 </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_METADATA_BINDING 2 </span></div>
<div class="line"><span class="preprocessor">#include &quot;dh_inspector.h&quot;</span></div>
</div><!-- fragment --><p>The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be unpacked within the Inspector for display according to the specified format. </p><div class="fragment"><div class="line">uint32_t myVariable = myFunction(...);</div>
<div class="line">inspect32BitValue(0, myVariable);</div>
</div><!-- fragment --><p>The inspection is triggered on the host side right after the compute shader invocation: </p><div class="fragment"><div class="line">m_computeShader.dispatchBlocks(cmd, computGridSize, &amp;constants);</div>
<div class="line"> </div>
<div class="line">g_inspectorElement-&gt;inspectComputeVariables(cmd, 0);</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md340"></a>
###                 FRAGMENT SHADER VARIABLE INSPECTION</h2>
<p>Inspect a fragment shader variable for a given output image resolution. Since the image may have high resolution capturing a variable for all threads may incur large memory consumption and performance loss. The bounding box of the fragments to inspect can be specified using inspectedMin/MaxCoord. IMPORTANT: Overlapping geometry may trigger several fragment shader invocations for a given pixel. The inspection will only store the value of the foremost fragment (with the lowest gl_FragCoord.z). </p><div class="fragment"><div class="line">fragmentInspectionFormat    = std::vector&lt;ElementInspector::ValueFormat&gt;(...); </div>
<div class="line">FragmentInspectionInfo info{}; </div>
<div class="line">info.name        = <span class="stringliteral">&quot;My Fragment Inspection&quot;</span>;</div>
<div class="line">info.format      = fragmentInspectionFormat;</div>
<div class="line">info.renderSize  = imageSize;</div>
<div class="line">info.minFragment = inspectedMinCoord;</div>
<div class="line">info.maxFragment = inspectedMaxCoord;</div>
<div class="line">g_inspectorElement-&gt;initFragmentInspection(0, info);</div>
</div><!-- fragment --><p>To allow variable inspection two storage buffers need to be declared in the pipeline layout and made available as follows: </p><div class="fragment"><div class="line">std::vector&lt;VkWriteDescriptorSet&gt; writes;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo inspectorInspection{</div>
<div class="line">   g_inspectorElement-&gt;getFragmentInspectionBuffer(0), </div>
<div class="line">   0, </div>
<div class="line">   VK_WHOLE_SIZE}; </div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 1, &amp;inspectorInspection)); </div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo inspectorMetadata{</div>
<div class="line">   g_inspectorElement-&gt;getFragmentMetadataBuffer(0), </div>
<div class="line">   0, </div>
<div class="line">   VK_WHOLE_SIZE};</div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 2, &amp;inspectorMetadata));</div>
<div class="line"> </div>
<div class="line">vkUpdateDescriptorSets(m_device, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(writes.size()), writes.data(), 0, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>The shader code needs to indicate include the Inspector header along with preprocessor variables to set the inspection mode to Fragment, and indicate the binding points for the buffers: </p><div class="fragment"><div class="line"><span class="preprocessor">#define INSPECTOR_MODE_FRAGMENT </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_DESCRIPTOR_SET 0 </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_INSPECTION_DATA_BINDING 1 </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_METADATA_BINDING 2 </span></div>
<div class="line"><span class="preprocessor">#include &quot;dh_inspector.h&quot;</span></div>
</div><!-- fragment --><p>The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be unpacked within the Inspector for display according to the specified format. </p><div class="fragment"><div class="line">uint32_t myVariable = myFunction(...);</div>
<div class="line">inspect32BitValue(0, myVariable);</div>
</div><!-- fragment --><p>The inspection data for a pixel will only be written if a fragment actually covers that pixel. To avoid ghosting where no fragments are rendered it is useful to clear the inspection data before rendering: </p><div class="fragment"><div class="line">g_inspectorElement-&gt;clearFragmentVariables(cmd, 0);</div>
<div class="line">vkCmdBeginRendering(...);</div>
</div><!-- fragment --><p>The inspection is triggered on the host side right after rendering: </p><div class="fragment"><div class="line">vkCmdEndRendering(cmd);</div>
<div class="line">g_inspectorElement-&gt;inspectFragmentVariables(cmd, 0);</div>
</div><!-- fragment --><hr  />
 <h2><a class="anchor" id="autotoc_md342"></a>
###                 CUSTOM SHADER VARIABLE INSPECTION</h2>
<p>In case some in-shader data has to be inspected in other shader types, or not on a once-per-thread basis, the custom inspection mode can be used. This mode allows the user to specify the overall size of the generated data as well as an effective inspection window. This mode may be used in conjunction with the COMPUTE and FRAGMENT modes. std::vector&lt;ElementInspector::ValueFormat&gt; customCaptureFormat; </p><div class="fragment"><div class="line">...</div>
<div class="line">ElementInspector::CustomInspectionInfo info{};</div>
<div class="line">info.extent   = totalInspectionSize;</div>
<div class="line">info.format   = customCaptureFormat;</div>
<div class="line">info.minCoord = inspectionWindowMin;</div>
<div class="line">info.maxCoord = inspectionWindowMax;</div>
<div class="line">info.name     = <span class="stringliteral">&quot;My Custom Capture&quot;</span>;</div>
<div class="line">g_inspectorElement-&gt;initCustomInspection(0, info);</div>
</div><!-- fragment --><p>To allow variable inspection two buffers need to be made available to the target pipeline: </p><div class="fragment"><div class="line">std::vector&lt;VkWriteDescriptorSet&gt; writes;</div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo      inspectorInspection{</div>
<div class="line">   g_inspectorElement-&gt;getCustomInspectionBuffer(0), </div>
<div class="line">   0,</div>
<div class="line">   VK_WHOLE_SIZE}; </div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 1, &amp;inspectorInspection)); </div>
<div class="line"><span class="keyword">const</span> VkDescriptorBufferInfo inspectorMetadata{</div>
<div class="line">   g_inspectorElement-&gt;getCustomMetadataBuffer(0), </div>
<div class="line">   0, </div>
<div class="line">   VK_WHOLE_SIZE};</div>
<div class="line">writes.emplace_back(m_dset-&gt;makeWrite(0, 2, &amp;inspectorMetadata));</div>
<div class="line"> </div>
<div class="line">vkUpdateDescriptorSets(m_device, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(writes.size()), writes.data(), 0, <span class="keyword">nullptr</span>);</div>
</div><!-- fragment --><p>The shader code needs to indicate include the Inspector header along with preprocessor variables to set the inspection mode to Fragment, and indicate the binding points for the buffers: </p><div class="fragment"><div class="line"><span class="preprocessor">#define INSPECTOR_MODE_CUSTOM </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_DESCRIPTOR_SET 0 </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_CUSTOM_INSPECTION_DATA_BINDING 1 </span></div>
<div class="line"><span class="preprocessor">#define INSPECTOR_CUSTOM_METADATA_BINDING 2 </span></div>
<div class="line"><span class="preprocessor">#include &quot;dh_inspector.h&quot;</span></div>
</div><!-- fragment --><p> The inspection of a variable is then done as follows. For alignment purposes the inspection is done with a 32-bit granularity. The shader is responsible for packing the inspected variables in 32-bit uint words. Those will be unpacked within the Inspector for display according to the specified format. </p><div class="fragment"><div class="line">uint32_t myVariable = myFunction(...);</div>
<div class="line">inspectCustom32BitValue(0, myCoordinates, myVariable);</div>
</div><!-- fragment --><p>The inspection is triggered on the host side right after running the pipeline: </p><div class="fragment"><div class="line">g_inspectorElement-&gt;inspectCustomVariables(cmd, 0);</div>
</div><!-- fragment --><p> @DOC_END</p>
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md343"></a>
class nvvkhl::ElementNvml</h1>
<blockquote class="doxtable">
<p>This class is an element of the application that is responsible for the NVML monitoring. It is using the <code>NVML</code> library to get information about the GPU and display it in the application. </p>
</blockquote>
<p>To use this class, you need to add it to the <code><a class="el" href="classnvvkhl_1_1_application.html">nvvkhl::Application</a></code> using the <code>addElement</code> method.</p>
<p>@DOC_END</p>
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md345"></a>
class nvvkhl::GBuffer</h1>
<blockquote class="doxtable">
<p>This class is an help for creating GBuffers. </p>
</blockquote>
<p>This can be use to create a <a class="el" href="classnvvkhl_1_1_g_buffer.html">GBuffer</a> with multiple color images and a depth image. The <a class="el" href="classnvvkhl_1_1_g_buffer.html">GBuffer</a> can be used to render the scene in multiple passes, such as deferred rendering.</p>
<p>To use this class, you need to create it and call the <code>create</code> method to create the <a class="el" href="classnvvkhl_1_1_g_buffer.html">GBuffer</a>. The <code>create</code> method will create the images and the descriptor set for the <a class="el" href="classnvvkhl_1_1_g_buffer.html">GBuffer</a>. The <code>destroy</code> method will destroy the images and the descriptor set.</p>
<p>Note: the <code>getDescriptorSet</code> method can be use to display the image in <a class="el" href="namespace_im_gui.html" title="@DOC_SKIP (keyword to exclude this file from automatic README.md generation)">ImGui</a>. Ex: <code>ImGui::Image((ImTextureID)gbuffer.getDescriptorSet(), ImVec2(128, 128));</code> @DOC_END</p>
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md346"></a>
class nvvkhl::GlslCompiler</h1>
<blockquote class="doxtable">
<p>This class is a wrapper around the shaderc compiler to help compiling GLSL to Spir-V using shaderC </p>
</blockquote>
<p>@DOC_END</p>
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md347"></a>
class nvvkhl::SceneRtx</h1>
<blockquote class="doxtable">
<p>This class is responsible for the ray tracing acceleration structure. </p>
</blockquote>
<p>It is using the <code><a class="el" href="classnvh_1_1gltf_1_1_scene.html">nvh::gltf::Scene</a></code> and <code><a class="el" href="classnvvkhl_1_1_scene_vk.html">nvvkhl::SceneVk</a></code> information to create the acceleration structure.</p>
<p>@DOC_END</p>
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md348"></a>
class nvvkhl::SceneVk</h1>
<blockquote class="doxtable">
<p>This class is responsible for the Vulkan version of the scene. </p>
</blockquote>
<p>It is using <code>nvvkhl::Scene</code> to create the Vulkan buffers and images.</p>
<p>@DOC_END </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a98091a31da506a69def3f35716d2bd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98091a31da506a69def3f35716d2bd3b">&#9670;&nbsp;</a></span>setCameraFromScene()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nvvkhl::setCameraFromScene </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>m_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nvh::GltfScene &amp;&#160;</td>
          <td class="paramname"><em>m_scene</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md420"></a>
Function nvvkhl::setCameraFromScene</h1>
<blockquote class="doxtable">
<p>Set the camera from the scene, if no camera is found, it will fit the camera to the scene. </p>
</blockquote>
<p>@DOC_END </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvvkhl.html">nvvkhl</a></li>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:50 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
