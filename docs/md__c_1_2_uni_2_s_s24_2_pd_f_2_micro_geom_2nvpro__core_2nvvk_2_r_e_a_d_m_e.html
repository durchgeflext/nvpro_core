<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nvpro_core<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_uni_2_s_s24_2_pd_f_2_micro_geom_2nvpro__core_2nvvk_2_r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Table of Contents</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md185"></a></p><ul>
<li>acceleration_structures.hpp</li>
<li>appwindowprofiler_vk.hpp</li>
<li>buffersuballocator_vk.hpp</li>
<li>buffers_vk.hpp</li>
<li>commands_vk.hpp</li>
<li>compute_vk.hpp</li>
<li>context_vk.hpp</li>
<li>debug_util_vk.hpp</li>
<li>descriptorsets_vk.hpp</li>
<li>dynamicrendering_vk.hpp</li>
<li>error_vk.hpp</li>
<li>gizmos_vk.hpp</li>
<li>images_vk.hpp</li>
<li>memallocator_dedicated_vk.hpp</li>
<li>memallocator_dma_vk.hpp</li>
<li>memallocator_vk.hpp</li>
<li>memallocator_vma_vk.hpp</li>
<li>memorymanagement_vk.hpp</li>
<li>memorymanagement_vkgl.hpp</li>
<li>pipeline_vk.hpp</li>
<li>profiler_vk.hpp</li>
<li>raypicker_vk.hpp</li>
<li>raytraceKHR_vk.hpp</li>
<li>raytraceNV_vk.hpp</li>
<li>renderpasses_vk.hpp</li>
<li>resourceallocator_vk.hpp</li>
<li>samplers_vk.hpp</li>
<li>sbtwrapper_vk.hpp</li>
<li>shadermodulemanager_vk.hpp</li>
<li>shaders_vk.hpp</li>
<li>sparse_image_vk.hpp</li>
<li>specialization.hpp</li>
<li>stagingmemorymanager_vk.hpp</li>
<li>swapchain_vk.hpp</li>
<li>vulkanhppsupport.hpp</li>
<li>vulkanhppsupport_vkgl.hpp</li>
</ul>
<h1><a class="anchor" id="autotoc_md186"></a>
acceleration_structures.hpp</h1>
<h2><a class="anchor" id="autotoc_md187"></a>
<code>nvvk::accelerationStructureBarrier</code> Function</h2>
<p>This function sets up a memory barrier specifically for acceleration structure operations in Vulkan, ensuring proper data synchronization during the build or update phases. It operates between pipeline stages that deal with acceleration structure building.</p>
<h2><a class="anchor" id="autotoc_md188"></a>
<code>nvvk::toTransformMatrixKHR</code> Function</h2>
<p>This function converts a <code>glm::mat4</code> matrix to the matrix format required by acceleration structures in Vulkan.</p>
<h2><a class="anchor" id="autotoc_md189"></a>
<code>nvvk::AccelerationStructureGeometryInfo</code> Structure</h2>
<ul>
<li><b>Purpose</b>: Holds information about acceleration structure geometry, including the geometry structure and build range information.</li>
</ul>
<h2><a class="anchor" id="autotoc_md190"></a>
<code>nvvk::AccelerationStructureBuildData</code> Structure</h2>
<ul>
<li><b>Purpose</b>: Manages the building of Vulkan acceleration structures of a specified type.</li>
<li><b>Key Functions</b>:<ul>
<li><code>addGeometry</code>: Adds a geometry with build range information to the acceleration structure.</li>
<li><code>finalizeGeometry</code>: Configures the build information and calculates the necessary size information.</li>
<li><code>makeCreateInfo</code>: Creates an acceleration structure based on the current build and size information.</li>
<li><code>cmdBuildAccelerationStructure</code>: Builds the acceleration structure in a Vulkan command buffer.</li>
<li><code>cmdUpdateAccelerationStructure</code>: Updates the acceleration structure in a Vulkan command buffer.</li>
<li><code>hasCompactFlag</code>: Checks if the compact flag is set for the build.</li>
</ul>
</li>
<li><b>Usage</b>:<ul>
<li>For each BLAS,<ul>
<li>Add geometry using <code>addGeometry</code>.</li>
<li>Finalize the geometry and get the size requirements using <code>finalizeGeometry</code>.</li>
<li>Keep the max scratch buffer size in mind when creating the scratch buffer.</li>
</ul>
</li>
<li>Create Scratch Buffer using the information returned by finalizeGeometry.</li>
<li>For each BLAS,<ul>
<li>Create the acceleration structure using <code>makeCreateInfo</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md191"></a>
appwindowprofiler_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md192"></a>
class nvvk::AppWindowProfilerVK</h2>
<p><a class="el" href="classnvvk_1_1_app_window_profiler_v_k.html">nvvk::AppWindowProfilerVK</a> derives from <a class="el" href="classnvh_1_1_app_window_profiler.html">nvh::AppWindowProfiler</a> and overrides the context and swapbuffer functions. The nvh class itself provides several utilities and command line options to run automated benchmarks etc.</p>
<p>To influence the vulkan instance/device creation modify <code>m_contextInfo</code> prior running AppWindowProfiler::run, which triggers instance, device, window, swapchain creation etc.</p>
<p>The class comes with a <a class="el" href="classnvvk_1_1_profiler_v_k.html">nvvk::ProfilerVK</a> instance that references the AppWindowProfiler::m_profiler's data.</p>
<h1><a class="anchor" id="autotoc_md193"></a>
buffersuballocator_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md194"></a>
class nvvk::BufferSubAllocator</h2>
<p><a class="el" href="classnvvk_1_1_buffer_sub_allocator.html">nvvk::BufferSubAllocator</a> provides buffer sub allocation using larger buffer blocks. The blocks are one VkBuffer each and are allocated via the provided nvvk::MemAllocator.</p>
<p>The requested buffer space is sub-allocated and recycled in blocks internally. This way we avoid creating lots of small VkBuffers and can avoid calling the Vulkan API at all, when there are blocks with sufficient empty space. While Vulkan is more efficient than previous APIs, creating lots of objects for it, is still not good for overall performance. It will result into more cache misses and use more system memory over all.</p>
<p>Be aware that each sub-allocation is always BASE_ALIGNMENT aligned. A custom alignment during allocation can be requested, it will ensure that the returned sub-allocation range of offset &amp; size can account for the original requested size fitting within and respecting the requested</p>
<p>This, however, means the regular offset and may not match the requested alignment, and the regular size can be bigger to account for the shift caused by manual alignment.</p>
<p>It is therefore necessary to pass the alignment that was used at allocation time to the query functions as well.</p>
<div class="fragment"><div class="line"><span class="comment">// alignment &lt;= BASE_ALIGNMENT</span></div>
<div class="line">    handle  = subAllocator.subAllocate(size);</div>
<div class="line">    binding = subAllocator.getSubBinding(handle);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// alignment &gt; BASE_ALIGNMENT</span></div>
<div class="line">    handle  = subAllocator.subAllocate(size, alignment);</div>
<div class="line">    binding = subAllocator.getSubBinding(handle, alignment);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md195"></a>
buffers_vk.hpp</h1>
<p>The utilities in this file provide a more direct approach, we encourage to use higher-level mechanisms also provided in the allocator / memorymanagement classes.</p>
<h2><a class="anchor" id="autotoc_md196"></a>
functions in nvvk</h2>
<ul>
<li>makeBufferCreateInfo : wraps setup of VkBufferCreateInfo (implicitly sets VK_BUFFER_USAGE_TRANSFER_DST_BIT)</li>
<li>makeBufferViewCreateInfo : wraps setup of VkBufferViewCreateInfo</li>
<li>createBuffer : wraps vkCreateBuffer</li>
<li>createBufferView : wraps vkCreateBufferView</li>
<li>getBufferDeviceAddressKHR : wraps vkGetBufferDeviceAddressKHR</li>
<li>getBufferDeviceAddress : wraps vkGetBufferDeviceAddress</li>
</ul>
<div class="fragment"><div class="line">VkBufferCreateInfo bufferCreate = makeBufferCreateInfo (size, VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT);</div>
<div class="line">VkBuffer buffer                 = createBuffer(device, bufferCreate);</div>
<div class="line">VkBufferView bufferView         = createBufferView(device, makeBufferViewCreateInfo(buffer, VK_FORMAT_R8G8B8A8_UNORM, size));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md197"></a>
commands_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md198"></a>
functions in nvvk</h2>
<ul>
<li>makeAccessMaskPipelineStageFlags : depending on accessMask returns appropriate VkPipelineStageFlagBits</li>
<li>cmdBegin : wraps vkBeginCommandBuffer with VkCommandBufferUsageFlags and implicitly handles VkCommandBufferBeginInfo setup</li>
<li>makeSubmitInfo : VkSubmitInfo struct setup using provided arrays of signals and commandbuffers, leaving rest zeroed </li>
</ul>
<h2><a class="anchor" id="autotoc_md199"></a>
class nvvk::CommandPool</h2>
<p><a class="el" href="classnvvk_1_1_command_pool.html">nvvk::CommandPool</a> stores a single VkCommandPool and provides utility functions to create VkCommandBuffers from it.</p>
<p>Example: </p><div class="fragment"><div class="line">{</div>
<div class="line">  <a class="code hl_class" href="classnvvk_1_1_command_pool.html">nvvk::CommandPool</a> cmdPool;</div>
<div class="line">  cmdPool.init(...);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// some setup/one shot work</span></div>
<div class="line">  {</div>
<div class="line">    vkCommandBuffer cmd = scopePool.createAndBegin();</div>
<div class="line">    ... record commands ...</div>
<div class="line">    <span class="comment">// trigger execution with a blocking operation</span></div>
<div class="line">    <span class="comment">// not recommended for performance</span></div>
<div class="line">    <span class="comment">// but useful for sample setup</span></div>
<div class="line">    scopePool.submitAndWait(cmd, queue);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// other cmds you may batch, or recycle</span></div>
<div class="line">  std::vector&lt;VkCommandBuffer&gt; cmds;</div>
<div class="line">  {</div>
<div class="line">    vkCommandBuffer cmd = scopePool.createAndBegin();</div>
<div class="line">    ... record commands ...</div>
<div class="line">    cmds.push_back(cmd);</div>
<div class="line">  }</div>
<div class="line">  {</div>
<div class="line">    vkCommandBuffer cmd = scopePool.createAndBegin();</div>
<div class="line">    ... record commands ...</div>
<div class="line">    cmds.push_back(cmd);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// do some form of batched submission of cmds</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// after completion destroy cmd</span></div>
<div class="line">  cmdPool.destroy(cmds.size(), cmds.data());</div>
<div class="line">  cmdPool.deinit();</div>
<div class="line">}</div>
<div class="ttc" id="aclassnvvk_1_1_command_pool_html"><div class="ttname"><a href="classnvvk_1_1_command_pool.html">nvvk::CommandPool</a></div><div class="ttdef"><b>Definition</b> commands_vk.hpp:106</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md200"></a>
class nvvk::ScopeCommandBuffer</h2>
<p><a class="el" href="classnvvk_1_1_scope_command_buffer.html">nvvk::ScopeCommandBuffer</a> provides a single VkCommandBuffer that lives within the scope and is directly submitted and deleted when the scope is left. Not recommended for efficiency, since it results in a blocking operation, but aids sample writing.</p>
<p>Example: </p><div class="fragment"><div class="line">{</div>
<div class="line">  ScopeCommandBuffer cmd(device, queueFamilyIndex, queue);</div>
<div class="line">  ... <span class="keywordflow">do</span> stuff</div>
<div class="line">  vkCmdCopyBuffer(cmd, ...);</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md201"></a>
class <b>nvvk::Ring...</b></h2>
<p>In real-time processing, the CPU typically generates commands in advance to the GPU and send them in batches for execution.</p>
<p>To avoid having the CPU to wait for the GPU'S completion and let it "race ahead" we make use of double, or tripple-buffering techniques, where we cycle through a pool of resources every frame. We know that those resources are currently not in use by the GPU and can therefore manipulate them directly.</p>
<p>Especially in Vulkan it is the developer's responsibility to avoid such access of resources that are in-flight.</p>
<p>The "Ring" classes cycle through a pool of resources. The default value is set to allow two frames in-flight, assuming one fence is used per-frame. </p>
<h2><a class="anchor" id="autotoc_md202"></a>
class nvvk::RingFences</h2>
<p><a class="el" href="classnvvk_1_1_ring_fences.html">nvvk::RingFences</a> recycles a fixed number of fences, provides information in which cycle we are currently at, and prevents accidental access to a cycle in-flight.</p>
<p>A typical frame would start by "setCycleAndWait", which waits for the requested cycle to be available. </p>
<h3><a class="anchor" id="autotoc_md203"></a>
class nvvk::RingCommandPool</h3>
<p><a class="el" href="classnvvk_1_1_ring_command_pool.html">nvvk::RingCommandPool</a> manages a fixed cycle set of VkCommandBufferPools and one-shot command buffers allocated from them.</p>
<p>The usage of multiple command buffer pools also means we get nice allocation behavior (linear allocation from frame start to frame end) without fragmentation. If we were using a single command pool over multiple frames, it could fragment easily.</p>
<p>You must ensure cycle is available manually, typically by keeping in sync with ring fences.</p>
<p>Example:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  frame++;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// wait until we can use the new cycle</span></div>
<div class="line">  <span class="comment">// (very rare if we use the fence at then end once per-frame)</span></div>
<div class="line">  ringFences.setCycleAndWait( frame );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// update cycle state, allows recycling of old resources</span></div>
<div class="line">  ringPool.setCycle( frame );</div>
<div class="line"> </div>
<div class="line">  VkCommandBuffer cmd = ringPool.createCommandBuffer(...);</div>
<div class="line">  ... <span class="keywordflow">do</span> stuff / submit etc...</div>
<div class="line"> </div>
<div class="line">  VkFence fence = ringFences.getFence();</div>
<div class="line">  <span class="comment">// use this fence in the submit</span></div>
<div class="line">  vkQueueSubmit(...fence..);</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md204"></a>
class nvvk::BatchSubmission</h2>
<p><a class="el" href="classnvvk_1_1_batch_submission.html">nvvk::BatchSubmission</a> batches the submission arguments of VkSubmitInfo for VkQueueSubmit.</p>
<p>vkQueueSubmit is a rather costly operation (depending on OS) and should be avoided to be done too often (e.g. &lt; 10 per frame). Therefore this utility class allows adding commandbuffers, semaphores etc. and submit them later in a batch.</p>
<p>When using manual locks, it can also be useful to feed commandbuffers from different threads and then later kick it off.</p>
<p>Example</p>
<div class="fragment"><div class="line"><span class="comment">// within upload logic</span></div>
<div class="line">{</div>
<div class="line">  semTransfer = handleUpload(...);</div>
<div class="line">  <span class="comment">// for example trigger async upload on transfer queue here</span></div>
<div class="line">  vkQueueSubmit(... semTransfer ...);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// tell next frame&#39;s batch submission</span></div>
<div class="line">  <span class="comment">// that its commandbuffers should wait for transfer</span></div>
<div class="line">  <span class="comment">// to be completed</span></div>
<div class="line">  graphicsSubmission.enqueWait(semTransfer)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// within present logic</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// for example ensure the next frame waits until proper present semaphore was triggered</span></div>
<div class="line">  graphicsSubmission.enqueueWait(presentSemaphore);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// within drawing logic</span></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// enqueue some graphics work for submission</span></div>
<div class="line">  graphicsSubmission.enqueue(getSceneCmdBuffer());</div>
<div class="line">  graphicsSubmission.enqueue(getUiCmdBuffer());</div>
<div class="line"> </div>
<div class="line">  graphicsSubmission.execute(frameFence);</div>
<div class="line">}</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md205"></a>
class nvvk::FencedCommandPools</h2>
<p><a class="el" href="classnvvk_1_1_fenced_command_pools.html">nvvk::FencedCommandPools</a> container class contains the typical utilities to handle command submission. It contains RingFences, RingCommandPool and BatchSubmission with a convenient interface.</p>
<h1><a class="anchor" id="autotoc_md206"></a>
compute_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md207"></a>
class nvvk::PushComputeDispatcher</h2>
<p><a class="el" href="classnvvk_1_1_push_compute_dispatcher.html">nvvk::PushComputeDispatcher</a> is a convenience structure for easily creating compute-only pipelines by defining the bindings and providing SPV code. The descriptor set updates are carried out using the KHR_push_descriptor extension.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> BindingLocation</div>
<div class="line">{</div>
<div class="line">  eMyBindingLocation = 0</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>PushConstant{</div>
<div class="line"> ...</div>
<div class="line">}</div>
<div class="line">pushConstant;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classnvvk_1_1_push_compute_dispatcher.html">nvvk::PushComputeDispatcher&lt;PushConstant, BindingLocation&gt;</a> myCompute;</div>
<div class="line"> </div>
<div class="line">VkBuffer myFirstBuffer = createMyFirstBuffer(...);</div>
<div class="line">VkBuffer mySecondBuffer = createMySecondBuffer(...);</div>
<div class="line">VkDevice device = getMyVkDevice(...);</div>
<div class="line">myCompute.create(device);</div>
<div class="line"><span class="keyword">const</span> uint8_t* spvCode = getMyComputeShaderCode(...);</div>
<div class="line"><span class="keywordtype">size_t</span> spvCodeSize = getMyComputeShaderCodeSize(...);</div>
<div class="line">myCompute.getBindings().addBinding(BindingLocation::eMyBindingLocation, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_ALL););</div>
<div class="line">myCompute.setCode(spvCode, spvCodeSize);</div>
<div class="line">myCompute.finalizePipeline();</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">myCompute.updateBufferBinding(BindingLocation::eMyBindingLocation, myFirstBuffer)</div>
<div class="line">VkCommandBuffer cmd = getMyCommandBuffer(...);</div>
<div class="line"> </div>
<div class="line">myCompute.dispatch(cmd, targetThreadCount, &amp;pushConstant);</div>
<div class="line">...</div>
<div class="line">myCompute.updateBufferBinding(BindingLocation::eMyBindingLocation, mySecondBuffer)</div>
<div class="line">myCompute.dispatch(cmd, targetThreadCount, &amp;pushConstant);</div>
<div class="line">...</div>
<div class="ttc" id="aclassnvvk_1_1_push_compute_dispatcher_html"><div class="ttname"><a href="classnvvk_1_1_push_compute_dispatcher.html">nvvk::PushComputeDispatcher</a></div><div class="ttdef"><b>Definition</b> compute_vk.hpp:97</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md208"></a>
context_vk.hpp</h1>
<p>To run a Vulkan application, you need to create the Vulkan instance and device. This is done using the <code><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a></code>, which wraps the creation of <code>VkInstance</code> and <code>VkDevice</code>.</p>
<p>First, any application needs to specify how instance and device should be created: Version, layers, instance and device extensions influence the features available. This is done through a temporary and intermediate class that will allow you to gather all the required conditions for the device creation. </p>
<h2><a class="anchor" id="autotoc_md209"></a>
struct ContextCreateInfo</h2>
<p>This structure allows the application to specify a set of features that are expected for the creation of</p><ul>
<li>VkInstance</li>
<li>VkDevice</li>
</ul>
<p>It is consumed by the <code>nvvk::Context::init</code> function.</p>
<p>Example on how to populate information in it :</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structnvvk_1_1_context_create_info.html">nvvk::ContextCreateInfo</a> ctxInfo;</div>
<div class="line">ctxInfo.setVersion(1, 2);</div>
<div class="line">ctxInfo.addInstanceExtension(VK_KHR_SURFACE_EXTENSION_NAME, <span class="keyword">false</span>);</div>
<div class="line">ctxInfo.addInstanceExtension(VK_KHR_WIN32_SURFACE_EXTENSION_NAME, <span class="keyword">false</span>);</div>
<div class="line">ctxInfo.addDeviceExtension(VK_KHR_SWAPCHAIN_EXTENSION_NAME, <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// adding an extension with a feature struct:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR pipePropFeatures = {</div>
<div class="line">    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR};</div>
<div class="line"><span class="comment">// Be aware of the lifetime of the pointer of the feature struct.</span></div>
<div class="line"><span class="comment">// ctxInfo stores the pointer directly and context init functions use it for read &amp; write access.</span></div>
<div class="line">ctxInfo.addDeviceExtension(VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME, <span class="keyword">true</span>, &amp;pipePropFeatures);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// disabling a feature:</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This callback is called after the feature structs were filled with physical device information</span></div>
<div class="line"><span class="comment">// and prior logical device creation.</span></div>
<div class="line"><span class="comment">// The callback iterates over all feature structs, including those from</span></div>
<div class="line"><span class="comment">// the vulkan versions.</span></div>
<div class="line">ctxInfo.fnDisableFeatures = [](VkStructureType sType, <span class="keywordtype">void</span> *pFeatureStruct)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">switch</span>(sType){</div>
<div class="line">  <span class="keywordflow">case</span> VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">auto</span>* features11 = <span class="keyword">reinterpret_cast&lt;</span>VkPhysicalDeviceVulkan11Features<span class="keyword">&gt;</span>(pFeatureStruct);</div>
<div class="line">      <span class="comment">// at this point the struct is populated with what the device supports</span></div>
<div class="line">      <span class="comment">// and therefore it is only legal to disable features, not enable them.</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// let&#39;s say we wanted to disable multiview</span></div>
<div class="line">      features11-&gt;multiView = VK_FALSE;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  <span class="keywordflow">default</span>:</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="astructnvvk_1_1_context_create_info_html"><div class="ttname"><a href="structnvvk_1_1_context_create_info.html">nvvk::ContextCreateInfo</a></div><div class="ttdef"><b>Definition</b> context_vk.hpp:115</div></div>
</div><!-- fragment --><p>then you are ready to create initialize <code><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a></code></p>
<blockquote class="doxtable">
<p>&zwj;Note: In debug builds, the extension <code>VK_EXT_DEBUG_UTILS_EXTENSION_NAME</code> and the layer <code>VK_LAYER_KHRONOS_validation</code> are added to help finding issues early. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md210"></a>
class nvvk::Context</h2>
<p><a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a> class helps creating the Vulkan instance and to choose the logical device for the mandatory extensions. First is to fill the <code>ContextCreateInfo</code> structure, then call:</p>
<div class="fragment"><div class="line"><span class="comment">// Creating the Vulkan instance and device</span></div>
<div class="line"><a class="code hl_struct" href="structnvvk_1_1_context_create_info.html">nvvk::ContextCreateInfo</a> ctxInfo;</div>
<div class="line">... see above ...</div>
<div class="line"> </div>
<div class="line">nvvk::Context vkctx;</div>
<div class="line">vkctx.init(ctxInfo);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// after init the ctxInfo is no longer needed</span></div>
</div><!-- fragment --><p>At this point, the class will have created the <code>VkInstance</code> and <code>VkDevice</code> according to the information passed. It will also keeps track or have query the information of:</p>
<ul>
<li>Physical Device information that you can later query : <code>PhysicalDeviceInfo</code> in which lots of <code>VkPhysicalDevice...</code> are stored</li>
<li><code>VkInstance</code> : the one instance being used for the program</li>
<li><code>VkPhysicalDevice</code> : physical device(s) used for the logical device creation. In case of more than one physical device, we have a std::vector for this purpose...</li>
<li><code>VkDevice</code> : the logical device instantiated</li>
<li><code>VkQueue</code> : By default, 3 queues are created, one per family: Graphic-Compute-Transfer, Compute and Transfer. For any additionnal queue, they need to be requested with <code>ContextCreateInfo::addRequestedQueue()</code>. This is creating information of the best suitable queues, but not creating them. To create the additional queues, <code>Context::createQueue()</code> <b>must be call after</b> creating the Vulkan context. The following queues are always created and can be directly accessed without calling createQueue :<ul>
<li><code>Queue m_queueGCT</code> : Graphics/Compute/Transfer Queue + family index</li>
<li><code>Queue m_queueT</code> : async Transfer Queue + family index</li>
<li><code>Queue m_queueC</code> : async Compute Queue + family index</li>
</ul>
</li>
<li>maintains what extensions are finally available</li>
<li>implicitly hooks up the debug callback</li>
</ul>
<h3><a class="anchor" id="autotoc_md211"></a>
Choosing the device</h3>
<p>When there are multiple devices, the <code>init</code> method is choosing the first compatible device available, but it is also possible the choose another one. </p><div class="fragment"><div class="line">vkctx.initInstance(deviceInfo);</div>
<div class="line"><span class="comment">// Find all compatible devices</span></div>
<div class="line"><span class="keyword">auto</span> compatibleDevices = vkctx.getCompatibleDevices(deviceInfo);</div>
<div class="line">assert(!compatibleDevices.empty());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use first compatible device</span></div>
<div class="line">vkctx.initDevice(compatibleDevices[0], deviceInfo);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md212"></a>
Multi-GPU</h3>
<p>When multiple graphic cards should be used as a single device, the <code>ContextCreateInfo::useDeviceGroups</code> need to be set to <code>true</code>. The above methods will transparently create the <code>VkDevice</code> using <code>VkDeviceGroupDeviceCreateInfo</code>. Especially in the context of NVLink connected cards this is useful.</p>
<h1><a class="anchor" id="autotoc_md213"></a>
debug_util_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md214"></a>
class DebugUtil</h2>
<p>This is a companion utility to add debug information to Vulkan objects, using the VK_EXT_debug_utils extension.</p>
<p>You can use it to:</p><ul>
<li>Add user-defined names to objects, using <code>DebugUtil::setObjectName</code></li>
<li>Annotate regions of command buffers, using <code>DebugUtil::{beginLabel, insertLabel, endLabel}</code></li>
<li>Create scoped command buffer labels, which make things simpler by automatically beginning and ending regions based on their C++ lifetime, using <code>DebugUtil::scopeLabel</code>.</li>
</ul>
<p>See <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_utils.html">https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_EXT_debug_utils.html</a>.</p>
<h1><a class="anchor" id="autotoc_md215"></a>
descriptorsets_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md216"></a>
functions in nvvk</h2>
<ul>
<li>createDescriptorPool : wrappers for vkCreateDescriptorPool</li>
<li>allocateDescriptorSet : allocates a single VkDescriptorSet</li>
<li>allocateDescriptorSets : allocates multiple VkDescriptorSets</li>
</ul>
<h2><a class="anchor" id="autotoc_md217"></a>
class nvvk::DescriptorSetBindings</h2>
<p><a class="el" href="classnvvk_1_1_descriptor_set_bindings.html">nvvk::DescriptorSetBindings</a> is a helper class that keeps a vector of <code>VkDescriptorSetLayoutBinding</code> for a single <code>VkDescriptorSetLayout</code>. Provides helper functions to create <code>VkDescriptorSetLayout</code> as well as <code>VkDescriptorPool</code> based on this information, as well as utilities to fill the <code>VkWriteDescriptorSet</code> structure with binding information stored within the class.</p>
<p>The class comes with the convenience functionality that when you make a VkWriteDescriptorSet you provide the binding slot, rather than the index of the binding's storage within this class. This results in a small linear search, but makes it easy to change the content/order of bindings at creation time.</p>
<p>Example : </p><div class="fragment"><div class="line">DescriptorSetBindings binds;</div>
<div class="line"> </div>
<div class="line">binds.addBinding( VIEW_BINDING, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, 1, VK_SHADER_STAGE_VERTEX_BIT);</div>
<div class="line">binds.addBinding(XFORM_BINDING, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_VERTEX_BIT);</div>
<div class="line"> </div>
<div class="line">VkDescriptorSetLayout layout = binds.createLayout(device);</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#if SINGLE_LAYOUT_POOL</span></div>
<div class="line">  <span class="comment">// let&#39;s create a pool with 2 sets</span></div>
<div class="line">  VkDescriptorPool      pool   = binds.createPool(device, 2);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  <span class="comment">// if you want to combine multiple layouts into a common pool</span></div>
<div class="line">  std::vector&lt;VkDescriptorPoolSize&gt; poolSizes;</div>
<div class="line">  bindsA.addRequiredPoolSizes(poolSizes, numSetsA);</div>
<div class="line">  bindsB.addRequiredPoolSizes(poolSizes, numSetsB);</div>
<div class="line">  VkDescriptorPool      pool   = <a class="code hl_function" href="namespacenvvk.html#a30b535dceb807b1c1b4b7789d48caa5c">nvvk::createDescriptorPool</a>(device, poolSizes,</div>
<div class="line">                                                            numSetsA + numSetsB);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// fill them</span></div>
<div class="line">std::vector&lt;VkWriteDescriptorSet&gt; updates;</div>
<div class="line"> </div>
<div class="line">updates.push_back(binds.makeWrite(0, VIEW_BINDING, &amp;view0BufferInfo));</div>
<div class="line">updates.push_back(binds.makeWrite(1, VIEW_BINDING, &amp;view1BufferInfo));</div>
<div class="line">updates.push_back(binds.makeWrite(0, XFORM_BINDING, &amp;xform0BufferInfo));</div>
<div class="line">updates.push_back(binds.makeWrite(1, XFORM_BINDING, &amp;xform1BufferInfo));</div>
<div class="line"> </div>
<div class="line">vkUpdateDescriptorSets(device, updates.size(), updates.data(), 0, <span class="keyword">nullptr</span>);</div>
<div class="ttc" id="anamespacenvvk_html_a30b535dceb807b1c1b4b7789d48caa5c"><div class="ttname"><a href="namespacenvvk.html#a30b535dceb807b1c1b4b7789d48caa5c">nvvk::createDescriptorPool</a></div><div class="ttdeci">VkDescriptorPool createDescriptorPool(VkDevice device, size_t poolSizeCount, const VkDescriptorPoolSize *poolSizes, uint32_t maxSets)</div><div class="ttdef"><b>Definition</b> descriptorsets_vk.hpp:65</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md218"></a>
class nvvk::DescriptorSetContainer</h2>
<p><a class="el" href="classnvvk_1_1_descriptor_set_container.html">nvvk::DescriptorSetContainer</a> is a container class that stores allocated DescriptorSets as well as reflection, layout and pool for a single VkDescripterSetLayout.</p>
<p>Example: </p><div class="fragment"><div class="line">container.init(device, allocator);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// setup dset layouts</span></div>
<div class="line">container.addBinding(0, UBO...)</div>
<div class="line">container.addBinding(1, SSBO...)</div>
<div class="line">container.initLayout();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allocate descriptorsets</span></div>
<div class="line">container.initPool(17);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// update descriptorsets</span></div>
<div class="line">writeUpdates.push_back( container.makeWrite(0, 0, &amp;..) );</div>
<div class="line">writeUpdates.push_back( container.makeWrite(0, 1, &amp;..) );</div>
<div class="line">writeUpdates.push_back( container.makeWrite(1, 0, &amp;..) );</div>
<div class="line">writeUpdates.push_back( container.makeWrite(1, 1, &amp;..) );</div>
<div class="line">writeUpdates.push_back( container.makeWrite(2, 0, &amp;..) );</div>
<div class="line">writeUpdates.push_back( container.makeWrite(2, 1, &amp;..) );</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// at render time</span></div>
<div class="line"> </div>
<div class="line">vkCmdBindDescriptorSets(cmd, GRAPHICS, pipeLayout, 1, 1, container.at(7).getSets());</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md219"></a>
class nvvk::TDescriptorSetContainer&lt;SETS,PIPES=1&gt;</h2>
<p><a class="el" href="classnvvk_1_1_t_descriptor_set_container.html">nvvk::TDescriptorSetContainer</a> is a templated version of DescriptorSetContainer :</p>
<ul>
<li>SETS - many DescriptorSetContainers</li>
<li>PIPES - many VkPipelineLayouts</li>
</ul>
<p>The pipeline layouts are stored separately, the class does not use the pipeline layouts of the embedded DescriptorSetContainers.</p>
<p>Example :</p>
<div class="fragment"><div class="line">Usage, e.g.SETS = 2, PIPES = 2</div>
<div class="line"> </div>
<div class="line">container.init(device, allocator);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// setup dset layouts</span></div>
<div class="line">container.at(0).addBinding(0, UBO...)</div>
<div class="line">container.at(0).addBinding(1, SSBO...)</div>
<div class="line">container.at(0).initLayout();</div>
<div class="line">container.at(1).addBinding(0, COMBINED_SAMPLER...)</div>
<div class="line">container.at(1).initLayout();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// pipe 0 uses set 0 alone</span></div>
<div class="line">container.initPipeLayout(0, 1);</div>
<div class="line"><span class="comment">// pipe 1 uses sets 0, 1</span></div>
<div class="line">container.initPipeLayout(1, 2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// allocate descriptorsets</span></div>
<div class="line">container.at(0).initPool(1);</div>
<div class="line">container.at(1).initPool(16);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// update descriptorsets</span></div>
<div class="line"> </div>
<div class="line">writeUpdates.push_back(container.at(0).makeWrite(0, 0, &amp;..));</div>
<div class="line">writeUpdates.push_back(container.at(0).makeWrite(0, 1, &amp;..));</div>
<div class="line">writeUpdates.push_back(container.at(1).makeWrite(0, 0, &amp;..));</div>
<div class="line">writeUpdates.push_back(container.at(1).makeWrite(1, 0, &amp;..));</div>
<div class="line">writeUpdates.push_back(container.at(1).makeWrite(2, 0, &amp;..));</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// at render time</span></div>
<div class="line"> </div>
<div class="line">vkCmdBindDescriptorSets(cmd, GRAPHICS, container.getPipeLayout(0), 0, 1, container.at(0).getSets());</div>
<div class="line">..</div>
<div class="line">vkCmdBindDescriptorSets(cmd, GRAPHICS, container.getPipeLayout(1), 1, 1, container.at(1).getSets(7));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md220"></a>
dynamicrendering_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md221"></a>
struct nvvk::RenderPass</h2>
<blockquote class="doxtable">
<p>&zwj; Wrapper for VkRenderingInfoKHR </p>
</blockquote>
<p>This class is a wrapper around the VkRenderingInfoKHR structure, which is used to create a render pass with dynamic attachments.</p>
<h1><a class="anchor" id="autotoc_md222"></a>
error_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md223"></a>
Function nvvk::checkResult</h2>
<blockquote class="doxtable">
<p>&zwj; Returns true on critical error result, logs errors. </p>
</blockquote>
<p>Use <code>NVVK_CHECK(result)</code> to automatically log filename/linenumber. </p>
<h2><a class="anchor" id="autotoc_md224"></a>
Function nvvk::setCheckResultHook</h2>
<blockquote class="doxtable">
<p>&zwj; Allow replacing nvvk::checkResult() calls. E.g. to catch </p>
</blockquote>
<p><code>VK_ERROR_DEVICE_LOST</code> and wait for aftermath to write the crash dump.</p>
<h1><a class="anchor" id="autotoc_md225"></a>
gizmos_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md226"></a>
class nvvk::Axis</h2>
<p>nvvk::Axis displays an Axis representing the orientation of the camera in the bottom left corner of the window.</p><ul>
<li>Initialize the Axis using <code>init()</code></li>
<li>Add <code>display()</code> in a inline rendering pass, one of the lass command</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line">m_axis.display(cmdBuf, CameraManip.getMatrix(), windowSize);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md227"></a>
images_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md228"></a>
functions in nvvk</h2>
<ul>
<li>makeImageMemoryBarrier : returns VkImageMemoryBarrier for an image based on provided layouts and access flags.</li>
<li>mipLevels : return number of mips for 2d/3d extent</li>
<li>accessFlagsForImageLayout : helps resource transtions</li>
<li>pipelineStageForLayout : helps resource transitions</li>
<li>cmdBarrierImageLayout : inserts barrier for image transition</li>
<li>cmdGenerateMipmaps : basic mipmap creation for images (meant for one-shot operations)</li>
<li>makeImage2DCreateInfo : aids 2d image creation</li>
<li>makeImage3DCreateInfo : aids 3d descriptor set updating</li>
<li>makeImageCubeCreateInfo : aids cube descriptor set updating</li>
<li>makeImageViewCreateInfo : aids common image view creation, derives info from VkImageCreateInfo</li>
<li>makeImage2DViewCreateInfo : aids 2d image view creation</li>
</ul>
<h1><a class="anchor" id="autotoc_md229"></a>
memallocator_dedicated_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md230"></a>
class nvvk::DedicatedMemoryAllocator</h2>
<p><a class="el" href="classnvvk_1_1_dedicated_memory_allocator.html">nvvk::DedicatedMemoryAllocator</a> is a simple implementation of the MemAllocator interface, using one vkDeviceMemory allocation per allocMemory() call. The simplicity of the implementation is bought with potential slowness (vkAllocateMemory tends to be very slow) and running out of operating system resources quickly (as some OSs limit the number of physical memory allocations per process).</p>
<h1><a class="anchor" id="autotoc_md231"></a>
memallocator_dma_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md232"></a>
class nvvk::DMAMemoryAllocator</h2>
<p><a class="el" href="classnvvk_1_1_d_m_a_memory_allocator.html">nvvk::DMAMemoryAllocator</a> is using <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> internally. <b>Not</b> thread-safe. <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> derives from <a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a> as well, so this class here is for those prefering a reduced wrapper; </p>
<h2><a class="anchor" id="autotoc_md233"></a>
class nvvk::DMAMemoryAllocatorTS</h2>
<p><a class="el" href="classnvvk_1_1_d_m_a_memory_allocator_t_s.html">nvvk::DMAMemoryAllocatorTS</a> is using <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> internally. It implements a simple thread-safe wrapper, not optimized for performance. <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> derives from <a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a> as well, so this class here is for those prefering a reduced wrapper;</p>
<h1><a class="anchor" id="autotoc_md234"></a>
memallocator_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md235"></a>
class nvvk::MemHandle</h2>
<p>nvvk::MemHandle represents a memory allocation or sub-allocation from the generic <a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a> interface. Ideally use <code>nvvk::NullMemHandle</code> for setting to 'NULL'. MemHandle may change to a non-pointer type in future.</p>
<h2><a class="anchor" id="autotoc_md236"></a>
class nvvk::MemAllocateInfo</h2>
<p><a class="el" href="classnvvk_1_1_mem_allocate_info.html">nvvk::MemAllocateInfo</a> is collecting almost all parameters a Vulkan allocation could potentially need. This keeps MemAllocator's interface simple and extensible. </p>
<h2><a class="anchor" id="autotoc_md237"></a>
class nvvk::MemAllocator</h2>
<p><a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a> is a Vulkan memory allocator interface extensively used by ResourceAllocator. It provides means to allocate, free, map and unmap pieces of Vulkan device memory. Concrete implementations derive from nvvk::MemoryAllocator. They can implement the allocator dunctionality themselves or act as an adapter to another memory allocator implementation.</p>
<p>A <a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a> hands out opaque 'MemHandles'. The implementation of the MemAllocator interface may chose any type of payload to store in a MemHandle. A MemHandle's relevant information can be retrieved via getMemoryInfo().</p>
<h1><a class="anchor" id="autotoc_md238"></a>
memallocator_vma_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md239"></a>
class nvvk::VMAMemoryAllocator</h2>
<p><a class="el" href="classnvvk_1_1_v_m_a_memory_allocator.html">nvvk::VMAMemoryAllocator</a> using the GPUOpen <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a> underneath. As VMA comes as a header-only library, when using it you'll have to: 1) provide _add_package_VMA() in your CMakeLists.txt 2) put these lines into one of your compilation units: </p><div class="fragment"><div class="line"><span class="preprocessor">#define VMA_IMPLEMENTATION</span></div>
<div class="line"><span class="preprocessor">#include &quot;vk_mem_alloc.h&quot;</span></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md240"></a>
class nvvk::ResourceAllocatorVMA</h2>
<p>nvvk::ResourceAllocatorVMA is a convencience class creating, initializing and owning a nvvk::VmaAllocator and associated <a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a> object.</p>
<h1><a class="anchor" id="autotoc_md241"></a>
memorymanagement_vk.hpp</h1>
<p>This framework assumes that memory heaps exists that support:</p>
<ul>
<li>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT &amp; VK_MEMORY_PROPERTY_HOST_COHERENT_BIT for uploading data to the device</li>
<li>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT &amp; VK_MEMORY_PROPERTY_HOST_CACHED_BIT for downloading data from the device</li>
</ul>
<p>This is typical on all major desktop platforms and vendors. See <a href="http://vulkan.gpuinfo.org">http://vulkan.gpuinfo.org</a> for information of various devices and platforms.</p>
<h2><a class="anchor" id="autotoc_md242"></a>
functions in nvvk</h2>
<ul>
<li>getMemoryInfo : fills the VkMemoryAllocateInfo based on device's memory properties and memory requirements and property flags. Returns <code>true</code> on success. </li>
</ul>
<h2><a class="anchor" id="autotoc_md243"></a>
class nvvk::DeviceMemoryAllocator</h2>
<p>The <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> allocates and manages device memory in fixed-size memory blocks. It implements the <a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a> interface.</p>
<p>It sub-allocates from the blocks, and can re-use memory if it finds empty regions. Because of the fixed-block usage, you can directly create resources and don't need a phase to compute the allocation sizes first.</p>
<p>It will create compatible chunks according to the memory requirements and usage flags. Therefore you can easily create mappable host allocations and delete them after usage, without inferring device-side allocations.</p>
<p>An <code>AllocationID</code> is returned rather than the allocation details directly, which one can query separately.</p>
<p>Several utility functions are provided to handle the binding of memory directly with the resource creation of buffers, images and acceleration structures. These utilities also make implicit use of Vulkan's dedicated allocation mechanism.</p>
<p>We recommend the use of the <a class="el" href="classnvvk_1_1_resource_allocator.html">nvvk::ResourceAllocator</a> class, rather than the various create functions provided here, as we may deprecate them.</p>
<blockquote class="doxtable">
<p>&zwj;<b>WARNING</b> : The memory manager serves as proof of concept for some key concepts however it is not meant for production use and it currently lacks de-fragmentation logic as well. You may want to look at <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">VMA</a> for a more production-focused solution. </p>
</blockquote>
<p>You can derive from this class and overload a few functions to alter the chunk allocation behavior.</p>
<p>Example : </p><div class="fragment"><div class="line"><a class="code hl_class" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> memAllocator;</div>
<div class="line"> </div>
<div class="line">memAllocator.init(device, physicalDevice);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// low-level</span></div>
<div class="line">aid = memAllocator.alloc(memRequirements,...);</div>
<div class="line">...</div>
<div class="line">memAllocator.free(aid);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// utility wrapper</span></div>
<div class="line">buffer = memAllocator.createBuffer(bufferSize, bufferUsage, bufferAid);</div>
<div class="line">...</div>
<div class="line">memAllocator.free(bufferAid);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// It is also possible to not track individual resources</span></div>
<div class="line"><span class="comment">// and free everything in one go. However, this is</span></div>
<div class="line"><span class="comment">// not recommended for general purpose use.</span></div>
<div class="line"> </div>
<div class="line">bufferA = memAllocator.createBuffer(sizeA, usageA);</div>
<div class="line">bufferB = memAllocator.createBuffer(sizeB, usageB);</div>
<div class="line">...</div>
<div class="line">memAllocator.freeAll();</div>
<div class="ttc" id="aclassnvvk_1_1_device_memory_allocator_html"><div class="ttname"><a href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a></div><div class="ttdef"><b>Definition</b> memorymanagement_vk.hpp:163</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md244"></a>
memorymanagement_vkgl.hpp</h1>
<p>This file contains helpers for resource interoperability between OpenGL and Vulkan. they only exist if the nvpro_core project is compiled with Vulkan AND OpenGL support. </p>
<h2><a class="anchor" id="autotoc_md245"></a>
class nvvk::DeviceMemoryAllocatorGL</h2>
<p>nvvk::DeviceMemoryAllocatorGL is derived from <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> it uses vulkan memory that is exported and directly imported into OpenGL. Requires GL_EXT_memory_object.</p>
<p>Used just like the original class however a new function to get the GL memory object exists: <code>getAllocationGL</code>.</p>
<p>Look at source of nvvk::AllocatorDmaGL for usage.</p>
<h1><a class="anchor" id="autotoc_md246"></a>
pipeline_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md247"></a>
struct nvvk::GraphicsPipelineState</h2>
<p>Most graphic pipelines have similar states, therefore the helper <code>GraphicsPipelineStage</code> holds all the elements and initialize the structures with the proper default values, such as the primitive type, <code>PipelineColorBlendAttachmentState</code> with their mask, <code>DynamicState</code> for viewport and scissor, adjust depth test if enabled, line width to 1 pixel, for example.</p>
<p>Example of usage : </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structnvvk_1_1_graphics_pipeline_state.html">nvvk::GraphicsPipelineState</a> pipelineState();</div>
<div class="line">pipelineState.depthStencilState.setDepthTestEnable(<span class="keyword">true</span>);</div>
<div class="line">pipelineState.rasterizationState.setCullMode(vk::CullModeFlagBits::eNone);</div>
<div class="line">pipelineState.addBindingDescription({0, <span class="keyword">sizeof</span>(Vertex)});</div>
<div class="line">pipelineState.addAttributeDescriptions ({</div>
<div class="line">    {0, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, pos))},</div>
<div class="line">    {1, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, nrm))},</div>
<div class="line">    {2, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, col))}});</div>
<div class="ttc" id="astructnvvk_1_1_graphics_pipeline_state_html"><div class="ttname"><a href="structnvvk_1_1_graphics_pipeline_state.html">nvvk::GraphicsPipelineState</a></div><div class="ttdef"><b>Definition</b> pipeline_vk.hpp:72</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md248"></a>
struct nvvk::GraphicsPipelineGenerator</h2>
<p>The graphics pipeline generator takes a GraphicsPipelineState object and pipeline-specific information such as the render pass and pipeline layout to generate the final pipeline.</p>
<p>Example of usage : </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structnvvk_1_1_graphics_pipeline_state.html">nvvk::GraphicsPipelineState</a> pipelineState();</div>
<div class="line">...</div>
<div class="line">nvvk::GraphicsPipelineGenerator pipelineGenerator(m_device, m_pipelineLayout, m_renderPass, pipelineState);</div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/vert_shader.vert.spv&quot;</span>), VkShaderStageFlagBits::eVertex);</div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/frag_shader.frag.spv&quot;</span>), VkShaderStageFlagBits::eFragment);</div>
<div class="line"> </div>
<div class="line">m_pipeline = pipelineGenerator.createPipeline();</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md249"></a>
class nvvk::GraphicsPipelineGeneratorCombined</h2>
<p>In some cases the application may have each state associated to a single pipeline. For convenience, <a class="el" href="structnvvk_1_1_graphics_pipeline_generator_combined.html">nvvk::GraphicsPipelineGeneratorCombined</a> combines both the state and generator into a single object.</p>
<p>Example of usage : </p><div class="fragment"><div class="line"><a class="code hl_struct" href="structnvvk_1_1_graphics_pipeline_generator_combined.html">nvvk::GraphicsPipelineGeneratorCombined</a> pipelineGenerator(m_device, m_pipelineLayout, m_renderPass);</div>
<div class="line">pipelineGenerator.depthStencilState.setDepthTestEnable(<span class="keyword">true</span>);</div>
<div class="line">pipelineGenerator.rasterizationState.setCullMode(vk::CullModeFlagBits::eNone);</div>
<div class="line">pipelineGenerator.addBindingDescription({0, <span class="keyword">sizeof</span>(Vertex)});</div>
<div class="line">pipelineGenerator.addAttributeDescriptions ({</div>
<div class="line">    {0, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, pos))},</div>
<div class="line">    {1, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, nrm))},</div>
<div class="line">    {2, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, col))}});</div>
<div class="line"> </div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/vert_shader.vert.spv&quot;</span>), VkShaderStageFlagBits::eVertex);</div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/frag_shader.frag.spv&quot;</span>), VkShaderStageFlagBits::eFragment);</div>
<div class="line"> </div>
<div class="line">m_pipeline = pipelineGenerator.createPipeline();</div>
<div class="ttc" id="astructnvvk_1_1_graphics_pipeline_generator_combined_html"><div class="ttname"><a href="structnvvk_1_1_graphics_pipeline_generator_combined.html">nvvk::GraphicsPipelineGeneratorCombined</a></div><div class="ttdef"><b>Definition</b> pipeline_vk.hpp:619</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md250"></a>
profiler_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md251"></a>
class nvvk::ProfilerVK</h2>
<p><a class="el" href="classnvvk_1_1_profiler_v_k.html">nvvk::ProfilerVK</a> derives from <a class="el" href="classnvh_1_1_profiler.html">nvh::Profiler</a> and uses vkCmdWriteTimestamp to measure the gpu time within a section.</p>
<p>If profiler.setLabelUsage(true) was used then it will make use of vkCmdDebugMarkerBeginEXT and vkCmdDebugMarkerEndEXT for each section so that it shows up in tools like NsightGraphics and renderdoc.</p>
<p>Currently the commandbuffers must support vkCmdResetQueryPool as well.</p>
<p>When multiple queues are used there could be problems with the "nesting" of sections. In that case multiple profilers, one per queue, are most likely better.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classnvvk_1_1_profiler_v_k.html">nvvk::ProfilerVK</a> profiler;</div>
<div class="line">std::string     profilerStats;</div>
<div class="line"> </div>
<div class="line">profiler.init(device, physicalDevice, queueFamilyIndex);</div>
<div class="line">profiler.setLabelUsage(<span class="keyword">true</span>); <span class="comment">// depends on VK_EXT_debug_utils</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">  profiler.beginFrame();</div>
<div class="line"> </div>
<div class="line">  ... setup frame ...</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// use the Section class to time the scope</span></div>
<div class="line">    <span class="keyword">auto</span> sec = profiler.timeRecurring(<span class="stringliteral">&quot;draw&quot;</span>, cmd);</div>
<div class="line"> </div>
<div class="line">    vkCmdDraw(cmd, ...);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  ... submit cmd buffer ...</div>
<div class="line"> </div>
<div class="line">  profiler.endFrame();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// generic print to string</span></div>
<div class="line">  profiler.print(profilerStats);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// or access data directly</span></div>
<div class="line">  <a class="code hl_struct" href="structnvh_1_1_profiler_1_1_timer_info.html">nvh::Profiler::TimerInfo</a> info;</div>
<div class="line">  <span class="keywordflow">if</span>( profiler.getTimerInfo(<span class="stringliteral">&quot;draw&quot;</span>, info)) {</div>
<div class="line">    <span class="comment">// do some updates</span></div>
<div class="line">    updateProfilerUi(<span class="stringliteral">&quot;draw&quot;</span>, info.gpu.average);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassnvvk_1_1_profiler_v_k_html"><div class="ttname"><a href="classnvvk_1_1_profiler_v_k.html">nvvk::ProfilerVK</a></div><div class="ttdef"><b>Definition</b> profiler_vk.hpp:89</div></div>
<div class="ttc" id="astructnvh_1_1_profiler_1_1_timer_info_html"><div class="ttname"><a href="structnvh_1_1_profiler_1_1_timer_info.html">nvh::Profiler::TimerInfo</a></div><div class="ttdef"><b>Definition</b> profiler.hpp:174</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md252"></a>
raypicker_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md253"></a>
class nvvk::RayPickerKHR</h2>
<p><a class="el" href="structnvvk_1_1_ray_picker_k_h_r.html">nvvk::RayPickerKHR</a> is a utility to get hit information under a screen coordinate.</p>
<p>The information returned is:</p><ul>
<li>origin and direction in world space</li>
<li>hitT, the distance of the hit along the ray direction</li>
<li>primitiveID, instanceID and instanceCustomIndex</li>
<li>the barycentric coordinates in the triangle</li>
</ul>
<p>Setting up:</p><ul>
<li>call setup() once with the Vulkan device, and allocator</li>
<li>call setTlas with the TLAS previously build</li>
</ul>
<p>Getting results, for example, on mouse down:</p><ul>
<li>fill the PickInfo structure</li>
<li>call run()</li>
<li>call getResult() to get all the information above</li>
</ul>
<p>Example to set the camera interest point </p><div class="fragment"><div class="line">RayPickerKHR::PickResult pr = m_picker.getResult();</div>
<div class="line"><span class="keywordflow">if</span>(pr.instanceID != ~0) <span class="comment">// Hit something</span></div>
<div class="line">{</div>
<div class="line">  glm::vec3 worldPos = pr.worldRayOrigin + pr.worldRayDirection * pr.hitT;</div>
<div class="line">  glm::vec3 eye, center, up;</div>
<div class="line">  CameraManip.getLookat(eye, center, up);</div>
<div class="line">  CameraManip.setLookat(eye, worldPos, up, <span class="keyword">false</span>); <span class="comment">// Nice with CameraManip.updateAnim();</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md254"></a>
raytraceKHR_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md255"></a>
class nvvk::RaytracingBuilderKHR</h2>
<blockquote class="doxtable">
<p>&zwj; nvvk::RaytracingBuilderKHR is a base functionality of raytracing </p>
</blockquote>
<p>This class acts as an owning container for a single top-level acceleration structure referencing any number of bottom-level acceleration structures. We provide functions for building (on the device) an array of BLASs and a single TLAS from vectors of BlasInput and Instance, respectively, and a destroy function for cleaning up the created acceleration structures.</p>
<p>Generally, we reference BLASs by their index in the stored BLAS array, rather than using raw device pointers as the pure Vulkan acceleration structure API uses.</p>
<p>This class does not support replacing acceleration structures once built, but you can update the acceleration structures. For educational purposes, this class prioritizes (relative) understandability over performance, so vkQueueWaitIdle is implicitly used everywhere.</p>
<h2><a class="anchor" id="autotoc_md256"></a>
Setup and Usage</h2>
<div class="fragment"><div class="line"><span class="comment">// Borrow a VkDevice and memory allocator pointer (must remain</span></div>
<div class="line"><span class="comment">// valid throughout our use of the ray trace builder), and</span></div>
<div class="line"><span class="comment">// instantiate an unspecified queue of the given family for use.</span></div>
<div class="line">m_rtBuilder.setup(device, memoryAllocator, queueIndex);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You create a vector of RayTracingBuilderKHR::BlasInput then</span></div>
<div class="line"><span class="comment">// pass it to buildBlas.</span></div>
<div class="line">std::vector&lt;RayTracingBuilderKHR::BlasInput&gt; inputs = <span class="comment">// ...</span></div>
<div class="line">m_rtBuilder.buildBlas(inputs);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You create a vector of RaytracingBuilder::Instance and pass to</span></div>
<div class="line"><span class="comment">// buildTlas. The blasId member of each instance must be below</span></div>
<div class="line"><span class="comment">// inputs.size() (above).</span></div>
<div class="line">std::vector&lt;VkAccelerationStructureInstanceKHR&gt; instances = <span class="comment">// ...</span></div>
<div class="line">m_rtBuilder.buildTlas(instances);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve the handle to the acceleration structure.</span></div>
<div class="line"><span class="keyword">const</span> VkAccelerationStructureKHR tlas = m.rtBuilder.getAccelerationStructure()</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md257"></a>
raytraceNV_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md258"></a>
class nvvk::RaytracingBuilderNV</h2>
<blockquote class="doxtable">
<p>&zwj; nvvk::RaytracingBuilderNV is a base functionality of raytracing </p>
</blockquote>
<p>This class does not implement all what you need to do raytracing, but helps creating the BLAS and TLAS, which then can be used by different raytracing usage.</p>
<h2><a class="anchor" id="autotoc_md259"></a>
Setup and Usage</h2>
<div class="fragment"><div class="line">m_rtBuilder.setup(device, memoryAllocator, queueIndex);</div>
<div class="line"><span class="comment">// Create array of VkGeometryNV</span></div>
<div class="line">m_rtBuilder.buildBlas(allBlas);</div>
<div class="line"><span class="comment">// Create array of RaytracingBuilder::instance</span></div>
<div class="line">m_rtBuilder.buildTlas(instances);</div>
<div class="line"><span class="comment">// Retrieve the acceleration structure</span></div>
<div class="line"><span class="keyword">const</span> VkAccelerationStructureNV&amp; tlas = m.rtBuilder.getAccelerationStructure()</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md260"></a>
renderpasses_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md261"></a>
functions in nvvk</h2>
<ul>
<li>findSupportedFormat : returns supported VkFormat from a list of candidates (returns first match)</li>
<li>findDepthFormat : returns supported depth format (24, 32, 16-bit)</li>
<li>findDepthStencilFormat : returns supported depth-stencil format (24/8, 32/8, 16/8-bit)</li>
<li>createRenderPass : wrapper for vkCreateRenderPass</li>
</ul>
<h1><a class="anchor" id="autotoc_md262"></a>
resourceallocator_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md263"></a>
class nvvk::ResourceAllocator</h2>
<p>The goal of <a class="el" href="classnvvk_1_1_resource_allocator.html">nvvk::ResourceAllocator</a> is to aid creation of typical Vulkan resources (VkBuffer, VkImage and VkAccelerationStructure). All memory is allocated using the provided nvvk::MemAllocator and bound to the appropriate resources. The allocator contains a nvvk::StagingMemoryManager and nvvk::SamplerPool to aid this process.</p>
<p>ResourceAllocator separates object creation and memory allocation by delegating allocation of memory to an object of interface type '<a class="el" href="classnvvk_1_1_mem_allocator.html">nvvk::MemAllocator</a>'. This way the ResourceAllocator can be used with different memory allocation strategies, depending on needs. nvvk provides three implementations of MemAllocator:</p><ul>
<li><a class="el" href="classnvvk_1_1_dedicated_memory_allocator.html">nvvk::DedicatedMemoryAllocator</a> is using a very simple allocation scheme, one VkDeviceMemory object per allocation. This strategy is only useful for very simple applications due to the overhead of vkAllocateMemory and an implementation dependent bounded number of vkDeviceMemory allocations possible.</li>
<li><a class="el" href="classnvvk_1_1_d_m_a_memory_allocator.html">nvvk::DMAMemoryAllocator</a> delegates memory requests to a 'nvvk:DeviceMemoryAllocator', as an example implemention of a suballocator. Not thread-safe.</li>
<li><a class="el" href="classnvvk_1_1_v_m_a_memory_allocator.html">nvvk::VMAMemoryAllocator</a> delegates memory requests to a <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a>, thread-safe</li>
</ul>
<p>Utility wrapper structs contain the appropriate Vulkan resource and the appropriate nvvk::MemHandle :</p>
<ul>
<li><a class="el" href="structnvvk_1_1_buffer.html">nvvk::Buffer</a></li>
<li><a class="el" href="structnvvk_1_1_image.html">nvvk::Image</a></li>
<li><a class="el" href="structnvvk_1_1_texture.html">nvvk::Texture</a> contains VkImage and VkImageView as well as an optional VkSampler stored witin VkDescriptorImageInfo</li>
<li><a class="el" href="structnvvk_1_1_accel_n_v.html">nvvk::AccelNV</a></li>
<li><a class="el" href="structnvvk_1_1_accel_k_h_r.html">nvvk::AccelKHR</a></li>
</ul>
<p><a class="el" href="structnvvk_1_1_buffer.html">nvvk::Buffer</a>, <a class="el" href="structnvvk_1_1_image.html">nvvk::Image</a>, <a class="el" href="structnvvk_1_1_texture.html">nvvk::Texture</a> and <a class="el" href="structnvvk_1_1_accel_k_h_r.html">nvvk::AccelKHR</a> <a class="el" href="structnvvk_1_1_accel_n_v.html">nvvk::AccelNV</a> objects can be copied by value. They do not track lifetime of the underlying Vulkan objects and memory allocations. The corresponding destroy() functions of <a class="el" href="classnvvk_1_1_resource_allocator.html">nvvk::ResourceAllocator</a> destroy created objects and free up their memory. ResourceAllocator does not track usage of objects either. Thus, one has to make sure that objects are no longer in use by the GPU when they get destroyed.</p>
<blockquote class="doxtable">
<p>&zwj;Note: These classes are foremost to showcase principle components that a Vulkan engine would most likely have. They are geared towards ease of use in this sample framework, and not optimized nor meant for production code. </p>
</blockquote>
<div class="fragment"><div class="line">VmaAllocator                vma;</div>
<div class="line"><a class="code hl_class" href="classnvvk_1_1_v_m_a_memory_allocator.html">nvvk::VMAMemoryAllocator</a>    memAllocator;</div>
<div class="line"><a class="code hl_class" href="classnvvk_1_1_resource_allocator.html">nvvk::ResourceAllocator</a>     resAllocator;</div>
<div class="line"> </div>
<div class="line">vma .. init</div>
<div class="line">memAllocator.init(device, physicalDevice, vma);</div>
<div class="line">resAllocator.init(device, physicalDevice, &amp;memAllocator);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">VkCommandBuffer cmd = ... transfer queue command buffer</div>
<div class="line"> </div>
<div class="line"><span class="comment">// creates new resources and</span></div>
<div class="line"><span class="comment">// implicitly triggers staging transfer copy operations into cmd</span></div>
<div class="line"><a class="code hl_struct" href="structnvvk_1_1_buffer.html">nvvk::Buffer</a> vbo = resAllocator.createBuffer(cmd, vboSize, vboData, vboUsage);</div>
<div class="line"><a class="code hl_struct" href="structnvvk_1_1_buffer.html">nvvk::Buffer</a> ibo = resAllocator.createBuffer(cmd, iboSize, iboData, iboUsage);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// use functions from staging memory manager</span></div>
<div class="line"><span class="comment">// here we associate the temporary staging resources with a fence</span></div>
<div class="line">resAllocator.finalizeStaging( fence );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// submit cmd buffer with staging copy operations</span></div>
<div class="line">vkQueueSubmit(... cmd ... fence ...)</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// if you do async uploads you would</span></div>
<div class="line"><span class="comment">// trigger garbage collection somewhere per frame</span></div>
<div class="line">resAllocator.releaseStaging();</div>
<div class="ttc" id="aclassnvvk_1_1_resource_allocator_html"><div class="ttname"><a href="classnvvk_1_1_resource_allocator.html">nvvk::ResourceAllocator</a></div><div class="ttdef"><b>Definition</b> resourceallocator_vk.hpp:212</div></div>
<div class="ttc" id="aclassnvvk_1_1_v_m_a_memory_allocator_html"><div class="ttname"><a href="classnvvk_1_1_v_m_a_memory_allocator.html">nvvk::VMAMemoryAllocator</a></div><div class="ttdef"><b>Definition</b> memallocator_vma_vk.hpp:41</div></div>
<div class="ttc" id="astructnvvk_1_1_buffer_html"><div class="ttname"><a href="structnvvk_1_1_buffer.html">nvvk::Buffer</a></div><div class="ttdef"><b>Definition</b> resourceallocator_vk.hpp:153</div></div>
</div><!-- fragment --><p>Separation of memory allocation and resource creation is very flexible, but it can be tedious to set up for simple usecases. nvvk offers three helper ResourceAllocator derived classes which internally contain the MemAllocator object and manage its lifetime:</p><ul>
<li>ResourceAllocatorDedicated</li>
<li>ResourceAllocatorDma</li>
<li>ResourceAllocatorVma</li>
</ul>
<p>In these cases, only one object needs to be created and initialized.</p>
<p>ResourceAllocator can also be subclassed to specialize some of its functionality. Examples are ExportResourceAllocator and ExplicitDeviceMaskResourceAllocator. ExportResourceAllocator injects itself into the object allocation process such that the resulting allocations can be exported or created objects may be bound to exported memory ExplicitDeviceMaskResourceAllocator overrides the devicemask of allocations such that objects can be created on a specific device in a device group.</p>
<h3><a class="anchor" id="autotoc_md264"></a>
Multi-Threading</h3>
<p>For multi-threaded usage, for example dedicating a thread to handling uploads or downloads, it is possible to use a ResourceAllocator per thread.</p>
<div class="fragment"><div class="line">ResourceAllocator resAllocatorPrimary;</div>
<div class="line">ResourceAllocator resAllocatorTransferThread;</div>
<div class="line"> </div>
<div class="line">// make sure to use a thread-safe primary memory allocator</div>
<div class="line">resAllocator.init(...);</div>
<div class="line"> </div>
<div class="line">// The res allocator used exclusively by the transfer thread will</div>
<div class="line">// use the primary&#39;s memory allocator and sampler pool. It will</div>
<div class="line">// get its own staging memory manager (which is not thread-safe)</div>
<div class="line">// so that staging memory can be accessed easily.</div>
<div class="line">resAllocatorTransferThread.init(resAllocatorPrimary);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md265"></a>
class nvvk::ResourceAllocatorDma</h2>
<p>nvvk::ResourceAllocatorDMA is a convencience class owning a <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> object. <b>Not</b> thread-safe. </p>
<h2><a class="anchor" id="autotoc_md266"></a>
class nvvk::ResourceAllocatorDma</h2>
<p>nvvk::ResourceAllocatorDMA is a convencience class owning a <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> and its simple thread-safe wrapper <a class="el" href="classnvvk_1_1_d_m_a_memory_allocator_t_s.html">nvvk::DMAMemoryAllocatorTS</a> object. </p>
<h2><a class="anchor" id="autotoc_md267"></a>
class nvvk::ResourceAllocatorDedicated</h2>
<blockquote class="doxtable">
<p>&zwj; <a class="el" href="classnvvk_1_1_resource_allocator_dedicated.html">nvvk::ResourceAllocatorDedicated</a> is a convencience class automatically creating and owning a DedicatedMemoryAllocator object </p>
</blockquote>
<p>#class <a class="el" href="classnvvk_1_1_export_resource_allocator.html">nvvk::ExportResourceAllocator</a></p>
<p>ExportResourceAllocator specializes the object allocation process such that resulting memory allocations are exportable and buffers and images can be bound to external memory. </p>
<h2><a class="anchor" id="autotoc_md268"></a>
class nvvk::ExportResourceAllocatorDedicated</h2>
<p><a class="el" href="classnvvk_1_1_export_resource_allocator_dedicated.html">nvvk::ExportResourceAllocatorDedicated</a> is a resource allocator that is using DedicatedMemoryAllocator to allocate memory and at the same time it'll make all allocations exportable. </p>
<h2><a class="anchor" id="autotoc_md269"></a>
class nvvk::ExplicitDeviceMaskResourceAllocator</h2>
<p><a class="el" href="classnvvk_1_1_explicit_device_mask_resource_allocator.html">nvvk::ExplicitDeviceMaskResourceAllocator</a> is a resource allocator that will inject a specific devicemask into each allocation, making the created allocations and objects available to only the devices in the mask.</p>
<h1><a class="anchor" id="autotoc_md270"></a>
samplers_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md271"></a>
class nvvk::SamplerPool</h2>
<p>This <a class="el" href="classnvvk_1_1_sampler_pool.html">nvvk::SamplerPool</a> class manages unique VkSampler objects. To minimize the total number of sampler objects, this class ensures that identical configurations return the same sampler</p>
<p>Example : </p><div class="fragment"><div class="line"><a class="code hl_class" href="classnvvk_1_1_sampler_pool.html">nvvk::SamplerPool</a> pool(device);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it : textures) {</div>
<div class="line">  VkSamplerCreateInfo info = {...};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// acquire ensures we create the minimal subset of samplers</span></div>
<div class="line">  it.sampler = pool.acquireSampler(info);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// you can manage releases individually, or just use deinit/destructor of pool</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> it : textures) {</div>
<div class="line">  pool.releaseSampler(it.sampler);</div>
<div class="line">}</div>
<div class="ttc" id="aclassnvvk_1_1_sampler_pool_html"><div class="ttname"><a href="classnvvk_1_1_sampler_pool.html">nvvk::SamplerPool</a></div><div class="ttdef"><b>Definition</b> samplers_vk.hpp:66</div></div>
</div><!-- fragment --><ul>
<li>makeSamplerCreateInfo : aids for sampler creation</li>
</ul>
<h1><a class="anchor" id="autotoc_md272"></a>
sbtwrapper_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md273"></a>
class nvvk::SBTWrapper</h2>
<p><a class="el" href="classnvvk_1_1_s_b_t_wrapper.html">nvvk::SBTWrapper</a> is a generic SBT builder from the ray tracing pipeline</p>
<p>The builder will iterate through the pipeline create info <code>VkRayTracingPipelineCreateInfoKHR</code> to find the number of raygen, miss, hit and callable shader groups were created. The handles for those group will be retrieved from the pipeline and written in the right order in separated buffer.</p>
<p>Convenient functions exist to retrieve all information to be used in TraceRayKHR.</p>
<h3><a class="anchor" id="autotoc_md274"></a>
Usage</h3>
<ul>
<li>Setup the builder (<code>setup()</code>)</li>
<li>After the pipeline creation, call <code>create()</code> with the same info used for the creation of the pipeline.</li>
<li>Use <code>getRegions()</code> to get all the vk::StridedDeviceAddressRegionKHR needed by TraceRayKHR()</li>
</ul>
<h4><a class="anchor" id="autotoc_md275"></a>
Example</h4>
<div class="fragment"><div class="line">m_sbtWrapper.setup(m_device, m_graphicsQueueIndex, &amp;m_alloc, m_rtProperties);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">m_sbtWrapper.create(m_rtPipeline, rayPipelineInfo);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span>&amp; regions = m_stbWrapper.getRegions();</div>
<div class="line">vkCmdTraceRaysKHR(cmdBuf, &amp;regions[0], &amp;regions[1], &amp;regions[2], &amp;regions[3], size.width, size.height, 1);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md276"></a>
Extra</h3>
<p>If data are attached to a shader group (see shaderRecord), it need to be provided independently. In this case, the user must know the group index for the group type.</p>
<p>Here the Hit group 1 and 2 has data, but not the group 0. Those functions must be called before create.</p>
<div class="fragment"><div class="line">m_sbtWrapper.addData(SBTWrapper::eHit, 1, m_hitShaderRecord[0]);</div>
<div class="line">m_sbtWrapper.addData(SBTWrapper::eHit, 2, m_hitShaderRecord[1]);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md277"></a>
Special case</h3>
<p>It is also possible to create a pipeline with only a few groups but having a SBT representing many more groups.</p>
<p>The following example shows a more complex setup. There are: 1 x raygen, 2 x miss, 2 x hit. BUT the SBT will have 3 hit by duplicating the second hit in its table. So, the same hit shader defined in the pipeline, can be called with different data.</p>
<p>In this case, the use must provide manually the information to the SBT. All extra group must be explicitly added.</p>
<p>The following show how to get handle indices provided in the pipeline, and we are adding another hit group, re-using the 4th pipeline entry. Note: we are not providing the pipelineCreateInfo, because we are manually defining it.</p>
<div class="fragment"><div class="line"><span class="comment">// Manually defining group indices</span></div>
<div class="line">m_sbtWrapper.addIndices(rayPipelineInfo); <span class="comment">// Add raygen(0), miss(1), miss(2), hit(3), hit(4) from the pipeline info</span></div>
<div class="line">m_sbtWrapper.addIndex(SBTWrapper::eHit, 4);  <span class="comment">// Adding a 3rd hit, duplicate from the hit:1, which make hit:2 available.</span></div>
<div class="line">m_sbtWrapper.addHitData(SBTWrapper::eHit, 2, m_hitShaderRecord[1]); <span class="comment">// Adding data to this hit shader</span></div>
<div class="line">m_sbtWrapper.create(m_rtPipeline);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md278"></a>
shadermodulemanager_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md279"></a>
class nvvk::ShaderModuleManager</h2>
<p>The <a class="el" href="classnvvk_1_1_shader_module_manager.html">nvvk::ShaderModuleManager</a> manages VkShaderModules stored in files (SPIR-V or GLSL)</p>
<p>Using ShaderFileManager it will find the files and resolve #include for GLSL. You must add include directories to the base-class for this.</p>
<p>It also comes with some convenience functions to reload shaders etc. That is why we pass out the ShaderModuleID rather than a VkShaderModule directly.</p>
<p>To change the compilation behavior manipulate the public member variables prior createShaderModule.</p>
<p>m_filetype is crucial for this. You can pass raw spir-v files or GLSL. If GLSL is used, shaderc must be used as well (which must be added via _add_package_ShaderC() in CMake of the project)</p>
<p>Example:</p>
<div class="fragment"><div class="line">ShaderModuleManager mgr(myDevice);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// derived from ShaderFileManager</span></div>
<div class="line">mgr.addDirectory(<span class="stringliteral">&quot;spv/&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// all shaders get this injected after #version statement</span></div>
<div class="line">mgr.m_prepend = <span class="stringliteral">&quot;#define USE_NOISE 1\n&quot;</span>;</div>
<div class="line"> </div>
<div class="line">vid = mgr.createShaderModule(VK_SHADER_STAGE_VERTEX_BIT,   <span class="stringliteral">&quot;object.vert.glsl&quot;</span>);</div>
<div class="line">fid = mgr.createShaderModule(VK_SHADER_STAGE_FRAGMENT_BIT, <span class="stringliteral">&quot;object.frag.glsl&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... later use module</span></div>
<div class="line">info.module = mgr.get(vid);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md280"></a>
shaders_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md281"></a>
functions in nvvk</h2>
<ul>
<li>createShaderModule : create the shader module from various binary code inputs</li>
<li>createShaderStageInfo: create the shader module and setup the stage from the incoming binary code</li>
</ul>
<h1><a class="anchor" id="autotoc_md282"></a>
sparse_image_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md283"></a>
struct nvvk::SparseImagePage</h2>
<blockquote class="doxtable">
<p>&zwj; Virtual texture page as a part of the partially resident texture. Contains memory bindings, offsets and status information. </p>
</blockquote>
<p>The virtual texture page is a part of the sparse texture, and contains information about its memory binding, location in the texture, and status information. </p>
<h2><a class="anchor" id="autotoc_md284"></a>
struct nvvk::SparseImage</h2>
<blockquote class="doxtable">
<p>&zwj; Sparse image object, containing the virtual texture pages and memory bindings. </p>
</blockquote>
<p>The sparse image object contains the virtual texture pages and memory bindings, as well as the memory requirements for the mip tail and the image granularity.</p>
<h1><a class="anchor" id="autotoc_md285"></a>
specialization.hpp</h1>
<h2><a class="anchor" id="autotoc_md286"></a>
class nvvk::Specialization</h2>
<blockquote class="doxtable">
<p>&zwj; Helper to generate specialization info </p>
</blockquote>
<p>Examples: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classnvvk_1_1_specialization.html">nvvk::Specialization</a> specialization;</div>
<div class="line">specialization.add(0, 5); <span class="comment">// Adding value 5 to constant_id=0</span></div>
<div class="line">VkPipelineShaderStageCreateInfo info;</div>
<div class="line">...</div>
<div class="line">info.pSpecializationInfo = specialization.getSpecialization();</div>
<div class="line">createPipeline();</div>
<div class="ttc" id="aclassnvvk_1_1_specialization_html"><div class="ttname"><a href="classnvvk_1_1_specialization.html">nvvk::Specialization</a></div><div class="ttdef"><b>Definition</b> specialization.hpp:46</div></div>
</div><!-- fragment --><p>Note: this is adding information in a vector, therefor add all values before calling getSpecialization(). Construct the pipeline before specialization get out of scope, or pointer getting invalidated by adding new values or clearing the vector of data.</p>
<h1><a class="anchor" id="autotoc_md287"></a>
stagingmemorymanager_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md288"></a>
class nvvk::StagingMemoryManager</h2>
<p><a class="el" href="classnvvk_1_1_staging_memory_manager.html">nvvk::StagingMemoryManager</a> class is a utility that manages host visible buffers and their allocations in an opaque fashion to assist asynchronous transfers between device and host. The memory for this is allocated using the provided nvvk::MemAllocator.</p>
<p>The collection of the transfer resources is represented by nvvk::StagingID.</p>
<p>The necessary buffer space is sub-allocated and recycled by using one nvvk::BufferSubAllocator per transfer direction (to or from device).</p>
<blockquote class="doxtable">
<p>&zwj;<b>WARNING:</b></p><ul>
<li>cannot manage a copy &gt; 4 GB </li>
</ul>
</blockquote>
<p>Usage:</p><ul>
<li>Enqueue transfers into your VkCommandBuffer and then finalize the copy operations.</li>
<li>Associate the copy operations with a VkFence or retrieve a SetID</li>
<li>The release of the resources allows to safely recycle the buffer space for future transfers.</li>
</ul>
<blockquote class="doxtable">
<p>&zwj;We use fences as a way to garbage collect here, however a more robust solution may be implementing some sort of ticketing/timeline system. If a fence is recycled, then this class may not be aware that the fence represents a different submission, likewise if the fence is deleted elsewhere problems can occur. You may want to use the manual "SetID" system in that case. </p>
</blockquote>
<p>Example :</p>
<div class="fragment"><div class="line">StagingMemoryManager  staging;</div>
<div class="line">staging.init(memAllocator);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enqueue copy operations of data to target buffer.</span></div>
<div class="line"><span class="comment">// This internally manages the required staging resources</span></div>
<div class="line">staging.cmdToBuffer(cmd, targetBufer, 0, targetSize, targetData);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// you can also get access to a temporary mapped pointer and fill</span></div>
<div class="line"><span class="comment">// the staging buffer directly</span></div>
<div class="line">vertices = staging.cmdToBufferT&lt;Vertex&gt;(cmd, targetBufer, 0, targetSize);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// OPTION A:</span></div>
<div class="line"><span class="comment">// associate all previous copy operations with a fence (or not)</span></div>
<div class="line">staging.finalizeResources( fence );</div>
<div class="line">..</div>
<div class="line"><span class="comment">// every once in a while call</span></div>
<div class="line">staging.releaseResources();</div>
<div class="line"><span class="comment">// this will release all those without fence, or those</span></div>
<div class="line"><span class="comment">// who had a fence that completed (but never manual SetIDs, see next).</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// OPTION B</span></div>
<div class="line"><span class="comment">// alternatively manage the resource release yourself.</span></div>
<div class="line"><span class="comment">// The SetID represents the staging resources</span></div>
<div class="line"><span class="comment">// since any last finalize.</span></div>
<div class="line">sid = staging.finalizeResourceSet();</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"><span class="comment">// You need to ensure these transfers and their staging</span></div>
<div class="line"><span class="comment">// data access completed yourself prior releasing the set.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This is particularly useful for managing downloads from</span></div>
<div class="line"><span class="comment">// device. The &quot;from&quot; functions return a pointer  where the</span></div>
<div class="line"><span class="comment">// data will be copied to. You want to use this pointer</span></div>
<div class="line"><span class="comment">// after the device-side transfer completed, and then</span></div>
<div class="line"><span class="comment">// release its resources once you are done using it.</span></div>
<div class="line"> </div>
<div class="line">staging.releaseResourceSet(sid);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md289"></a>
swapchain_vk.hpp</h1>
<h2><a class="anchor" id="autotoc_md290"></a>
class nvvk::SwapChain</h2>
<blockquote class="doxtable">
<p>&zwj; <a class="el" href="classnvvk_1_1_swap_chain.html">nvvk::SwapChain</a> is a helper to handle swapchain setup and use </p>
</blockquote>
<p>In Vulkan, we have to use <code>VkSwapchainKHR</code> to request a swap chain (front and back buffers) from the operating system and manually synchronize our and OS's access to the images within the swap chain. This helper abstracts that process.</p>
<p>For each swap chain image there is an ImageView, and one read and write semaphore synchronizing it (see <code>SwapChainAcquireState</code>).</p>
<p>To start, you need to call <code>init</code>, then <code>update</code> with the window's initial framebuffer size (for example, use <code>glfwGetFramebufferSize</code>). Then, in your render loop, you need to call <code>acquire()</code> to get the swap chain image to draw to, draw your frame (waiting and signalling the appropriate semaphores), and call <code>present()</code>.</p>
<p>Sometimes, the swap chain needs to be re-created (usually due to window resizes). <code><a class="el" href="classnvvk_1_1_swap_chain.html">nvvk::SwapChain</a></code> detects this automatically and re-creates the swap chain for you. Every new swap chain is assigned a unique ID (<code>getChangeID()</code>), allowing you to detect swap chain re-creations. This usually triggers a <code>VkDeviceWaitIdle</code>; however, if this is not appropriate, see <code>setWaitQueue()</code>.</p>
<p>Finally, there is a utility function to setup the image transitions from VK_IMAGE_LAYOUT_UNDEFINED to VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, which is the format an image must be in before it is presented.</p>
<p>Example in combination with <a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a> :</p>
<ul>
<li>get the window handle</li>
<li>create its related surface</li>
<li>make sure the Queue is the one we need to render in this surface</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// could {.cpp}be arguments of a function/method :</span></div>
<div class="line"><a class="code hl_class" href="classnvvk_1_1_context.html">nvvk::Context</a> ctx;</div>
<div class="line"><a class="code hl_class" href="class_n_v_p_window.html">NVPWindow</a>     win;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get the surface of the window in which to render</span></div>
<div class="line">VkWin32SurfaceCreateInfoKHR createInfo = {};</div>
<div class="line">... populate the fields of createInfo ...</div>
<div class="line">createInfo.hwnd = glfwGetWin32Window(win.<a class="code hl_variable" href="class_n_v_p_window.html#ac1cbb1c75f889b569d0dd54bc5eaa49e">m_internal</a>);</div>
<div class="line">result = vkCreateWin32SurfaceKHR(ctx.m_instance, &amp;createInfo, <span class="keyword">nullptr</span>, &amp;m_surface);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"><span class="comment">// make sure we assign the proper Queue to m_queueGCT, from what the surface tells us</span></div>
<div class="line">ctx.setGCTQueueWithPresent(m_surface);</div>
<div class="ttc" id="aclass_n_v_p_window_html"><div class="ttname"><a href="class_n_v_p_window.html">NVPWindow</a></div><div class="ttdef"><b>Definition</b> nvpwindow.hpp:34</div></div>
<div class="ttc" id="aclass_n_v_p_window_html_ac1cbb1c75f889b569d0dd54bc5eaa49e"><div class="ttname"><a href="class_n_v_p_window.html#ac1cbb1c75f889b569d0dd54bc5eaa49e">NVPWindow::m_internal</a></div><div class="ttdeci">struct GLFWwindow * m_internal</div><div class="ttdoc">internal delegate to GLFWwindow</div><div class="ttdef"><b>Definition</b> nvpwindow.hpp:202</div></div>
<div class="ttc" id="aclassnvvk_1_1_context_html"><div class="ttname"><a href="classnvvk_1_1_context.html">nvvk::Context</a></div><div class="ttdef"><b>Definition</b> context_vk.hpp:287</div></div>
</div><!-- fragment --><p>The initialization can happen now :</p>
<div class="fragment"><div class="line">m_swapChain.init(ctx.m_device, ctx.m_physicalDevice, ctx.m_queueGCT, ctx.m_queueGCT.familyIndex,</div>
<div class="line">                 m_surface, VK_FORMAT_B8G8R8A8_UNORM);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// after init or update you also have to setup the image layouts at some point</span></div>
<div class="line">VkCommandBuffer cmd = ...</div>
<div class="line">m_swapChain.cmdUpdateBarriers(cmd);</div>
</div><!-- fragment --><p>During a resizing of a window, you can update the swapchain as well :</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> WindowSurface::resize(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">  m_swapChain.update(w, h);</div>
<div class="line">  <span class="comment">// be cautious to also transition the image layouts</span></div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><p>A typical renderloop would look as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// handles vkAcquireNextImageKHR and setting the active image</span></div>
<div class="line"><span class="comment">// w,h only needed if update(w,h) not called reliably.</span></div>
<div class="line"><span class="keywordtype">int</span> w, h;</div>
<div class="line"><span class="keywordtype">bool</span> recreated;</div>
<div class="line">glfwGetFramebufferSize(window, &amp;w, &amp;h);</div>
<div class="line"><span class="keywordflow">if</span>(!m_swapChain.acquire(w, h, &amp;recreated, [, optional SwapChainAcquireState ptr]))</div>
<div class="line">{</div>
<div class="line">  ... handle acquire error (shouldn<span class="stringliteral">&#39;t happen)</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">VkCommandBuffer cmd = ...</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// acquire might have recreated the swap chain: respond if needed here.</span></div>
<div class="line"><span class="stringliteral">// NOTE: you can also check the recreated variable above, but this</span></div>
<div class="line"><span class="stringliteral">// only works if the swap chain was recreated this frame.</span></div>
<div class="line"><span class="stringliteral">if (m_swapChain.getChangeID() != lastChangeID){</span></div>
<div class="line"><span class="stringliteral">  // after init or resize you have to setup the image layouts</span></div>
<div class="line"><span class="stringliteral">  m_swapChain.cmdUpdateBarriers(cmd);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">  lastChangeID = m_swapChain.getChangeID();</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// do render operations either directly using the imageview</span></div>
<div class="line"><span class="stringliteral">VkImageView swapImageView = m_swapChain.getActiveImageView();</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// or you may always render offline int your own framebuffer</span></div>
<div class="line"><span class="stringliteral">// and then simply blit into the backbuffer. NOTE: use</span></div>
<div class="line"><span class="stringliteral">// m_swapChain.getWidth() / getHeight() to get blit dimensions,</span></div>
<div class="line"><span class="stringliteral">// actual swap chain image size may differ from requested width/height.</span></div>
<div class="line"><span class="stringliteral">VkImage swapImage = m_swapChain.getActiveImage();</span></div>
<div class="line"><span class="stringliteral">vkCmdBlitImage(cmd, ... swapImage ...);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// setup submit</span></div>
<div class="line"><span class="stringliteral">VkSubmitInfo submitInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO};</span></div>
<div class="line"><span class="stringliteral">submitInfo.commandBufferCount = 1;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pCommandBuffers    = &amp;cmd;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// we need to ensure to wait for the swapchain image to have been read already</span></div>
<div class="line"><span class="stringliteral">// so we can safely blit into it</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">VkSemaphore swapchainReadSemaphore      = m_swapChain-&gt;getActiveReadSemaphore();</span></div>
<div class="line"><span class="stringliteral">VkPipelineStageFlags swapchainReadFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</span></div>
<div class="line"><span class="stringliteral">submitInfo.waitSemaphoreCount = 1;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pWaitSemaphores    = &amp;swapchainReadSemaphore;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pWaitDstStageMask  = &amp;swapchainReadFlags);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// once this submit completed, it means we have written the swapchain image</span></div>
<div class="line"><span class="stringliteral">VkSemaphore swapchainWrittenSemaphore = m_swapChain-&gt;getActiveWrittenSemaphore();</span></div>
<div class="line"><span class="stringliteral">submitInfo.signalSemaphoreCount = 1;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pSignalSemaphores    = &amp;swapchainWrittenSemaphore;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// submit it</span></div>
<div class="line"><span class="stringliteral">vkQueueSubmit(m_queue, 1, &amp;submitInfo, fence);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// present via a queue that supports it</span></div>
<div class="line"><span class="stringliteral">// this will also setup the dependency for the appropriate written semaphore</span></div>
<div class="line"><span class="stringliteral">// and bump the semaphore cycle</span></div>
<div class="line"><span class="stringliteral">m_swapChain.present(m_queue);</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md291"></a>
vulkanhppsupport.hpp</h1>
<h2><a class="anchor" id="autotoc_md292"></a>
class nvvk::GraphicsPipelineGeneratorCombined</h2>
<p>In some cases the application may have each state associated to a single pipeline. For convenience, <a class="el" href="structnvvk_1_1_graphics_pipeline_generator_combined.html">nvvk::GraphicsPipelineGeneratorCombined</a> combines both the state and generator into a single object.</p>
<p>Example of usage : </p><div class="fragment"><div class="line">                        <a class="code hl_struct" href="structnvvk_1_1_graphics_pipeline_generator_combined.html">nvvk::GraphicsPipelineGeneratorCombined</a> pipelineGenerator(m_device, m_pipelineLayout, m_renderPass);</div>
<div class="line">pipelineGenerator.depthStencilState.setDepthTestEnable(<span class="keyword">true</span>);</div>
<div class="line">pipelineGenerator.rasterizationState.setCullMode(vk::CullModeFlagBits::eNone);</div>
<div class="line">pipelineGenerator.addBindingDescription({0, <span class="keyword">sizeof</span>(Vertex)});</div>
<div class="line">pipelineGenerator.addAttributeDescriptions ({</div>
<div class="line">                                            {0, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, pos))},</div>
<div class="line">                                            {1, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, nrm))},</div>
<div class="line">                                            {2, 0, vk::Format::eR32G32B32Sfloat, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(offsetof(Vertex, col))}});</div>
<div class="line"> </div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/vert_shader.vert.spv&quot;</span>), VkShaderStageFlagBits::eVertex);</div>
<div class="line">pipelineGenerator.addShader(readFile(<span class="stringliteral">&quot;spv/frag_shader.frag.spv&quot;</span>), VkShaderStageFlagBits::eFragment);</div>
<div class="line"> </div>
<div class="line">m_pipeline = pipelineGenerator.createPipeline();</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md293"></a>
class nvvk::ResourceAllocatorDma</h2>
<p>nvvk::ResourceAllocatorDMA is a convencience class owning a <a class="el" href="classnvvk_1_1_d_m_a_memory_allocator.html">nvvk::DMAMemoryAllocator</a> and <a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a> object </p>
<h2><a class="anchor" id="autotoc_md294"></a>
class nvvk::ResourceAllocatorDedicated</h2>
<blockquote class="doxtable">
<p>&zwj; <a class="el" href="classnvvk_1_1_resource_allocator_dedicated.html">nvvk::ResourceAllocatorDedicated</a> is a convencience class automatically creating and owning a DedicatedMemoryAllocator object </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md295"></a>
class nvvk::ExportResourceAllocator</h2>
<p>ExportResourceAllocator specializes the object allocation process such that resulting memory allocations are exportable and buffers and images can be bound to external memory. </p>
<h2><a class="anchor" id="autotoc_md296"></a>
class nvvk::ExportResourceAllocatorDedicated</h2>
<p><a class="el" href="classnvvk_1_1_export_resource_allocator_dedicated.html">nvvk::ExportResourceAllocatorDedicated</a> is a resource allocator that is using DedicatedMemoryAllocator to allocate memory and at the same time it'll make all allocations exportable. </p>
<h2><a class="anchor" id="autotoc_md297"></a>
class nvvk::ExplicitDeviceMaskResourceAllocator</h2>
<p><a class="el" href="classnvvk_1_1_explicit_device_mask_resource_allocator.html">nvvk::ExplicitDeviceMaskResourceAllocator</a> is a resource allocator that will inject a specific devicemask into each allocation, making the created allocations and objects available to only the devices in the mask.</p>
<h1><a class="anchor" id="autotoc_md298"></a>
vulkanhppsupport_vkgl.hpp</h1>
<h2><a class="anchor" id="autotoc_md299"></a>
class nvvkpp::ResourceAllocatorGLInterop</h2>
<blockquote class="doxtable">
<p>&zwj; ResourceAllocatorGLInterop is a helper class to manage Vulkan and OpenGL memory allocation and interop. </p>
</blockquote>
<p>This class is a wrapper around the <code>nvvk::DeviceMemoryAllocatorGL</code> and <code><a class="el" href="classnvvk_1_1_device_memory_allocator.html">nvvk::DeviceMemoryAllocator</a></code> classes, which are used to allocate memory for Vulkan and OpenGL resources. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 3 2025 15:08:46 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
