<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: nvvk::SwapChainAcquireState Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">nvpro_core
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structnvvk_1_1_swap_chain_acquire_state.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structnvvk_1_1_swap_chain_acquire_state-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nvvk::SwapChainAcquireState Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;swapchain_vk.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3b2fc90884d7db77b40d4dd25b13a745"><td class="memItemLeft" align="right" valign="top"><a id="a3b2fc90884d7db77b40d4dd25b13a745"></a>
VkImage&#160;</td><td class="memItemRight" valign="bottom"><b>image</b></td></tr>
<tr class="separator:a3b2fc90884d7db77b40d4dd25b13a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb077919677dfdba67e1bd582483b83"><td class="memItemLeft" align="right" valign="top"><a id="a6eb077919677dfdba67e1bd582483b83"></a>
VkImageView&#160;</td><td class="memItemRight" valign="bottom"><b>view</b></td></tr>
<tr class="separator:a6eb077919677dfdba67e1bd582483b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0f73579925bd8b6040cdda25b78014"><td class="memItemLeft" align="right" valign="top"><a id="a0d0f73579925bd8b6040cdda25b78014"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>index</b></td></tr>
<tr class="separator:a0d0f73579925bd8b6040cdda25b78014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a27b6be4053df2448f241357490c6c9"><td class="memItemLeft" align="right" valign="top"><a id="a5a27b6be4053df2448f241357490c6c9"></a>
VkSemaphore&#160;</td><td class="memItemRight" valign="bottom"><b>waitSem</b></td></tr>
<tr class="separator:a5a27b6be4053df2448f241357490c6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ceb914b60d80e917210ca6df1d8595"><td class="memItemLeft" align="right" valign="top"><a id="a66ceb914b60d80e917210ca6df1d8595"></a>
VkSemaphore&#160;</td><td class="memItemRight" valign="bottom"><b>signalSem</b></td></tr>
<tr class="separator:a66ceb914b60d80e917210ca6df1d8595"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>@DOC_START </p>
<h1><a class="anchor" id="autotoc_md321"></a>
class nvvk::SwapChain</h1>
<blockquote class="doxtable">
<p><a class="el" href="classnvvk_1_1_swap_chain.html">nvvk::SwapChain</a> is a helper to handle swapchain setup and use </p>
</blockquote>
<p>In Vulkan, we have to use <code>VkSwapchainKHR</code> to request a swap chain (front and back buffers) from the operating system and manually synchronize our and OS's access to the images within the swap chain. This helper abstracts that process.</p>
<p>For each swap chain image there is an ImageView, and one read and write semaphore synchronizing it (see <code><a class="el" href="structnvvk_1_1_swap_chain_acquire_state.html">SwapChainAcquireState</a></code>).</p>
<p>To start, you need to call <code>init</code>, then <code>update</code> with the window's initial framebuffer size (for example, use <code>glfwGetFramebufferSize</code>). Then, in your render loop, you need to call <code>acquire()</code> to get the swap chain image to draw to, draw your frame (waiting and signalling the appropriate semaphores), and call <code>present()</code>.</p>
<p>Sometimes, the swap chain needs to be re-created (usually due to window resizes). <code><a class="el" href="classnvvk_1_1_swap_chain.html">nvvk::SwapChain</a></code> detects this automatically and re-creates the swap chain for you. Every new swap chain is assigned a unique ID (<code>getChangeID()</code>), allowing you to detect swap chain re-creations. This usually triggers a <code>VkDeviceWaitIdle</code>; however, if this is not appropriate, see <code>setWaitQueue()</code>.</p>
<p>Finally, there is a utility function to setup the image transitions from VK_IMAGE_LAYOUT_UNDEFINED to VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, which is the format an image must be in before it is presented.</p>
<p>Example in combination with <a class="el" href="classnvvk_1_1_context.html">nvvk::Context</a> :</p>
<p>get the window handle create its related surface make sure the Queue is the one we need to render in this surface</p>
<div class="fragment"><div class="line">could {.cpp}be arguments of a <span class="keyword">function</span>/method :</div>
<div class="line"><a class="code" href="classnvvk_1_1_context.html">nvvk::Context</a> ctx;</div>
<div class="line"><a class="code" href="class_n_v_p_window.html">NVPWindow</a>     win;</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">get the surface of the window in which to render</div>
<div class="line">VkWin32SurfaceCreateInfoKHR createInfo = {};</div>
<div class="line">... populate the fields of createInfo ...</div>
<div class="line">createInfo.hwnd = glfwGetWin32Window(win.<a class="code" href="class_n_v_p_window.html#ac1cbb1c75f889b569d0dd54bc5eaa49e">m_internal</a>);</div>
<div class="line">result = vkCreateWin32SurfaceKHR(ctx.m_instance, &amp;createInfo, <span class="keyword">nullptr</span>, &amp;m_surface);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">make sure we assign the proper Queue to m_queueGCT, from what the surface tells us</div>
<div class="line">ctx.setGCTQueueWithPresent(m_surface);</div>
<div class="ttc" id="aclass_n_v_p_window_html"><div class="ttname"><a href="class_n_v_p_window.html">NVPWindow</a></div><div class="ttdef"><b>Definition:</b> nvpwindow.hpp:34</div></div>
<div class="ttc" id="aclass_n_v_p_window_html_ac1cbb1c75f889b569d0dd54bc5eaa49e"><div class="ttname"><a href="class_n_v_p_window.html#ac1cbb1c75f889b569d0dd54bc5eaa49e">NVPWindow::m_internal</a></div><div class="ttdeci">struct GLFWwindow * m_internal</div><div class="ttdoc">internal delegate to GLFWwindow</div><div class="ttdef"><b>Definition:</b> nvpwindow.hpp:202</div></div>
<div class="ttc" id="aclassnvvk_1_1_context_html"><div class="ttname"><a href="classnvvk_1_1_context.html">nvvk::Context</a></div><div class="ttdef"><b>Definition:</b> context_vk.hpp:287</div></div>
</div><!-- fragment --><p>The initialization can happen now :</p>
<div class="fragment"><div class="line">m_swapChain.init(ctx.m_device, ctx.m_physicalDevice, ctx.m_queueGCT, ctx.m_queueGCT.familyIndex,</div>
<div class="line">                 m_surface, VK_FORMAT_B8G8R8A8_UNORM);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// after init or update you also have to setup the image layouts at some point</span></div>
<div class="line">VkCommandBuffer cmd = ...</div>
<div class="line">m_swapChain.cmdUpdateBarriers(cmd);</div>
</div><!-- fragment --><p>During a resizing of a window, you can update the swapchain as well :</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> WindowSurface::resize(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h)</div>
<div class="line">{</div>
<div class="line">...</div>
<div class="line">  m_swapChain.update(w, h);</div>
<div class="line">be cautious to also transition the image layouts</div>
<div class="line">...</div>
<div class="line">}</div>
</div><!-- fragment --><p>A typical renderloop would look as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// handles vkAcquireNextImageKHR and setting the active image</span></div>
<div class="line"><span class="comment">// w,h only needed if update(w,h) not called reliably.</span></div>
<div class="line"><span class="keywordtype">int</span> w, h;</div>
<div class="line"><span class="keywordtype">bool</span> recreated;</div>
<div class="line">glfwGetFramebufferSize(window, &amp;w, &amp;h);</div>
<div class="line"><span class="keywordflow">if</span>(!m_swapChain.acquire(w, h, &amp;recreated, [, optional SwapChainAcquireState ptr]))</div>
<div class="line">{</div>
<div class="line">  ... handle acquire error (shouldn<span class="stringliteral">&#39;t happen)</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">VkCommandBuffer cmd = ...</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// acquire might have recreated the swap chain: respond if needed here.</span></div>
<div class="line"><span class="stringliteral">// NOTE: you can also check the recreated variable above, but this</span></div>
<div class="line"><span class="stringliteral">// only works if the swap chain was recreated this frame.</span></div>
<div class="line"><span class="stringliteral">if (m_swapChain.getChangeID() != lastChangeID){</span></div>
<div class="line"><span class="stringliteral">  // after init or resize you have to setup the image layouts</span></div>
<div class="line"><span class="stringliteral">  m_swapChain.cmdUpdateBarriers(cmd);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">  lastChangeID = m_swapChain.getChangeID();</span></div>
<div class="line"><span class="stringliteral">}</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// do render operations either directly using the imageview</span></div>
<div class="line"><span class="stringliteral">VkImageView swapImageView = m_swapChain.getActiveImageView();</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// or you may always render offline int your own framebuffer</span></div>
<div class="line"><span class="stringliteral">// and then simply blit into the backbuffer. NOTE: use</span></div>
<div class="line"><span class="stringliteral">// m_swapChain.getWidth() / getHeight() to get blit dimensions,</span></div>
<div class="line"><span class="stringliteral">// actual swap chain image size may differ from requested width/height.</span></div>
<div class="line"><span class="stringliteral">VkImage swapImage = m_swapChain.getActiveImage();</span></div>
<div class="line"><span class="stringliteral">vkCmdBlitImage(cmd, ... swapImage ...);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// setup submit</span></div>
<div class="line"><span class="stringliteral">VkSubmitInfo submitInfo = {VK_STRUCTURE_TYPE_SUBMIT_INFO};</span></div>
<div class="line"><span class="stringliteral">submitInfo.commandBufferCount = 1;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pCommandBuffers    = &amp;cmd;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// we need to ensure to wait for the swapchain image to have been read already</span></div>
<div class="line"><span class="stringliteral">// so we can safely blit into it</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">VkSemaphore swapchainReadSemaphore      = m_swapChain-&gt;getActiveReadSemaphore();</span></div>
<div class="line"><span class="stringliteral">VkPipelineStageFlags swapchainReadFlags = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</span></div>
<div class="line"><span class="stringliteral">submitInfo.waitSemaphoreCount = 1;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pWaitSemaphores    = &amp;swapchainReadSemaphore;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pWaitDstStageMask  = &amp;swapchainReadFlags);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// once this submit completed, it means we have written the swapchain image</span></div>
<div class="line"><span class="stringliteral">VkSemaphore swapchainWrittenSemaphore = m_swapChain-&gt;getActiveWrittenSemaphore();</span></div>
<div class="line"><span class="stringliteral">submitInfo.signalSemaphoreCount = 1;</span></div>
<div class="line"><span class="stringliteral">submitInfo.pSignalSemaphores    = &amp;swapchainWrittenSemaphore;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// submit it</span></div>
<div class="line"><span class="stringliteral">vkQueueSubmit(m_queue, 1, &amp;submitInfo, fence);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">// present via a queue that supports it</span></div>
<div class="line"><span class="stringliteral">// this will also setup the dependency for the appropriate written semaphore</span></div>
<div class="line"><span class="stringliteral">// and bump the semaphore cycle</span></div>
<div class="line"><span class="stringliteral">m_swapChain.present(m_queue);</span></div>
</div><!-- fragment --><p>@DOC_END </p>
</div><hr/>The documentation for this struct was generated from the following file:<ul>
<li>swapchain_vk.hpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacenvvk.html">nvvk</a></li><li class="navelem"><a class="el" href="structnvvk_1_1_swap_chain_acquire_state.html">SwapChainAcquireState</a></li>
    <li class="footer">Generated on Thu Apr 3 2025 15:13:49 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
