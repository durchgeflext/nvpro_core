<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nvpro_core: Table of Contents</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">nvpro_core<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_uni_2_s_s24_2_pd_f_2_micro_geom_2nvpro__core_2nvvkhl_2shaders_2_r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Table of Contents</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md406"></a></p><ul>
<li>bsdf_functions.h</li>
<li>bsdf_structs.h</li>
<li>constants.h</li>
<li>dh_comp.h</li>
<li>dh_hdr.h</li>
<li>dh_inspector.h</li>
<li>dh_lighting.h</li>
<li>dh_scn_desc.h</li>
<li>dh_sky.h</li>
<li>dh_tonemap.h</li>
<li>func.h</li>
<li>ggx.h</li>
<li>hdr_env_sampling.h</li>
<li>light_contrib.h</li>
<li>pbr_mat_eval.h</li>
<li>random.h</li>
<li>ray_util.h</li>
<li>vertex_accessor.h</li>
</ul>
<h1><a class="anchor" id="autotoc_md407"></a>
bsdf_functions.h</h1>
<blockquote class="doxtable">
<p>&zwj;Implements bidirectional scattering distribution functions (BSDFs) for physically-based rendering systems. </p>
</blockquote>
<p>To use this code, include <code>bsdf_functions.h</code>. When a ray hits a surface:</p><ul>
<li>Create a <code><a class="el" href="struct_pbr_material.html" title="@DOC_SKIP">PbrMaterial</a></code> describing the material at that point</li>
<li>Call <code>bsdfEvaluate()</code> to evaluate the scattering from one direction to another, or <code>bsdfSample()</code> to choose the next ray in the light path. See these functions' documentation for more information on their parameters and return values.</li>
</ul>
<p>See the vk_gltf_renderer and vk_mini_samples/gltf_raytrace samples for examples where these functions are used in a Monte Carlo path tracer.</p>
<p>The returned BSDF values and weights have the cosine term from the rendering equation included; e.g. the Lambert lobe returns <code>max(0.0f, cos(N, k1)) / pi</code>.</p>
<p>Advanced users can use some of the other functions in this file to evaluate and sample individual lobes, or subsets of lobes.</p>
<p>This file also provides <code>bsdfEvaluateSimple()</code> and <code>bsdfSampleSimple()</code>, which implement a simpler and faster, though less fully-featured BSDF model. The simple model only has diffuse, specular, and metallic lobes, while the full model includes diffuse, transmission, specular, metal, sheen, and clearcoat lobes (plus support for most glTF extensions).</p>
<p>Since GLSL doesn't have a distinction between public and private functions, only functions that are part of the "public API" will have annotations to appear in README.md.</p>
<p>This file (and files that it depends on) should be a GLSL/C++ polyglot, and work so long as GLM has been included:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#undef GLM_FORCE_XYZW_ONLY</span></div>
<div class="line"><span class="preprocessor">#define GLM_FORCE_SWIZZLE</span></div>
<div class="line"><span class="preprocessor">#include &lt;glm/glm.hpp&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>glm;</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;nvvkhl/shaders/bsdf_functions.h&gt;</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md408"></a>
Technical Notes</h3>
<p>NVVKHL's BSDFs are based on <a href="https://github.com/KhronosGroup/glTF">the glTF 2.0 specification</a> and <a href="https://github.com/NVIDIA/MDL-SDK/blob/203d5140b1dee89de17b26e828c4333571878629/src/mdl/jit/libbsdf/libbsdf.cpp">the NVIDIA MDL SDK's BSDF implementations</a>.</p>
<p>The largest divergence from the above is that NVVKHL's BSDF model uses a Fresnel term that depends only on the view and normal vectors, instead of the half vector. This allows it to compute weights for lobes independently, while BSDF code would normally need to sample a half vector for layer <code>i</code> to determine the Fresnel weight for layer <code>i+1</code>. This can result in slightly different glossy/diffuse blend weights (e.g. slightly differently shaped highlights on leather surfaces).</p>
<p>All lobes are energy conserving (their integral over the sphere is at most 1) and probability distribution functions (PDFs) integrate to 1 (except for areas where the sampled direction results in an absorption event).</p>
<p>All lobes use single-scattering BSDFs. Multiple-scattering lobes are a potential future improvement.</p>
<p>Most lobes use GGX normal distribution functions (NDFs) and the uncorrelated Smith shadowing-maskiung function, except for the diffuse lobe (Lambert BRDF) and the sheen lobe (<a href="https://blog.selfshadow.com/publications/s2017-shading-course/#course_content">Conty and Kulla's "Charlie" sheen</a> and a V-cavity shadowing-masking function).</p>
<h2><a class="anchor" id="autotoc_md409"></a>
<code>DIRAC</code> Define</h2>
<blockquote class="doxtable">
<p>&zwj;Special PDF value returned by <code>bsdfSample()</code> to represent an infinite impulse or singularity. </p>
</blockquote>
<p>### Function <code>absorptionCoefficient</code> </p><blockquote class="doxtable">
<p>&zwj;Returns the absorption coefficient of the material. </p>
</blockquote>
<p>### <code>LOBE_*</code> Defines </p><blockquote class="doxtable">
<p>&zwj;Indices for lobe weights returned by <code>computeLobeWeights()</code>. </p>
</blockquote>
<p>### Function <code>computeLobeWeights</code> &gt;Calculates the weights of the individual lobes inside the standard PBR material.</p>
<p>Returns an array which can be indexed using the <code>LOBE_*</code> defines. This can be used to perform your own lobe sampling.</p>
<p>Note that <code>tint</code> will be changed if the material has iridescence! (It's convenient to compute the iridescence factor here.) This means you should avoid passing a material parameter to the <code>tint</code> field. Make a temporary instead: </p><div class="fragment"><div class="line">vec3 tint = mat.baseColor;</div>
<div class="line">float[LOBE_COUNT] weights = computeLobeWeights(mat, dot(k1, mat.N), tint);</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md410"></a>
Function <code>findLobe</code></h2>
<blockquote class="doxtable">
<p>&zwj;Calculates the weights of the individual lobes inside the standard PBR material and randomly selects one. </p>
</blockquote>
<p>### Function <code>computeDispersedIOR</code> </p><blockquote class="doxtable">
<p>&zwj;Calculates the IOR at a given wavelength (in nanometers) given the base IOR and glTF dispersion factor. </p>
</blockquote>
<p>See <a href="https://github.com/KhronosGroup/glTF/tree/0251c5c0cce8daec69bd54f29f891e3d0cdb52c8/extensions/2.0/Khronos/KHR_materials_dispersion">https://github.com/KhronosGroup/glTF/tree/0251c5c0cce8daec69bd54f29f891e3d0cdb52c8/extensions/2.0/Khronos/KHR_materials_dispersion</a>. </p>
<h2><a class="anchor" id="autotoc_md411"></a>
Function <code>wavelengthToRGB</code></h2>
<blockquote class="doxtable">
<p>&zwj;Given a wavelength of light, returns an approximation to the linear RGB color of a D65 illuminant (sRGB whitepoint) sampled at a wavelength of <code>x</code> nanometers, using the CIE 2015 2-degree Standard Observer Color Matching Functions. </p>
</blockquote>
<p>This is normalized so that <code>sum(wavelengthToRGB(i), {i, WAVELENGTH_MIN, WAVELENGTH_MAX}) == vec3(1.)</code>, which means that the values it returns are usually low. You'll need to multiply by an appropriate normalization factor if you're randomly sampling it.</p>
<p>The colors here are clamped to only positive sRGB values, in case renderers have problems with colors with negative sRGB components (i.e. are valid colors but are out-of-gamut). </p>
<h2><a class="anchor" id="autotoc_md412"></a>
Function <code>bsdfEvaluate</code></h2>
<blockquote class="doxtable">
<p>&zwj;Evaluates the full BSDF model for the given material and set of directions. </p>
</blockquote>
<p>You must provide <code><a class="el" href="struct_bsdf_evaluate_data.html">BsdfEvaluateData</a></code>'s <code>k1</code>, <code>k2</code>, and <code>xi</code> parameters. (Evaluation is stochastic because this code randomly samples lobes depending on <code>xi</code>; this is valid to do in a Monte Carlo path tracer.)</p>
<p>The diffuse lobe evaluation and the sum of the specular lobe evaluations (including the cosine term from the rendering equation) will be returned in <code>data.bsdf_diffuse</code> and <code>data.bsdf_glossy</code>. Additionally, the probability that the sampling code will return this direction will be returned in <code>data.pdf</code>. </p>
<h2><a class="anchor" id="autotoc_md413"></a>
Function <code>bsdfSample</code></h2>
<blockquote class="doxtable">
<p>&zwj;Samples the full BSDF model for the given material and input direction. </p>
</blockquote>
<p>You must provide <code><a class="el" href="struct_bsdf_sample_data.html">BsdfSampleData</a></code>'s <code>k1</code> and <code>xi</code> parameters. This function will set the other parameters of <code><a class="el" href="struct_bsdf_sample_data.html">BsdfSampleData</a></code>.</p>
<p>There are two things you should check after calling this function:</p><ul>
<li>Is <code>data.event_type</code> equal to <code>BSDF_EVENT_ABSORB</code>? If so, the sampler sampled an output direction that would be absorbed by the material (e.g. it chose a reflective lobe but sampled a vector below the surface). The light path ends here.</li>
<li>Is <code>data.pdf</code> equal to <code>DIRAC</code>? If so, this sampled a perfectly specular lobe. If you're using Multiple Importance Sampling weights, you should compute them as if <code>data.pdf</code> was infinity.</li>
</ul>
<h2><a class="anchor" id="autotoc_md414"></a>
Simple BSDF Model</h2>
<p>The functions below are used to evaluate and sample the BSDF for a simple PBR material, without any additional lobes like clearcoat, sheen, etc. and without the need of random numbers. This is based on the metallic/roughness BRDF in Appendix B of the glTF specification. </p>
<h2><a class="anchor" id="autotoc_md415"></a>
Function <code>bsdfEvaluateSimple</code></h2>
<blockquote class="doxtable">
<p>&zwj;Evaluates the simple BSDF model using the given material and input and output directions. </p>
</blockquote>
<p>You must provide <code>data.k1</code> and <code>data.k2</code>, but do not need to provide <code>data.xi</code>. </p>
<h2><a class="anchor" id="autotoc_md416"></a>
Function <code>bsdfSampleSimple</code></h2>
<blockquote class="doxtable">
<p>&zwj;Evaluates the simple BSDF model using the given material and input and output directions. </p>
</blockquote>
<p>You must provide <code>data.k1</code> and <code>data.xi</code>. For one sample of pure reflection (e.g. vk_mini_samples/ray_trace), use <code>data.xi == vec2(0,0)</code>.</p>
<p>After calling this function, you should check if <code>data.event_type</code> is <code>BSDF_EVENT_ABSORB</code>. If so, the sampling code sampled a direction below the surface, and the light path ends here (it should be treated as a reflectance of 0).</p>
<p>This code cannot currently return a PDF of <code>DIRAC</code>, but that might change in the future. </p>
<h2><a class="anchor" id="autotoc_md417"></a>
Function <code>bsdfSimpleAverageReflectance</code></h2>
<blockquote class="doxtable">
<p>&zwj;Returns the approximate average reflectance of the Simple BSDF &ndash; that is, <code>average_over_k2(f(k1, k2))</code> &ndash; if GGX didn't lose energy. </p>
</blockquote>
<p>This is useful for things like the variance reduction algorithm in Tomasz Stachowiak's <em>Stochastic Screen-Space Reflections</em>; see also Ray-Tracing Gems 1, chapter 32, <em>Accurate Real-Time Specular Reflections with Radiance Caching</em>.</p>
<h1><a class="anchor" id="autotoc_md418"></a>
bsdf_structs.h</h1>
<h2><a class="anchor" id="autotoc_md419"></a>
<code>BSDF_EVENT*</code> Defines</h2>
<blockquote class="doxtable">
<p>&zwj;These are the flags of the <code>BsdfSampleData::event_type</code> bitfield, which indicates the type of lobe that was sampled. </p>
</blockquote>
<p>This terminology is based on McGuire et al., "A Taxonomy of Bidirectional
Scattering Distribution Function Lobes for Rendering Engineers", <a href="https://casual-effects.com/research/McGuire2020BSDF/McGuire2020BSDF.pdf">https://casual-effects.com/research/McGuire2020BSDF/McGuire2020BSDF.pdf</a>. </p>
<h2><a class="anchor" id="autotoc_md420"></a>
struct <code>BsdfEvaluateData</code></h2>
<blockquote class="doxtable">
<p>&zwj;Data structure for evaluating a BSDF. See the file for parameter documentation. </p>
</blockquote>
<p>### struct <code><a class="el" href="struct_bsdf_sample_data.html">BsdfSampleData</a></code> </p><blockquote class="doxtable">
<p>&zwj;Data structure for sampling a BSDF. See the file for parameter documentation. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md421"></a>
constants.h</h1>
<p>Useful mathematical constants:</p><ul>
<li><code>M_PI</code> (pi)</li>
<li><code>M_TWO_PI</code> (2*pi)</li>
<li><code>M_PI_2</code> (pi/2)</li>
<li><code>M_PI_4</code> (pi/4)</li>
<li><code>M_1_OVER_PI</code> (1/pi)</li>
<li><code>M_2_OVER_PI</code> (2/pi)</li>
<li><code>M_1_PI</code> (also 1/pi)</li>
<li><code>INFINITE</code> (infinity)</li>
</ul>
<h1><a class="anchor" id="autotoc_md422"></a>
dh_comp.h</h1>
<h2><a class="anchor" id="autotoc_md423"></a>
Device/Host Polyglot Overview</h2>
<p>Files in nvvkhl named "*.h" are designed to be compiled by both C++ and GLSL code, so that they can share structure and function definitions. Not all functions will be available in both C++ and GLSL. </p>
<h2><a class="anchor" id="autotoc_md424"></a>
<code>WORKGROUP_SIZE</code> Define</h2>
<blockquote class="doxtable">
<p>&zwj;The number of threads per workgroup in X and Y used by 2D compute shaders. </p>
</blockquote>
<p>Generally, all nvvkhl compute shaders use the same workgroup size. (Workgroup sizes of 128, 256, or 512 threads are generally good choices across GPUs.) </p>
<h2><a class="anchor" id="autotoc_md425"></a>
Function <code>getGroupCounts</code></h2>
<blockquote class="doxtable">
<p>&zwj;Returns the number of workgroups needed to cover <code>size</code> threads. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md426"></a>
dh_hdr.h</h1>
<blockquote class="doxtable">
<p>&zwj;Common structures used for HDR environment maps. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md427"></a>
dh_inspector.h</h1>
<blockquote class="doxtable">
<p>&zwj;Shader header for inspecting shader variables. </p>
</blockquote>
<p>Prior to including this header either the <code>INSPECTOR_MODE_COMPUTE</code> or the <code>INSPECTOR_MODE_FRAGMENT</code> macro must be defined, depending on the type of shader to be inspected.</p>
<ul>
<li>If <code>INSPECTOR_MODE_COMPUTE</code> is defined, the shader must expose invocation information (e.g. <code>gl_LocalInvocationID</code>). This typically applies to compute, task and mesh shaders.</li>
<li>If <code>INSPECTOR_MODE_FRAGMENT</code> is defined, the shader must expose fragment information (e.g. <code>gl_FragCoord</code>). This applies to fragment shaders.</li>
</ul>
<p>You must also define the following macros:</p><ul>
<li><code>INSPECTOR_DESCRIPTOR_SET</code>: the index of the descriptor set containing the Inspector buffers.</li>
<li><code>INSPECTOR_INSPECTION_DATA_BINDING</code>: the binding index of the buffer containing the inspection information, as provided by <code>ElementInspector::getComputeInspectionBuffer()</code>.</li>
<li><code>INSPECTOR_METADATA_BINDING</code>: the binding index of the buffer containing the inspection metadata, as provided by <code>ElementInspector::getComputeMetadataBuffer()</code></li>
</ul>
<p>You can also set <code>INSPECTOR_MODE_CUSTOM</code>, <code>INSPECTOR_CUSTOM_INSPECTION_DATA_BINDING</code>, and <code>INSPECTOR_CUSTOM_METADATA_BINDING</code> to inspect more than one variable per thread. </p>
<h2><a class="anchor" id="autotoc_md428"></a>
Function <code>inspect32BitValue</code></h2>
<blockquote class="doxtable">
<p>&zwj;Use this to inspect a 32-bit value at a given index. </p>
</blockquote>
<p>### Function <code>inspectCustom32BitValue</code> </p><blockquote class="doxtable">
<p>&zwj;Use this to inspect a custom 32-bit value at a given index. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md429"></a>
dh_lighting.h</h1>
<p>Common structures used for lights other than environment lighting.</p>
<h1><a class="anchor" id="autotoc_md430"></a>
dh_scn_desc.h</h1>
<p>Common structures used to store glTF scenes in GPU buffers.</p>
<h1><a class="anchor" id="autotoc_md431"></a>
dh_sky.h</h1>
<blockquote class="doxtable">
<p>&zwj;Contains structures and functions for procedural sky models. </p>
</blockquote>
<p>This file includes two sky models: a simple sky that is fast to compute, and a more complex "physical sky" model based on a model from Mental Ray, customized for nvpro-samples. </p>
<h2><a class="anchor" id="autotoc_md432"></a>
Struct <code>SkySamplingResult</code></h2>
<blockquote class="doxtable">
<p>&zwj;Contains the resulting direction, probability density function, and radiance from sampling the procedural sky. </p>
</blockquote>
<p>### Struct <code><a class="el" href="struct_sky_push_constant.html">SkyPushConstant</a></code> </p><blockquote class="doxtable">
<p>&zwj;Used by shaders that bake the procedural sky to a texture. </p>
</blockquote>
<p>### Struct <code><a class="el" href="struct_simple_sky_parameters.html">SimpleSkyParameters</a></code> </p><blockquote class="doxtable">
<p>&zwj;Parameters for the simple sky model. </p>
</blockquote>
<p>### Function <code>initSimpleSkyParameters</code> </p><blockquote class="doxtable">
<p>&zwj;Initializes <code><a class="el" href="struct_simple_sky_parameters.html">SimpleSkyParameters</a></code> with default values. </p>
</blockquote>
<p>### Function <code>evalSimpleSky</code> </p><blockquote class="doxtable">
<p>&zwj;Returns the radiance of the simple sky model in a given view direction. </p>
</blockquote>
<p>### Function <code>sampleSimpleSky</code> </p><blockquote class="doxtable">
<p>&zwj;Samples the simple sky model using two random values, returning a <code><a class="el" href="struct_sky_sampling_result.html">SkySamplingResult</a></code>. </p>
</blockquote>
<p>### Struct <code><a class="el" href="struct_physical_sky_parameters.html">PhysicalSkyParameters</a></code> </p><blockquote class="doxtable">
<p>&zwj;Parameters for the physical sky model. </p>
</blockquote>
<p>### Function <code>initPhysicalSkyParameters</code> </p><blockquote class="doxtable">
<p>&zwj;Initializes <code><a class="el" href="struct_physical_sky_parameters.html">PhysicalSkyParameters</a></code> with default, realistic parameters. </p>
</blockquote>
<p>### Function <code>evalPhysicalSky</code> </p><blockquote class="doxtable">
<p>&zwj;Returns the radiance of the physical sky model in a given direction. </p>
</blockquote>
<p>### Function <code>samplePhysicalSky</code> </p><blockquote class="doxtable">
<p>&zwj;Samples the physical sky model using two random values, returning a <code><a class="el" href="struct_sky_sampling_result.html">SkySamplingResult</a></code>. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md433"></a>
dh_tonemap.h</h1>
<blockquote class="doxtable">
<p>&zwj;Contains implementations for several local tone mappers. </p>
</blockquote>
<p>### Struct <code><a class="el" href="struct_tonemapper.html">Tonemapper</a></code> </p><blockquote class="doxtable">
<p>&zwj;<a class="el" href="struct_tonemapper.html">Tonemapper</a> settings. </p>
</blockquote>
<p>### Struct <code>defaultTonemapper</code> </p><blockquote class="doxtable">
<p>&zwj;Returns default tonemapper settings: filmic tone mapping, no additional color correction. </p>
</blockquote>
<p>### Function <code>toSrgb</code> </p><blockquote class="doxtable">
<p>&zwj;Converts a color from linear RGB to sRGB. </p>
</blockquote>
<p>### Function <code>toLinear</code> </p><blockquote class="doxtable">
<p>&zwj;Converts a color from sRGB to linear RGB. </p>
</blockquote>
<p>### Function <code>tonemapFilmic</code> </p><blockquote class="doxtable">
<p>&zwj;Filmic tonemapping operator by Jim Hejl and Richard Burgess-Dawson, approximating the Digital Fusion Cineon mode, but more saturated and with darker midtones. sRGB correction is built in. </p>
</blockquote>
<p><a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">http://filmicworlds.com/blog/filmic-tonemapping-operators/</a> </p>
<h2><a class="anchor" id="autotoc_md434"></a>
Function <code>tonemapUncharted</code></h2>
<blockquote class="doxtable">
<p>&zwj;Tone mapping operator from Uncharted 2 by John Hable. sRGB correction is built in. </p>
</blockquote>
<p>See: <a href="http://filmicworlds.com/blog/filmic-tonemapping-operators/">http://filmicworlds.com/blog/filmic-tonemapping-operators/</a> </p>
<h2><a class="anchor" id="autotoc_md435"></a>
Function <code>tonemapACES</code></h2>
<blockquote class="doxtable">
<p>&zwj;An approximation by Stephen Hill to the Academy Color Encoding System's filmic curve for displaying HDR images on LDR output devices. </p>
</blockquote>
<p>From <a href="https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl">https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl</a>, via <a href="https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/">https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/</a> </p>
<h2><a class="anchor" id="autotoc_md436"></a>
Function <code>tonemapAgX</code></h2>
<blockquote class="doxtable">
<p>&zwj;Benjamin Wrensch's approximation to the AgX tone mapping curve by Troy Sobotka. </p>
</blockquote>
<p>From <a href="https://iolite-engine.com/blog_posts/minimal_agx_implementation">https://iolite-engine.com/blog_posts/minimal_agx_implementation</a> </p>
<h2><a class="anchor" id="autotoc_md437"></a>
Function <code>tonemapKhronosPBR</code></h2>
<blockquote class="doxtable">
<p>&zwj;The Khronos PBR neutral tone mapper. </p>
</blockquote>
<p>Adapted from <a href="https://github.com/KhronosGroup/ToneMapping/blob/main/PBR_Neutral/pbrNeutral.glsl">https://github.com/KhronosGroup/ToneMapping/blob/main/PBR_Neutral/pbrNeutral.glsl</a> </p><blockquote class="doxtable">
<p>&zwj;Applies the given tone mapper and color grading settings to a given color. </p>
</blockquote>
<p>Requires the UV coordinate so that it can apply vignetting.</p>
<h1><a class="anchor" id="autotoc_md438"></a>
func.h</h1>
<p>Useful utility functions for shaders. </p>
<h2><a class="anchor" id="autotoc_md439"></a>
Function <code>saturate</code></h2>
<blockquote class="doxtable">
<p>&zwj;Clamps a value to the range [0,1]. </p>
</blockquote>
<p>### Function <code>luminance</code> </p><blockquote class="doxtable">
<p>&zwj;Returns the luminance of a linear RGB color, using Rec. 709 coefficients. </p>
</blockquote>
<p>### Function <code>clampedDot</code> </p><blockquote class="doxtable">
<p>&zwj;Takes the dot product of two values and clamps the result to [0,1]. </p>
</blockquote>
<p>### Function <code>orthonormalBasis</code> </p><blockquote class="doxtable">
<p>&zwj;Builds an orthonormal basis: given only a normal vector, returns a </p>
</blockquote>
<p>tangent and bitangent.</p>
<p>This uses the technique from "Improved accuracy when building an orthonormal
basis" by Nelson Max, <a href="https://jcgt.org/published/0006/01/02">https://jcgt.org/published/0006/01/02</a>.</p>
<p>Any tangent-generating algorithm must produce at least one discontinuity when operating on a sphere (due to the hairy ball theorem); this has a small ring-shaped discontinuity at <code>normal.z == -0.99998796</code>. </p>
<h2><a class="anchor" id="autotoc_md440"></a>
Function <code>makeFastTangent</code></h2>
<blockquote class="doxtable">
<p>&zwj;Like <code>orthonormalBasis()</code>, but returns a tangent and tangent sign that matches the glTF convention. </p>
</blockquote>
<p>### Function <code>rotate</code> </p><blockquote class="doxtable">
<p>&zwj;Rotates the vector <code>v</code> around the unit direction <code>k</code> by an angle of <code>theta</code>. </p>
</blockquote>
<p>At <code>theta == pi/2</code>, returns <code>cross(k, v) + k * dot(k, v)</code>. This means that rotations are clockwise in right-handed coordinate systems and counter-clockwise in left-handed coordinate systems. </p>
<h2><a class="anchor" id="autotoc_md441"></a>
Function <code>getSphericalUv</code></h2>
<blockquote class="doxtable">
<p>&zwj;Given a direction, returns the UV coordinate of an environment map for that direction using a spherical projection. </p>
</blockquote>
<p>### Function <code>mixBary</code> </p><blockquote class="doxtable">
<p>&zwj;Interpolates between 3 values, using the barycentric coordinates of a triangle. </p>
</blockquote>
<p>### Function <code>cosineSampleHemisphere &lt;blockquote&gt;&amp;zwj;Samples a hemisphere using a cosine-weighted distribution. &lt;/blockquote&gt; See <a href="https://www.realtimerendering.com/raytracinggems/unofficial_RayTracingGems_v1.4.pdf">https://www.realtimerendering.com/raytracinggems/unofficial_RayTracingGems_v1.4.pdf</a>, section 16.6.1, "COSINE-WEIGHTED HEMISPHERE ORIENTED TO THE Z-AXIS". @subsection autotoc_md442 Function</code>powerHeuristic<code> &lt;blockquote&gt;&amp;zwj;The power heuristic for multiple importance sampling, with</code>beta = 2`. </p>
<p>See equation 9.13 of <a href="https://graphics.stanford.edu/papers/veach_thesis/thesis.pdf">https://graphics.stanford.edu/papers/veach_thesis/thesis.pdf</a>.</p>
<h1><a class="anchor" id="autotoc_md443"></a>
ggx.h</h1>
<p>Lower-level mathematical functions used for BSDFs. This file is named after the GGX normal distribution, which is the basis for much of nvvkhl's BSDF code, but includes Fresnel, shadowing-masking, sheen, and thin-film functions as well. </p>
<h2><a class="anchor" id="autotoc_md444"></a>
Function <code>hvd_ggx_eval</code></h2>
<blockquote class="doxtable">
<p>&zwj;Evaluates anisotropic GGX distribution on the non-projected hemisphere (i.e. +z is up) </p>
</blockquote>
<p>### Function <code>hvd_ggx_sample_vndf</code> </p><blockquote class="doxtable">
<p>&zwj;Samples Samples a visible (Smith-masked) half vector according to the anisotropic GGX distribution. </p>
</blockquote>
<p>See Eric Heitz, "A Simpler and Exact Sampling Routine for the GGX Distribution of Visible Normals".</p>
<p>The input and output will be in local space: <code>vec3(dot(T, k1), dot(B, k1), dot(N, k1))</code>. </p>
<h2><a class="anchor" id="autotoc_md445"></a>
Function <code>ggx_smith_shadow_mask</code></h2>
<blockquote class="doxtable">
<p>&zwj;The uncorrelated Smith shadowing-masking function. </p>
</blockquote>
<p>Note that the joint Smith shadowing-masking function may be more realistic. </p>
<h2><a class="anchor" id="autotoc_md446"></a>
Function <code>ior_fresnel</code></h2>
<blockquote class="doxtable">
<p>&zwj;Fresnel equation for an equal mix of polarization. </p>
</blockquote>
<p>### Function <code>hvd_sheen_eval</code> </p><blockquote class="doxtable">
<p>&zwj;Evaluates the anisotropic sheen half-vector distribution on the non-projected hemisphere. </p>
</blockquote>
<p>### Function <code>vcavities_shadow_mask</code> </p><blockquote class="doxtable">
<p>&zwj;Cook-Torrance style v-cavities shadowing-masking term. </p>
</blockquote>
<p>### Function <code>hvd_sheen_sample</code> </p><blockquote class="doxtable">
<p>&zwj;Samples a half-vector according to an anisotropic sheen distribution. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md447"></a>
hdr_env_sampling.h</h1>
<h2><a class="anchor" id="autotoc_md448"></a>
Function <code>environmentSample</code></h2>
<blockquote class="doxtable">
<p>&zwj;Randomly samples a direction from an environment map. </p>
</blockquote>
<p>Inputs:</p><ul>
<li><code>envSamplingData</code>, a buffer generated by the <code>HdrEnvDome</code> code containing data for the alias method to work.</li>
<li>hdrTexture: Used to look up the environment value.</li>
<li>randVal: A uniform random vector in the range [0,1]^3.</li>
</ul>
<p>Returns <code>vec4(vec3(radiance), pdf)</code>, and sets <code>toLight</code> to the sampled direction.</p>
<p>See <a href="https://arxiv.org/pdf/1901.05423.pdf">https://arxiv.org/pdf/1901.05423.pdf</a>, Section 2.6, "The Alias Method".</p>
<h1><a class="anchor" id="autotoc_md449"></a>
light_contrib.h</h1>
<h2><a class="anchor" id="autotoc_md450"></a>
Function <code>singleLightContribution</code></h2>
<blockquote class="doxtable">
<p>&zwj;Returns an estimate of the contribution of a light to a given point on a surface. </p>
</blockquote>
<p>Inputs:</p><ul>
<li><code>light</code>: A <code><a class="el" href="struct_light.html">Light</a></code> structure; see dh_lighting.h.</li>
<li><code>surfacePos</code>: The surface position.</li>
<li><code>surfaceNormal</code>: The surface normal.</li>
<li><code>randVal</code>: Used to randomly sample points on area (disk) lights. This means that the light contribution from an area light will be noisy. </li>
</ul>
<h2><a class="anchor" id="autotoc_md451"></a>
Function <code>singleLightContribution</code> (three-argument overload)</h2>
<blockquote class="doxtable">
<p>&zwj;Like <code>singleLightContribution</code> above, but without using random values. </p>
</blockquote>
<p>Because this is equivalent to <code>singleLightContribution(..., vec2(0.0F))</code>, area lights won't be noisy, but will have harder falloff than they would otherwise have.</p>
<h1><a class="anchor" id="autotoc_md452"></a>
pbr_mat_eval.h</h1>
<p>This file takes the incoming <code><a class="el" href="struct_gltf_shade_material.html">GltfShadeMaterial</a></code> (material uploaded in a buffer) and evaluates it, basically sampling the textures, and returns the struct <code><a class="el" href="struct_pbr_material.html" title="@DOC_SKIP">PbrMaterial</a></code> which is used by the BSDF functions to evaluate and sample the material. </p>
<h2><a class="anchor" id="autotoc_md453"></a>
<code>MAT_EVAL_TEXTURE_ARRAY</code> Define</h2>
<blockquote class="doxtable">
<p>&zwj;The name of the array that contains all texture samplers. </p>
</blockquote>
<p>Defaults to <code>texturesMap</code>; you can define this before including <code>pbr_mat_eval.h</code> to use textures from a different array name. </p>
<h2><a class="anchor" id="autotoc_md454"></a>
<code>NO_TEXTURES</code> Define</h2>
<blockquote class="doxtable">
<p>&zwj;Define this before including <code>pbr_mat_eval.h</code> to use a color of <code>vec4(1.0f)</code> for everything instead of reading textures. </p>
</blockquote>
<p>### <code>MICROFACET_MIN_ROUGHNESS</code> Define </p><blockquote class="doxtable">
<p>&zwj;Minimum roughness for microfacet models. </p>
</blockquote>
<p>This protects microfacet code from dividing by 0, as well as from numerical instability around roughness == 0. However, it also means even roughness-0 surfaces will be rendered with a tiny amount of roughness.</p>
<p>This value is ad-hoc; it could probably be lowered without issue. </p>
<h2><a class="anchor" id="autotoc_md455"></a>
Function <code>evaluateMaterial</code></h2>
<blockquote class="doxtable">
<p>&zwj;From the incoming <code>material</code> and <code>mesh</code> info, return a <code><a class="el" href="struct_pbr_material.html" title="@DOC_SKIP">PbrMaterial</a></code> struct for the BSDF system. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md456"></a>
random.h</h1>
<p>Random number generation functions.</p>
<p>For even more hash functions, check out <a href="https://jcgt.org/published/0009/03/02/">Jarzynski and Olano, "Hash Functions for GPU Rendering"</a> </p>
<h2><a class="anchor" id="autotoc_md457"></a>
Function <code>xxhash32</code></h2>
<blockquote class="doxtable">
<p>&zwj;High-quality hash that takes 96 bits of data and outputs 32, roughly twice as slow as <code>pcg</code>. </p>
</blockquote>
<p>You can use this to generate a seed for subsequent random number generators; for instance, provide `uvec3(pixel.x, pixel.y, frame_number).</p>
<p>From <a href="https://github.com/Cyan4973/xxHash">https://github.com/Cyan4973/xxHash</a> and <a href="https://www.shadertoy.com/view/XlGcRh">https://www.shadertoy.com/view/XlGcRh</a>. </p>
<h2><a class="anchor" id="autotoc_md458"></a>
Function <code>pcg</code></h2>
<blockquote class="doxtable">
<p>&zwj;Fast, reasonably good hash that updates 32 bits of state and outputs 32 bits. </p>
</blockquote>
<p>This is a version of <code>pcg32i_random_t</code> from the <a href="https://www.pcg-random.org/index.html">PCG random number generator library</a>, which updates its internal state using a linear congruential generator and outputs a hash using <code>pcg_output_rxs_m_xs_32_32</code>, a more complex hash.</p>
<p>There's a section of vk_mini_path_tracer on this random number generator <a href="https://nvpro-samples.github.io/vk_mini_path_tracer/#antialiasingandpseudorandomnumbergeneration/pseudorandomnumbergenerationinglsl">here</a>. </p>
<h2><a class="anchor" id="autotoc_md459"></a>
Function <code>rand</code></h2>
<blockquote class="doxtable">
<p>&zwj;Generates a random float in [0, 1], updating an RNG state. </p>
</blockquote>
<p>This can be used to generate many random numbers! Here's an example:</p>
<div class="fragment"><div class="line">uint seed = xxhash32(vec3(pixel.xy, frame_number));</div>
<div class="line">for(int bounce = 0; bounce &lt; 50; bounce++)</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  BsdfSampleData sampleData;</div>
<div class="line">  sampleData.xi = vec3(rand(seed), rand(seed), rand(seed));</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md460"></a>
ray_util.h</h1>
<h2><a class="anchor" id="autotoc_md461"></a>
Function <code>offsetRay</code></h2>
<blockquote class="doxtable">
<p>&zwj;Adjusts the origin <code>p</code> of the ray <code>p + t*n</code> so that it is unlikely to intersect with a triangle that passes through <code>p</code>, but tries not to noticeably affect visual results. </p>
</blockquote>
<p>For a more sophisticated algorithm, see "A Fast and Robust Method for Avoiding Self-Intersection" by Carsten Wachter and Nikolaus Binder in Ray Tracing Gems volume 1. </p>
<h2><a class="anchor" id="autotoc_md462"></a>
Function <code>pointOffset</code></h2>
<blockquote class="doxtable">
<p>&zwj;Adjusts a position so that shadows match interpolated normals more closely. </p>
</blockquote>
<p>This technique comes from <a href="https://jo.dreggn.org/home/2021_terminator.pdf">"Hacking the shadow terminator"</a> by Johannes Hanika.</p>
<p>Inputs:</p><ul>
<li><code>p</code>: Point of intersection on a triangle.</li>
<li><code>p[a..c]</code>: Positions of the triangle at each vertex.</li>
<li><code>n[a..c]</code>: Normals of the triangle at each vertex.</li>
<li><code>bary</code>: Barycentric coordinate of the hit position.</li>
</ul>
<p>Returns the new position.</p>
<h1><a class="anchor" id="autotoc_md463"></a>
vertex_accessor.h</h1>
<p>Included in shaders to provide access to vertex data, so long as vertex data follows a standard form.</p>
<p>Includes <code>getTriangleIndices</code>, and <code>getVertex*</code> and <code>getInterpolatedVertex*</code> functions for all attributes. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Apr 3 2025 15:08:46 for nvpro_core by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
